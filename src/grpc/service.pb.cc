// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#include "service.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace protos {
template <typename>
PROTOBUF_CONSTEXPR Vector2D::Vector2D(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_.dist_)*/ 0

  , /*decltype(_impl_.angle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Vector2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector2DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector2DDefaultTypeInternal() {}
  union {
    Vector2D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector2DDefaultTypeInternal _Vector2D_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ball::Ball(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.relative_position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.heard_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.heard_vel_count_)*/ 0

  , /*decltype(_impl_.lost_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.dist_from_self_)*/ 0

  , /*decltype(_impl_.angle_from_self_)*/ 0
} {}
struct BallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallDefaultTypeInternal() {}
  union {
    Ball _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallDefaultTypeInternal _Ball_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Player::Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.dist_from_self_)*/ 0

  , /*decltype(_impl_.angle_from_self_)*/ 0

  , /*decltype(_impl_.id_)*/ 0

  , /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.uniform_number_count_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0

  , /*decltype(_impl_.body_direction_count_)*/ 0

  , /*decltype(_impl_.face_direction_)*/ 0

  , /*decltype(_impl_.face_direction_count_)*/ 0

  , /*decltype(_impl_.point_to_direction_)*/ 0

  , /*decltype(_impl_.point_to_direction_count_)*/ 0

  , /*decltype(_impl_.is_goalie_)*/ false

  , /*decltype(_impl_.is_kicking_)*/ false

  , /*decltype(_impl_.is_tackling_)*/ false

  , /*decltype(_impl_.dist_from_ball_)*/ 0

  , /*decltype(_impl_.angle_from_ball_)*/ 0

  , /*decltype(_impl_.ball_reach_steps_)*/ 0

  , /*decltype(_impl_.type_id_)*/ 0
} {}
struct PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerDefaultTypeInternal() {}
  union {
    Player _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerDefaultTypeInternal _Player_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Self::Self(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.id_)*/ 0

  , /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.uniform_number_count_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0

  , /*decltype(_impl_.body_direction_count_)*/ 0

  , /*decltype(_impl_.face_direction_)*/ 0

  , /*decltype(_impl_.face_direction_count_)*/ 0

  , /*decltype(_impl_.point_to_direction_)*/ 0

  , /*decltype(_impl_.point_to_direction_count_)*/ 0

  , /*decltype(_impl_.dist_from_ball_)*/ 0

  , /*decltype(_impl_.is_goalie_)*/ false

  , /*decltype(_impl_.is_kicking_)*/ false

  , /*decltype(_impl_.is_tackling_)*/ false

  , /*decltype(_impl_.is_kickable_)*/ false

  , /*decltype(_impl_.angle_from_ball_)*/ 0

  , /*decltype(_impl_.ball_reach_steps_)*/ 0

  , /*decltype(_impl_.relative_neck_direction_)*/ 0

  , /*decltype(_impl_.stamina_)*/ 0

  , /*decltype(_impl_.catch_probability_)*/ 0

  , /*decltype(_impl_.tackle_probability_)*/ 0

  , /*decltype(_impl_.foul_probability_)*/ 0

  , /*decltype(_impl_.view_width_)*/ 0

  , /*decltype(_impl_.type_id_)*/ 0

  , /*decltype(_impl_.kick_rate_)*/ 0
} {}
struct SelfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelfDefaultTypeInternal() {}
  union {
    Self _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelfDefaultTypeInternal _Self_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptInfo::InterceptInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.final_self_position_)*/nullptr
  , /*decltype(_impl_.action_type_)*/ 0

  , /*decltype(_impl_.turn_steps_)*/ 0

  , /*decltype(_impl_.turn_angle_)*/ 0

  , /*decltype(_impl_.dash_steps_)*/ 0

  , /*decltype(_impl_.dash_power_)*/ 0

  , /*decltype(_impl_.dash_dir_)*/ 0

  , /*decltype(_impl_.final_ball_dist_)*/ 0

  , /*decltype(_impl_.final_stamina_)*/ 0

  , /*decltype(_impl_.value_)*/ 0
} {}
struct InterceptInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptInfoDefaultTypeInternal() {}
  union {
    InterceptInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptInfoDefaultTypeInternal _InterceptInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptTable::InterceptTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.self_intercept_info_)*/{}
  , /*decltype(_impl_.self_reach_steps_)*/ 0

  , /*decltype(_impl_.first_teammate_reach_steps_)*/ 0

  , /*decltype(_impl_.second_teammate_reach_steps_)*/ 0

  , /*decltype(_impl_.first_opponent_reach_steps_)*/ 0

  , /*decltype(_impl_.second_opponent_reach_steps_)*/ 0

  , /*decltype(_impl_.first_teammate_id_)*/ 0

  , /*decltype(_impl_.second_teammate_id_)*/ 0

  , /*decltype(_impl_.first_opponent_id_)*/ 0

  , /*decltype(_impl_.second_opponent_id_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InterceptTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptTableDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptTableDefaultTypeInternal() {}
  union {
    InterceptTable _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptTableDefaultTypeInternal _InterceptTable_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorldModel_OurPlayersDictEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorldModel_TheirPlayersDictEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel_HeliosHomePositionsEntry_DoNotUse::WorldModel_HeliosHomePositionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WorldModel_HeliosHomePositionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModel_HeliosHomePositionsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModel_HeliosHomePositionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorldModel_HeliosHomePositionsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModel_HeliosHomePositionsEntry_DoNotUseDefaultTypeInternal _WorldModel_HeliosHomePositionsEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel::WorldModel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.teammates_)*/{}
  , /*decltype(_impl_.opponents_)*/{}
  , /*decltype(_impl_.unknowns_)*/{}
  , /*decltype(_impl_.our_players_dict_)*/{}
  , /*decltype(_impl_.their_players_dict_)*/{}
  , /*decltype(_impl_.helios_home_positions_)*/{}
  , /*decltype(_impl_.our_team_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.their_team_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.intercept_table_)*/nullptr
  , /*decltype(_impl_.self_)*/nullptr
  , /*decltype(_impl_.ball_)*/nullptr
  , /*decltype(_impl_.our_side_)*/ 0

  , /*decltype(_impl_.last_set_play_start_time_)*/ 0

  , /*decltype(_impl_.our_goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.their_goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.offside_line_x_)*/ 0

  , /*decltype(_impl_.ofside_line_x_count_)*/ 0

  , /*decltype(_impl_.kickable_teammate_id_)*/ 0

  , /*decltype(_impl_.kickable_opponent_id_)*/ 0

  , /*decltype(_impl_.last_kick_side_)*/ 0

  , /*decltype(_impl_.last_kicker_uniform_number_)*/ 0

  , /*decltype(_impl_.cycle_)*/ 0

  , /*decltype(_impl_.game_mode_type_)*/ 0

  , /*decltype(_impl_.left_team_score_)*/ 0

  , /*decltype(_impl_.right_team_score_)*/ 0

  , /*decltype(_impl_.stoped_cycle_)*/ 0

  , /*decltype(_impl_.is_our_set_play_)*/ false

  , /*decltype(_impl_.is_their_set_play_)*/ false

  , /*decltype(_impl_.is_penalty_kick_mode_)*/ false

  , /*decltype(_impl_.our_team_score_)*/ 0

  , /*decltype(_impl_.their_team_score_)*/ 0
} {}
struct WorldModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModelDefaultTypeInternal() {}
  union {
    WorldModel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModelDefaultTypeInternal _WorldModel_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR State::State(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.world_model_)*/nullptr
  , /*decltype(_impl_.full_world_model_)*/nullptr
  , /*decltype(_impl_.agent_type_)*/ 0
} {}
struct StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateDefaultTypeInternal() {}
  union {
    State _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateDefaultTypeInternal _State_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InitMessage::InitMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.agent_type_)*/ 0

  , /*decltype(_impl_.debug_mode_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InitMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitMessageDefaultTypeInternal() {}
  union {
    InitMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitMessageDefaultTypeInternal _InitMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Dash::Dash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_)*/ 0

  , /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DashDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DashDefaultTypeInternal() {}
  union {
    Dash _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DashDefaultTypeInternal _Dash_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Turn::Turn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TurnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnDefaultTypeInternal() {}
  union {
    Turn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnDefaultTypeInternal _Turn_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Kick::Kick(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_)*/ 0

  , /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KickDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KickDefaultTypeInternal() {}
  union {
    Kick _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KickDefaultTypeInternal _Kick_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Tackle::Tackle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_or_dir_)*/ 0

  , /*decltype(_impl_.foul_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TackleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TackleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TackleDefaultTypeInternal() {}
  union {
    Tackle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TackleDefaultTypeInternal _Tackle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Catch::Catch(
    ::_pbi::ConstantInitialized) {}
struct CatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CatchDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CatchDefaultTypeInternal() {}
  union {
    Catch _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CatchDefaultTypeInternal _Catch_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Move::Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDefaultTypeInternal() {}
  union {
    Move _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDefaultTypeInternal _Move_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TurnNeck::TurnNeck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.moment_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TurnNeckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnNeckDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnNeckDefaultTypeInternal() {}
  union {
    TurnNeck _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnNeckDefaultTypeInternal _TurnNeck_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ChangeView::ChangeView(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.view_width_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChangeViewDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeViewDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeViewDefaultTypeInternal() {}
  union {
    ChangeView _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeViewDefaultTypeInternal _ChangeView_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BallMessage::BallMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr} {}
struct BallMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallMessageDefaultTypeInternal() {}
  union {
    BallMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallMessageDefaultTypeInternal _BallMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PassMessage::PassMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.receiver_point_)*/nullptr
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr
  , /*decltype(_impl_.receiver_uniform_number_)*/ 0
} {}
struct PassMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PassMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PassMessageDefaultTypeInternal() {}
  union {
    PassMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PassMessageDefaultTypeInternal _PassMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptMessage::InterceptMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.our_)*/ false

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.cycle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InterceptMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptMessageDefaultTypeInternal() {}
  union {
    InterceptMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptMessageDefaultTypeInternal _InterceptMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GoalieMessage::GoalieMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.goalie_position_)*/nullptr
  , /*decltype(_impl_.goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.goalie_body_direction_)*/ 0
} {}
struct GoalieMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GoalieMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GoalieMessageDefaultTypeInternal() {}
  union {
    GoalieMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GoalieMessageDefaultTypeInternal _GoalieMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GoalieAndPlayerMessage::GoalieAndPlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.goalie_position_)*/nullptr
  , /*decltype(_impl_.player_position_)*/nullptr
  , /*decltype(_impl_.goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.goalie_body_direction_)*/ 0

  , /*decltype(_impl_.player_uniform_number_)*/ 0
} {}
struct GoalieAndPlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GoalieAndPlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GoalieAndPlayerMessageDefaultTypeInternal() {}
  union {
    GoalieAndPlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GoalieAndPlayerMessageDefaultTypeInternal _GoalieAndPlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OffsideLineMessage::OffsideLineMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.offside_line_x_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OffsideLineMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OffsideLineMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OffsideLineMessageDefaultTypeInternal() {}
  union {
    OffsideLineMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OffsideLineMessageDefaultTypeInternal _OffsideLineMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DefenseLineMessage::DefenseLineMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.defense_line_x_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DefenseLineMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DefenseLineMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DefenseLineMessageDefaultTypeInternal() {}
  union {
    DefenseLineMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefenseLineMessageDefaultTypeInternal _DefenseLineMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WaitRequestMessage::WaitRequestMessage(
    ::_pbi::ConstantInitialized) {}
struct WaitRequestMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaitRequestMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaitRequestMessageDefaultTypeInternal() {}
  union {
    WaitRequestMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaitRequestMessageDefaultTypeInternal _WaitRequestMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetplayMessage::SetplayMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wait_step_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetplayMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetplayMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetplayMessageDefaultTypeInternal() {}
  union {
    SetplayMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetplayMessageDefaultTypeInternal _SetplayMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PassRequestMessage::PassRequestMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr} {}
struct PassRequestMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PassRequestMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PassRequestMessageDefaultTypeInternal() {}
  union {
    PassRequestMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PassRequestMessageDefaultTypeInternal _PassRequestMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StaminaMessage::StaminaMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stamina_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StaminaMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaminaMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaminaMessageDefaultTypeInternal() {}
  union {
    StaminaMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaminaMessageDefaultTypeInternal _StaminaMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RecoveryMessage::RecoveryMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recovery_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecoveryMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecoveryMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecoveryMessageDefaultTypeInternal() {}
  union {
    RecoveryMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecoveryMessageDefaultTypeInternal _RecoveryMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StaminaCapacityMessage::StaminaCapacityMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stamina_capacity_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StaminaCapacityMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaminaCapacityMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaminaCapacityMessageDefaultTypeInternal() {}
  union {
    StaminaCapacityMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaminaCapacityMessageDefaultTypeInternal _StaminaCapacityMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DribbleMessage::DribbleMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.queue_count_)*/ 0
} {}
struct DribbleMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DribbleMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DribbleMessageDefaultTypeInternal() {}
  union {
    DribbleMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DribbleMessageDefaultTypeInternal _DribbleMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BallGoalieMessage::BallGoalieMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr
  , /*decltype(_impl_.goalie_position_)*/nullptr
  , /*decltype(_impl_.goalie_body_direction_)*/ 0
} {}
struct BallGoalieMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallGoalieMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallGoalieMessageDefaultTypeInternal() {}
  union {
    BallGoalieMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallGoalieMessageDefaultTypeInternal _BallGoalieMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OnePlayerMessage::OnePlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0
} {}
struct OnePlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnePlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnePlayerMessageDefaultTypeInternal() {}
  union {
    OnePlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnePlayerMessageDefaultTypeInternal _OnePlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TwoPlayerMessage::TwoPlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.first_position_)*/nullptr
  , /*decltype(_impl_.second_position_)*/nullptr
  , /*decltype(_impl_.first_uniform_number_)*/ 0

  , /*decltype(_impl_.second_uniform_number_)*/ 0
} {}
struct TwoPlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TwoPlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TwoPlayerMessageDefaultTypeInternal() {}
  union {
    TwoPlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TwoPlayerMessageDefaultTypeInternal _TwoPlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ThreePlayerMessage::ThreePlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.first_position_)*/nullptr
  , /*decltype(_impl_.second_position_)*/nullptr
  , /*decltype(_impl_.third_position_)*/nullptr
  , /*decltype(_impl_.first_uniform_number_)*/ 0

  , /*decltype(_impl_.second_uniform_number_)*/ 0

  , /*decltype(_impl_.third_uniform_number_)*/ 0
} {}
struct ThreePlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreePlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreePlayerMessageDefaultTypeInternal() {}
  union {
    ThreePlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreePlayerMessageDefaultTypeInternal _ThreePlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SelfMessage::SelfMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.self_position_)*/nullptr
  , /*decltype(_impl_.self_body_direction_)*/ 0

  , /*decltype(_impl_.self_stamina_)*/ 0
} {}
struct SelfMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelfMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelfMessageDefaultTypeInternal() {}
  union {
    SelfMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelfMessageDefaultTypeInternal _SelfMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TeammateMessage::TeammateMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0
} {}
struct TeammateMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TeammateMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TeammateMessageDefaultTypeInternal() {}
  union {
    TeammateMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TeammateMessageDefaultTypeInternal _TeammateMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OpponentMessage::OpponentMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0
} {}
struct OpponentMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpponentMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpponentMessageDefaultTypeInternal() {}
  union {
    OpponentMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpponentMessageDefaultTypeInternal _OpponentMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BallPlayerMessage::BallPlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr
  , /*decltype(_impl_.player_position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0
} {}
struct BallPlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallPlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallPlayerMessageDefaultTypeInternal() {}
  union {
    BallPlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallPlayerMessageDefaultTypeInternal _BallPlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Say::Say(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SayDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SayDefaultTypeInternal() {}
  union {
    Say _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SayDefaultTypeInternal _Say_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointTo::PointTo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointToDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointToDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointToDefaultTypeInternal() {}
  union {
    PointTo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointToDefaultTypeInternal _PointTo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointToOf::PointToOf(
    ::_pbi::ConstantInitialized) {}
struct PointToOfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointToOfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointToOfDefaultTypeInternal() {}
  union {
    PointToOf _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointToOfDefaultTypeInternal _PointToOf_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AttentionTo::AttentionTo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.unum_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AttentionToDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttentionToDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttentionToDefaultTypeInternal() {}
  union {
    AttentionTo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttentionToDefaultTypeInternal _AttentionTo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AttentionToOf::AttentionToOf(
    ::_pbi::ConstantInitialized) {}
struct AttentionToOfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttentionToOfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttentionToOfDefaultTypeInternal() {}
  union {
    AttentionToOf _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttentionToOfDefaultTypeInternal _AttentionToOf_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddText::AddText(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AddTextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddTextDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddTextDefaultTypeInternal() {}
  union {
    AddText _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddTextDefaultTypeInternal _AddText_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddPoint::AddPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0
} {}
struct AddPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddPointDefaultTypeInternal() {}
  union {
    AddPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddPointDefaultTypeInternal _AddPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddLine::AddLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0
} {}
struct AddLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddLineDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddLineDefaultTypeInternal() {}
  union {
    AddLine _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddLineDefaultTypeInternal _AddLine_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddArc::AddArc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.center_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.radius_)*/ 0

  , /*decltype(_impl_.start_angle_)*/ 0

  , /*decltype(_impl_.span_angel_)*/ 0
} {}
struct AddArcDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddArcDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddArcDefaultTypeInternal() {}
  union {
    AddArc _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddArcDefaultTypeInternal _AddArc_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddCircle::AddCircle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.center_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.radius_)*/ 0

  , /*decltype(_impl_.fill_)*/ false
} {}
struct AddCircleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddCircleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddCircleDefaultTypeInternal() {}
  union {
    AddCircle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddCircleDefaultTypeInternal _AddCircle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddTriangle::AddTriangle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.point1_)*/nullptr
  , /*decltype(_impl_.point2_)*/nullptr
  , /*decltype(_impl_.point3_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.fill_)*/ false
} {}
struct AddTriangleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddTriangleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddTriangleDefaultTypeInternal() {}
  union {
    AddTriangle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddTriangleDefaultTypeInternal _AddTriangle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddRectangle::AddRectangle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.left_)*/ 0

  , /*decltype(_impl_.top_)*/ 0

  , /*decltype(_impl_.length_)*/ 0

  , /*decltype(_impl_.width_)*/ 0

  , /*decltype(_impl_.fill_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AddRectangleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddRectangleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddRectangleDefaultTypeInternal() {}
  union {
    AddRectangle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddRectangleDefaultTypeInternal _AddRectangle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddSector::AddSector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.center_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.min_radius_)*/ 0

  , /*decltype(_impl_.max_radius_)*/ 0

  , /*decltype(_impl_.start_angle_)*/ 0

  , /*decltype(_impl_.span_angel_)*/ 0

  , /*decltype(_impl_.fill_)*/ false
} {}
struct AddSectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddSectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddSectorDefaultTypeInternal() {}
  union {
    AddSector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddSectorDefaultTypeInternal _AddSector_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddMessage::AddMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0
} {}
struct AddMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddMessageDefaultTypeInternal() {}
  union {
    AddMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddMessageDefaultTypeInternal _AddMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Log::Log(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.log_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogDefaultTypeInternal() {}
  union {
    Log _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogDefaultTypeInternal _Log_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DebugClient::DebugClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DebugClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DebugClientDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DebugClientDefaultTypeInternal() {}
  union {
    DebugClient _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DebugClientDefaultTypeInternal _DebugClient_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_GoToPoint::Body_GoToPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.distance_threshold_)*/ 0

  , /*decltype(_impl_.max_dash_power_)*/ 0
} {}
struct Body_GoToPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_GoToPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_GoToPointDefaultTypeInternal() {}
  union {
    Body_GoToPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_GoToPointDefaultTypeInternal _Body_GoToPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_SmartKick::Body_SmartKick(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.first_speed_)*/ 0

  , /*decltype(_impl_.first_speed_threshold_)*/ 0

  , /*decltype(_impl_.max_steps_)*/ 0
} {}
struct Body_SmartKickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_SmartKickDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_SmartKickDefaultTypeInternal() {}
  union {
    Body_SmartKick _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_SmartKickDefaultTypeInternal _Body_SmartKick_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_BeforeKickOff::Bhv_BeforeKickOff(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr} {}
struct Bhv_BeforeKickOffDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_BeforeKickOffDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_BeforeKickOffDefaultTypeInternal() {}
  union {
    Bhv_BeforeKickOff _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_BeforeKickOffDefaultTypeInternal _Bhv_BeforeKickOff_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_BodyNeckToBall::Bhv_BodyNeckToBall(
    ::_pbi::ConstantInitialized) {}
struct Bhv_BodyNeckToBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_BodyNeckToBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_BodyNeckToBallDefaultTypeInternal() {}
  union {
    Bhv_BodyNeckToBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_BodyNeckToBallDefaultTypeInternal _Bhv_BodyNeckToBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_BodyNeckToPoint::Bhv_BodyNeckToPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr} {}
struct Bhv_BodyNeckToPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_BodyNeckToPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_BodyNeckToPointDefaultTypeInternal() {}
  union {
    Bhv_BodyNeckToPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_BodyNeckToPointDefaultTypeInternal _Bhv_BodyNeckToPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_Emergency::Bhv_Emergency(
    ::_pbi::ConstantInitialized) {}
struct Bhv_EmergencyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_EmergencyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_EmergencyDefaultTypeInternal() {}
  union {
    Bhv_Emergency _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_EmergencyDefaultTypeInternal _Bhv_Emergency_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_GoToPointLookBall::Bhv_GoToPointLookBall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.distance_threshold_)*/ 0

  , /*decltype(_impl_.max_dash_power_)*/ 0
} {}
struct Bhv_GoToPointLookBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_GoToPointLookBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_GoToPointLookBallDefaultTypeInternal() {}
  union {
    Bhv_GoToPointLookBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_GoToPointLookBallDefaultTypeInternal _Bhv_GoToPointLookBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_NeckBodyToBall::Bhv_NeckBodyToBall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.angle_buf_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Bhv_NeckBodyToBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_NeckBodyToBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_NeckBodyToBallDefaultTypeInternal() {}
  union {
    Bhv_NeckBodyToBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_NeckBodyToBallDefaultTypeInternal _Bhv_NeckBodyToBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_NeckBodyToPoint::Bhv_NeckBodyToPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.angle_buf_)*/ 0
} {}
struct Bhv_NeckBodyToPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_NeckBodyToPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_NeckBodyToPointDefaultTypeInternal() {}
  union {
    Bhv_NeckBodyToPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_NeckBodyToPointDefaultTypeInternal _Bhv_NeckBodyToPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Bhv_ScanField::Bhv_ScanField(
    ::_pbi::ConstantInitialized) {}
struct Bhv_ScanFieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Bhv_ScanFieldDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Bhv_ScanFieldDefaultTypeInternal() {}
  union {
    Bhv_ScanField _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Bhv_ScanFieldDefaultTypeInternal _Bhv_ScanField_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_AdvanceBall::Body_AdvanceBall(
    ::_pbi::ConstantInitialized) {}
struct Body_AdvanceBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_AdvanceBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_AdvanceBallDefaultTypeInternal() {}
  union {
    Body_AdvanceBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_AdvanceBallDefaultTypeInternal _Body_AdvanceBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_ClearBall::Body_ClearBall(
    ::_pbi::ConstantInitialized) {}
struct Body_ClearBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_ClearBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_ClearBallDefaultTypeInternal() {}
  union {
    Body_ClearBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_ClearBallDefaultTypeInternal _Body_ClearBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_Dribble::Body_Dribble(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.distance_threshold_)*/ 0

  , /*decltype(_impl_.dash_power_)*/ 0

  , /*decltype(_impl_.dash_count_)*/ 0

  , /*decltype(_impl_.dodge_)*/ false
} {}
struct Body_DribbleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_DribbleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_DribbleDefaultTypeInternal() {}
  union {
    Body_Dribble _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_DribbleDefaultTypeInternal _Body_Dribble_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_GoToPointDodge::Body_GoToPointDodge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.dash_power_)*/ 0
} {}
struct Body_GoToPointDodgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_GoToPointDodgeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_GoToPointDodgeDefaultTypeInternal() {}
  union {
    Body_GoToPointDodge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_GoToPointDodgeDefaultTypeInternal _Body_GoToPointDodge_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_HoldBall::Body_HoldBall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.turn_target_point_)*/nullptr
  , /*decltype(_impl_.kick_target_point_)*/nullptr
  , /*decltype(_impl_.do_turn_)*/ false
} {}
struct Body_HoldBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_HoldBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_HoldBallDefaultTypeInternal() {}
  union {
    Body_HoldBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_HoldBallDefaultTypeInternal _Body_HoldBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_Intercept::Body_Intercept(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.face_point_)*/nullptr
  , /*decltype(_impl_.save_recovery_)*/ false
} {}
struct Body_InterceptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_InterceptDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_InterceptDefaultTypeInternal() {}
  union {
    Body_Intercept _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_InterceptDefaultTypeInternal _Body_Intercept_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_KickOneStep::Body_KickOneStep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.first_speed_)*/ 0

  , /*decltype(_impl_.force_mode_)*/ false
} {}
struct Body_KickOneStepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_KickOneStepDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_KickOneStepDefaultTypeInternal() {}
  union {
    Body_KickOneStep _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_KickOneStepDefaultTypeInternal _Body_KickOneStep_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_StopBall::Body_StopBall(
    ::_pbi::ConstantInitialized) {}
struct Body_StopBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_StopBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_StopBallDefaultTypeInternal() {}
  union {
    Body_StopBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_StopBallDefaultTypeInternal _Body_StopBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_StopDash::Body_StopDash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.save_recovery_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Body_StopDashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_StopDashDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_StopDashDefaultTypeInternal() {}
  union {
    Body_StopDash _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_StopDashDefaultTypeInternal _Body_StopDash_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_TackleToPoint::Body_TackleToPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.min_probability_)*/ 0

  , /*decltype(_impl_.min_speed_)*/ 0
} {}
struct Body_TackleToPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_TackleToPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_TackleToPointDefaultTypeInternal() {}
  union {
    Body_TackleToPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_TackleToPointDefaultTypeInternal _Body_TackleToPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_TurnToAngle::Body_TurnToAngle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.angle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Body_TurnToAngleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_TurnToAngleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_TurnToAngleDefaultTypeInternal() {}
  union {
    Body_TurnToAngle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_TurnToAngleDefaultTypeInternal _Body_TurnToAngle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_TurnToBall::Body_TurnToBall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cycle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Body_TurnToBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_TurnToBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_TurnToBallDefaultTypeInternal() {}
  union {
    Body_TurnToBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_TurnToBallDefaultTypeInternal _Body_TurnToBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Body_TurnToPoint::Body_TurnToPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.cycle_)*/ 0
} {}
struct Body_TurnToPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Body_TurnToPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Body_TurnToPointDefaultTypeInternal() {}
  union {
    Body_TurnToPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Body_TurnToPointDefaultTypeInternal _Body_TurnToPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Focus_MoveToPoint::Focus_MoveToPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr} {}
struct Focus_MoveToPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Focus_MoveToPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Focus_MoveToPointDefaultTypeInternal() {}
  union {
    Focus_MoveToPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Focus_MoveToPointDefaultTypeInternal _Focus_MoveToPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Focus_Reset::Focus_Reset(
    ::_pbi::ConstantInitialized) {}
struct Focus_ResetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Focus_ResetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Focus_ResetDefaultTypeInternal() {}
  union {
    Focus_Reset _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Focus_ResetDefaultTypeInternal _Focus_Reset_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_ScanField::Neck_ScanField(
    ::_pbi::ConstantInitialized) {}
struct Neck_ScanFieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_ScanFieldDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_ScanFieldDefaultTypeInternal() {}
  union {
    Neck_ScanField _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_ScanFieldDefaultTypeInternal _Neck_ScanField_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_ScanPlayers::Neck_ScanPlayers(
    ::_pbi::ConstantInitialized) {}
struct Neck_ScanPlayersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_ScanPlayersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_ScanPlayersDefaultTypeInternal() {}
  union {
    Neck_ScanPlayers _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_ScanPlayersDefaultTypeInternal _Neck_ScanPlayers_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToBallAndPlayer::Neck_TurnToBallAndPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.count_threshold_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Neck_TurnToBallAndPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToBallAndPlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToBallAndPlayerDefaultTypeInternal() {}
  union {
    Neck_TurnToBallAndPlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToBallAndPlayerDefaultTypeInternal _Neck_TurnToBallAndPlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToBallOrScan::Neck_TurnToBallOrScan(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.count_threshold_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Neck_TurnToBallOrScanDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToBallOrScanDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToBallOrScanDefaultTypeInternal() {}
  union {
    Neck_TurnToBallOrScan _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToBallOrScanDefaultTypeInternal _Neck_TurnToBallOrScan_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToBall::Neck_TurnToBall(
    ::_pbi::ConstantInitialized) {}
struct Neck_TurnToBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToBallDefaultTypeInternal() {}
  union {
    Neck_TurnToBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToBallDefaultTypeInternal _Neck_TurnToBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToGoalieOrScan::Neck_TurnToGoalieOrScan(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.count_threshold_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Neck_TurnToGoalieOrScanDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToGoalieOrScanDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToGoalieOrScanDefaultTypeInternal() {}
  union {
    Neck_TurnToGoalieOrScan _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToGoalieOrScanDefaultTypeInternal _Neck_TurnToGoalieOrScan_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToLowConfTeammate::Neck_TurnToLowConfTeammate(
    ::_pbi::ConstantInitialized) {}
struct Neck_TurnToLowConfTeammateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToLowConfTeammateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToLowConfTeammateDefaultTypeInternal() {}
  union {
    Neck_TurnToLowConfTeammate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToLowConfTeammateDefaultTypeInternal _Neck_TurnToLowConfTeammate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToPlayerOrScan::Neck_TurnToPlayerOrScan(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.count_threshold_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Neck_TurnToPlayerOrScanDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToPlayerOrScanDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToPlayerOrScanDefaultTypeInternal() {}
  union {
    Neck_TurnToPlayerOrScan _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToPlayerOrScanDefaultTypeInternal _Neck_TurnToPlayerOrScan_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToPoint::Neck_TurnToPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr} {}
struct Neck_TurnToPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToPointDefaultTypeInternal() {}
  union {
    Neck_TurnToPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToPointDefaultTypeInternal _Neck_TurnToPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Neck_TurnToRelative::Neck_TurnToRelative(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.angle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Neck_TurnToRelativeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Neck_TurnToRelativeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Neck_TurnToRelativeDefaultTypeInternal() {}
  union {
    Neck_TurnToRelative _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Neck_TurnToRelativeDefaultTypeInternal _Neck_TurnToRelative_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR View_ChangeWidth::View_ChangeWidth(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.view_width_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct View_ChangeWidthDefaultTypeInternal {
  PROTOBUF_CONSTEXPR View_ChangeWidthDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~View_ChangeWidthDefaultTypeInternal() {}
  union {
    View_ChangeWidth _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 View_ChangeWidthDefaultTypeInternal _View_ChangeWidth_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR View_Normal::View_Normal(
    ::_pbi::ConstantInitialized) {}
struct View_NormalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR View_NormalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~View_NormalDefaultTypeInternal() {}
  union {
    View_Normal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 View_NormalDefaultTypeInternal _View_Normal_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR View_Synch::View_Synch(
    ::_pbi::ConstantInitialized) {}
struct View_SynchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR View_SynchDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~View_SynchDefaultTypeInternal() {}
  union {
    View_Synch _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 View_SynchDefaultTypeInternal _View_Synch_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR View_Wide::View_Wide(
    ::_pbi::ConstantInitialized) {}
struct View_WideDefaultTypeInternal {
  PROTOBUF_CONSTEXPR View_WideDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~View_WideDefaultTypeInternal() {}
  union {
    View_Wide _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 View_WideDefaultTypeInternal _View_Wide_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosGoalie::HeliosGoalie(
    ::_pbi::ConstantInitialized) {}
struct HeliosGoalieDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosGoalieDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosGoalieDefaultTypeInternal() {}
  union {
    HeliosGoalie _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosGoalieDefaultTypeInternal _HeliosGoalie_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosGoalieMove::HeliosGoalieMove(
    ::_pbi::ConstantInitialized) {}
struct HeliosGoalieMoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosGoalieMoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosGoalieMoveDefaultTypeInternal() {}
  union {
    HeliosGoalieMove _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosGoalieMoveDefaultTypeInternal _HeliosGoalieMove_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosGoalieKick::HeliosGoalieKick(
    ::_pbi::ConstantInitialized) {}
struct HeliosGoalieKickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosGoalieKickDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosGoalieKickDefaultTypeInternal() {}
  union {
    HeliosGoalieKick _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosGoalieKickDefaultTypeInternal _HeliosGoalieKick_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosShoot::HeliosShoot(
    ::_pbi::ConstantInitialized) {}
struct HeliosShootDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosShootDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosShootDefaultTypeInternal() {}
  union {
    HeliosShoot _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosShootDefaultTypeInternal _HeliosShoot_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosChainAction::HeliosChainAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.direct_pass_)*/ false

  , /*decltype(_impl_.lead_pass_)*/ false

  , /*decltype(_impl_.through_pass_)*/ false

  , /*decltype(_impl_.short_dribble_)*/ false

  , /*decltype(_impl_.long_dribble_)*/ false

  , /*decltype(_impl_.cross_)*/ false

  , /*decltype(_impl_.simple_pass_)*/ false

  , /*decltype(_impl_.simple_dribble_)*/ false

  , /*decltype(_impl_.simple_shoot_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeliosChainActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosChainActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosChainActionDefaultTypeInternal() {}
  union {
    HeliosChainAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosChainActionDefaultTypeInternal _HeliosChainAction_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosBasicOffensive::HeliosBasicOffensive(
    ::_pbi::ConstantInitialized) {}
struct HeliosBasicOffensiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosBasicOffensiveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosBasicOffensiveDefaultTypeInternal() {}
  union {
    HeliosBasicOffensive _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosBasicOffensiveDefaultTypeInternal _HeliosBasicOffensive_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosBasicMove::HeliosBasicMove(
    ::_pbi::ConstantInitialized) {}
struct HeliosBasicMoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosBasicMoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosBasicMoveDefaultTypeInternal() {}
  union {
    HeliosBasicMove _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosBasicMoveDefaultTypeInternal _HeliosBasicMove_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosSetPlay::HeliosSetPlay(
    ::_pbi::ConstantInitialized) {}
struct HeliosSetPlayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosSetPlayDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosSetPlayDefaultTypeInternal() {}
  union {
    HeliosSetPlay _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosSetPlayDefaultTypeInternal _HeliosSetPlay_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosPenalty::HeliosPenalty(
    ::_pbi::ConstantInitialized) {}
struct HeliosPenaltyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosPenaltyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosPenaltyDefaultTypeInternal() {}
  union {
    HeliosPenalty _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosPenaltyDefaultTypeInternal _HeliosPenalty_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HeliosCommunicaion::HeliosCommunicaion(
    ::_pbi::ConstantInitialized) {}
struct HeliosCommunicaionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeliosCommunicaionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeliosCommunicaionDefaultTypeInternal() {}
  union {
    HeliosCommunicaion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeliosCommunicaionDefaultTypeInternal _HeliosCommunicaion_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PlayerAction::PlayerAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.action_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PlayerActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerActionDefaultTypeInternal() {}
  union {
    PlayerAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerActionDefaultTypeInternal _PlayerAction_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PlayerActions::PlayerActions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.actions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerActionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerActionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerActionsDefaultTypeInternal() {}
  union {
    PlayerActions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerActionsDefaultTypeInternal _PlayerActions_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ChangePlayerType::ChangePlayerType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChangePlayerTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangePlayerTypeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangePlayerTypeDefaultTypeInternal() {}
  union {
    ChangePlayerType _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangePlayerTypeDefaultTypeInternal _ChangePlayerType_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoHeliosSubstitute::DoHeliosSubstitute(
    ::_pbi::ConstantInitialized) {}
struct DoHeliosSubstituteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoHeliosSubstituteDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoHeliosSubstituteDefaultTypeInternal() {}
  union {
    DoHeliosSubstitute _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoHeliosSubstituteDefaultTypeInternal _DoHeliosSubstitute_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoHeliosSayPlayerTypes::DoHeliosSayPlayerTypes(
    ::_pbi::ConstantInitialized) {}
struct DoHeliosSayPlayerTypesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoHeliosSayPlayerTypesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoHeliosSayPlayerTypesDefaultTypeInternal() {}
  union {
    DoHeliosSayPlayerTypes _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoHeliosSayPlayerTypesDefaultTypeInternal _DoHeliosSayPlayerTypes_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CoachAction::CoachAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.action_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CoachActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoachActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoachActionDefaultTypeInternal() {}
  union {
    CoachAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoachActionDefaultTypeInternal _CoachAction_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CoachActions::CoachActions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.actions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CoachActionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoachActionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoachActionsDefaultTypeInternal() {}
  union {
    CoachActions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoachActionsDefaultTypeInternal _CoachActions_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoKickOff::DoKickOff(
    ::_pbi::ConstantInitialized) {}
struct DoKickOffDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoKickOffDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoKickOffDefaultTypeInternal() {}
  union {
    DoKickOff _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoKickOffDefaultTypeInternal _DoKickOff_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoMoveBall::DoMoveBall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr} {}
struct DoMoveBallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoMoveBallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoMoveBallDefaultTypeInternal() {}
  union {
    DoMoveBall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoMoveBallDefaultTypeInternal _DoMoveBall_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoMovePlayer::DoMovePlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.our_side_)*/ false

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0
} {}
struct DoMovePlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoMovePlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoMovePlayerDefaultTypeInternal() {}
  union {
    DoMovePlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoMovePlayerDefaultTypeInternal _DoMovePlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoRecover::DoRecover(
    ::_pbi::ConstantInitialized) {}
struct DoRecoverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoRecoverDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoRecoverDefaultTypeInternal() {}
  union {
    DoRecover _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoRecoverDefaultTypeInternal _DoRecover_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoChangeMode::DoChangeMode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.game_mode_type_)*/ 0

  , /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DoChangeModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoChangeModeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoChangeModeDefaultTypeInternal() {}
  union {
    DoChangeMode _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoChangeModeDefaultTypeInternal _DoChangeMode_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DoChangePlayerType::DoChangePlayerType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.our_side_)*/ false

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DoChangePlayerTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoChangePlayerTypeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoChangePlayerTypeDefaultTypeInternal() {}
  union {
    DoChangePlayerType _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoChangePlayerTypeDefaultTypeInternal _DoChangePlayerType_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TrainerAction::TrainerAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.action_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TrainerActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrainerActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrainerActionDefaultTypeInternal() {}
  union {
    TrainerAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainerActionDefaultTypeInternal _TrainerAction_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TrainerActions::TrainerActions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.actions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrainerActionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrainerActionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrainerActionsDefaultTypeInternal() {}
  union {
    TrainerActions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainerActionsDefaultTypeInternal _TrainerActions_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ServerParam::ServerParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.replay_file_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.landmark_file_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.text_log_dir_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.game_log_dir_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.text_log_fixed_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.game_log_fixed_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.log_date_format_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.team_l_start_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.team_r_start_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.keepaway_log_dir_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.keepaway_log_fixed_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.module_dir_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.coach_msg_file_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fixed_teamname_l_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fixed_teamname_r_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.agent_type_)*/ 0

  , /*decltype(_impl_.inertia_moment_)*/ 0

  , /*decltype(_impl_.player_size_)*/ 0

  , /*decltype(_impl_.player_decay_)*/ 0

  , /*decltype(_impl_.player_rand_)*/ 0

  , /*decltype(_impl_.player_weight_)*/ 0

  , /*decltype(_impl_.player_speed_max_)*/ 0

  , /*decltype(_impl_.player_accel_max_)*/ 0

  , /*decltype(_impl_.stamina_max_)*/ 0

  , /*decltype(_impl_.stamina_inc_max_)*/ 0

  , /*decltype(_impl_.recover_init_)*/ 0

  , /*decltype(_impl_.recover_dec_thr_)*/ 0

  , /*decltype(_impl_.recover_min_)*/ 0

  , /*decltype(_impl_.recover_dec_)*/ 0

  , /*decltype(_impl_.effort_init_)*/ 0

  , /*decltype(_impl_.effort_dec_thr_)*/ 0

  , /*decltype(_impl_.effort_min_)*/ 0

  , /*decltype(_impl_.effort_dec_)*/ 0

  , /*decltype(_impl_.effort_inc_thr_)*/ 0

  , /*decltype(_impl_.effort_inc_)*/ 0

  , /*decltype(_impl_.kick_rand_)*/ 0

  , /*decltype(_impl_.player_rand_factor_l_)*/ 0

  , /*decltype(_impl_.player_rand_factor_r_)*/ 0

  , /*decltype(_impl_.kick_rand_factor_l_)*/ 0

  , /*decltype(_impl_.kick_rand_factor_r_)*/ 0

  , /*decltype(_impl_.ball_size_)*/ 0

  , /*decltype(_impl_.ball_decay_)*/ 0

  , /*decltype(_impl_.ball_rand_)*/ 0

  , /*decltype(_impl_.ball_weight_)*/ 0

  , /*decltype(_impl_.ball_speed_max_)*/ 0

  , /*decltype(_impl_.ball_accel_max_)*/ 0

  , /*decltype(_impl_.dash_power_rate_)*/ 0

  , /*decltype(_impl_.kick_power_rate_)*/ 0

  , /*decltype(_impl_.kickable_margin_)*/ 0

  , /*decltype(_impl_.control_radius_)*/ 0

  , /*decltype(_impl_.control_radius_width_)*/ 0

  , /*decltype(_impl_.max_power_)*/ 0

  , /*decltype(_impl_.min_power_)*/ 0

  , /*decltype(_impl_.max_moment_)*/ 0

  , /*decltype(_impl_.min_moment_)*/ 0

  , /*decltype(_impl_.max_neck_moment_)*/ 0

  , /*decltype(_impl_.min_neck_moment_)*/ 0

  , /*decltype(_impl_.max_neck_angle_)*/ 0

  , /*decltype(_impl_.min_neck_angle_)*/ 0

  , /*decltype(_impl_.visible_angle_)*/ 0

  , /*decltype(_impl_.visible_distance_)*/ 0

  , /*decltype(_impl_.wind_dir_)*/ 0

  , /*decltype(_impl_.wind_force_)*/ 0

  , /*decltype(_impl_.wind_angle_)*/ 0

  , /*decltype(_impl_.wind_rand_)*/ 0

  , /*decltype(_impl_.kickable_area_)*/ 0

  , /*decltype(_impl_.catch_area_l_)*/ 0

  , /*decltype(_impl_.catch_area_w_)*/ 0

  , /*decltype(_impl_.catch_probability_)*/ 0

  , /*decltype(_impl_.team_actuator_noise_)*/ false

  , /*decltype(_impl_.wind_none_)*/ false

  , /*decltype(_impl_.use_wind_random_)*/ false

  , /*decltype(_impl_.use_offside_)*/ false

  , /*decltype(_impl_.goalie_max_moves_)*/ 0

  , /*decltype(_impl_.corner_kick_margin_)*/ 0

  , /*decltype(_impl_.offside_active_area_size_)*/ 0

  , /*decltype(_impl_.coach_say_count_max_)*/ 0

  , /*decltype(_impl_.coach_say_msg_size_)*/ 0

  , /*decltype(_impl_.clang_win_size_)*/ 0

  , /*decltype(_impl_.clang_define_win_)*/ 0

  , /*decltype(_impl_.clang_meta_win_)*/ 0

  , /*decltype(_impl_.clang_advice_win_)*/ 0

  , /*decltype(_impl_.clang_info_win_)*/ 0

  , /*decltype(_impl_.clang_mess_delay_)*/ 0

  , /*decltype(_impl_.clang_mess_per_cycle_)*/ 0

  , /*decltype(_impl_.half_time_)*/ 0

  , /*decltype(_impl_.simulator_step_)*/ 0

  , /*decltype(_impl_.send_step_)*/ 0

  , /*decltype(_impl_.recv_step_)*/ 0

  , /*decltype(_impl_.sense_body_step_)*/ 0

  , /*decltype(_impl_.lcm_step_)*/ 0

  , /*decltype(_impl_.player_say_msg_size_)*/ 0

  , /*decltype(_impl_.player_hear_max_)*/ 0

  , /*decltype(_impl_.player_hear_inc_)*/ 0

  , /*decltype(_impl_.player_hear_decay_)*/ 0

  , /*decltype(_impl_.catch_ban_cycle_)*/ 0

  , /*decltype(_impl_.slow_down_factor_)*/ 0

  , /*decltype(_impl_.offside_kick_margin_)*/ 0

  , /*decltype(_impl_.audio_cut_dist_)*/ 0

  , /*decltype(_impl_.dist_quantize_step_)*/ 0

  , /*decltype(_impl_.landmark_dist_quantize_step_)*/ 0

  , /*decltype(_impl_.dir_quantize_step_)*/ 0

  , /*decltype(_impl_.dist_quantize_step_l_)*/ 0

  , /*decltype(_impl_.dist_quantize_step_r_)*/ 0

  , /*decltype(_impl_.landmark_dist_quantize_step_l_)*/ 0

  , /*decltype(_impl_.landmark_dist_quantize_step_r_)*/ 0

  , /*decltype(_impl_.kickoff_offside_)*/ false

  , /*decltype(_impl_.coach_mode_)*/ false

  , /*decltype(_impl_.coach_with_referee_mode_)*/ false

  , /*decltype(_impl_.use_old_coach_hear_)*/ false

  , /*decltype(_impl_.dir_quantize_step_l_)*/ 0

  , /*decltype(_impl_.dir_quantize_step_r_)*/ 0

  , /*decltype(_impl_.slowness_on_top_for_left_team_)*/ 0

  , /*decltype(_impl_.slowness_on_top_for_right_team_)*/ 0

  , /*decltype(_impl_.start_goal_l_)*/ 0

  , /*decltype(_impl_.start_goal_r_)*/ 0

  , /*decltype(_impl_.drop_ball_time_)*/ 0

  , /*decltype(_impl_.fullstate_l_)*/ false

  , /*decltype(_impl_.fullstate_r_)*/ false

  , /*decltype(_impl_.synch_mode_)*/ false

  , /*decltype(_impl_.verbose_mode_)*/ false

  , /*decltype(_impl_.synch_offset_)*/ 0

  , /*decltype(_impl_.synch_micro_sleep_)*/ 0

  , /*decltype(_impl_.point_to_ban_)*/ 0

  , /*decltype(_impl_.point_to_duration_)*/ 0

  , /*decltype(_impl_.player_port_)*/ 0

  , /*decltype(_impl_.trainer_port_)*/ 0

  , /*decltype(_impl_.online_coach_port_)*/ 0

  , /*decltype(_impl_.coach_send_vi_step_)*/ 0

  , /*decltype(_impl_.send_comms_)*/ false

  , /*decltype(_impl_.text_logging_)*/ false

  , /*decltype(_impl_.game_logging_)*/ false

  , /*decltype(_impl_.use_text_log_fixed_)*/ false

  , /*decltype(_impl_.game_log_version_)*/ 0

  , /*decltype(_impl_.use_game_log_fixed_)*/ false

  , /*decltype(_impl_.use_text_log_dated_)*/ false

  , /*decltype(_impl_.use_game_log_dated_)*/ false

  , /*decltype(_impl_.log_times_)*/ false

  , /*decltype(_impl_.text_log_compression_)*/ 0

  , /*decltype(_impl_.game_log_compression_)*/ 0

  , /*decltype(_impl_.tackle_dist_)*/ 0

  , /*decltype(_impl_.tackle_back_dist_)*/ 0

  , /*decltype(_impl_.tackle_width_)*/ 0

  , /*decltype(_impl_.tackle_exponent_)*/ 0

  , /*decltype(_impl_.record_message_)*/ false

  , /*decltype(_impl_.use_profile_)*/ false

  , /*decltype(_impl_.free_kick_faults_)*/ false

  , /*decltype(_impl_.back_passes_)*/ false

  , /*decltype(_impl_.tackle_cycles_)*/ 0

  , /*decltype(_impl_.tackle_power_rate_)*/ 0

  , /*decltype(_impl_.freeform_wait_period_)*/ 0

  , /*decltype(_impl_.freeform_send_period_)*/ 0

  , /*decltype(_impl_.stopped_ball_vel_)*/ 0

  , /*decltype(_impl_.max_goal_kicks_)*/ 0

  , /*decltype(_impl_.clang_del_win_)*/ 0

  , /*decltype(_impl_.clang_rule_win_)*/ 0

  , /*decltype(_impl_.kick_off_wait_)*/ 0

  , /*decltype(_impl_.connect_wait_)*/ 0

  , /*decltype(_impl_.proper_goal_kicks_)*/ false

  , /*decltype(_impl_.auto_mode_)*/ false

  , /*decltype(_impl_.keepaway_mode_)*/ false

  , /*decltype(_impl_.keepaway_logging_)*/ false

  , /*decltype(_impl_.game_over_wait_)*/ 0

  , /*decltype(_impl_.keepaway_length_)*/ 0

  , /*decltype(_impl_.keepaway_width_)*/ 0

  , /*decltype(_impl_.keepaway_start_)*/ 0

  , /*decltype(_impl_.nr_normal_halfs_)*/ 0

  , /*decltype(_impl_.nr_extra_halfs_)*/ 0

  , /*decltype(_impl_.keepaway_log_fixed_)*/ false

  , /*decltype(_impl_.keepaway_log_dated_)*/ false

  , /*decltype(_impl_.penalty_shoot_outs_)*/ false

  , /*decltype(_impl_.pen_random_winner_)*/ false

  , /*decltype(_impl_.pen_before_setup_wait_)*/ 0

  , /*decltype(_impl_.pen_setup_wait_)*/ 0

  , /*decltype(_impl_.pen_ready_wait_)*/ 0

  , /*decltype(_impl_.pen_taken_wait_)*/ 0

  , /*decltype(_impl_.pen_nr_kicks_)*/ 0

  , /*decltype(_impl_.pen_max_extra_kicks_)*/ 0

  , /*decltype(_impl_.pen_dist_x_)*/ 0

  , /*decltype(_impl_.pen_max_goalie_dist_x_)*/ 0

  , /*decltype(_impl_.ball_stuck_area_)*/ 0

  , /*decltype(_impl_.max_tackle_power_)*/ 0

  , /*decltype(_impl_.max_back_tackle_power_)*/ 0

  , /*decltype(_impl_.player_speed_max_min_)*/ 0

  , /*decltype(_impl_.pen_allow_mult_kicks_)*/ false

  , /*decltype(_impl_.pen_coach_moves_players_)*/ false

  , /*decltype(_impl_.golden_goal_)*/ false

  , /*decltype(_impl_.extra_stamina_)*/ 0

  , /*decltype(_impl_.synch_see_offset_)*/ 0

  , /*decltype(_impl_.extra_half_time_)*/ 0

  , /*decltype(_impl_.stamina_capacity_)*/ 0

  , /*decltype(_impl_.max_dash_angle_)*/ 0

  , /*decltype(_impl_.min_dash_angle_)*/ 0

  , /*decltype(_impl_.dash_angle_step_)*/ 0

  , /*decltype(_impl_.side_dash_rate_)*/ 0

  , /*decltype(_impl_.back_dash_rate_)*/ 0

  , /*decltype(_impl_.max_dash_power_)*/ 0

  , /*decltype(_impl_.min_dash_power_)*/ 0

  , /*decltype(_impl_.tackle_rand_factor_)*/ 0

  , /*decltype(_impl_.foul_detect_probability_)*/ 0

  , /*decltype(_impl_.foul_exponent_)*/ 0

  , /*decltype(_impl_.foul_cycles_)*/ 0

  , /*decltype(_impl_.red_card_probability_)*/ 0

  , /*decltype(_impl_.illegal_defense_duration_)*/ 0

  , /*decltype(_impl_.illegal_defense_number_)*/ 0

  , /*decltype(_impl_.illegal_defense_dist_x_)*/ 0

  , /*decltype(_impl_.illegal_defense_width_)*/ 0

  , /*decltype(_impl_.max_catch_angle_)*/ 0

  , /*decltype(_impl_.min_catch_angle_)*/ 0

  , /*decltype(_impl_.random_seed_)*/ 0

  , /*decltype(_impl_.long_kick_power_factor_)*/ 0

  , /*decltype(_impl_.long_kick_delay_)*/ 0

  , /*decltype(_impl_.max_monitors_)*/ 0

  , /*decltype(_impl_.catchable_area_)*/ 0

  , /*decltype(_impl_.real_speed_max_)*/ 0

  , /*decltype(_impl_.pitch_half_length_)*/ 0

  , /*decltype(_impl_.pitch_half_width_)*/ 0

  , /*decltype(_impl_.our_penalty_area_line_x_)*/ 0

  , /*decltype(_impl_.their_penalty_area_line_x_)*/ 0

  , /*decltype(_impl_.penalty_area_half_width_)*/ 0

  , /*decltype(_impl_.penalty_area_length_)*/ 0

  , /*decltype(_impl_.goal_width_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServerParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerParamDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerParamDefaultTypeInternal() {}
  union {
    ServerParam _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerParamDefaultTypeInternal _ServerParam_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PlayerParam::PlayerParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.agent_type_)*/ 0

  , /*decltype(_impl_.player_types_)*/ 0

  , /*decltype(_impl_.subs_max_)*/ 0

  , /*decltype(_impl_.pt_max_)*/ 0

  , /*decltype(_impl_.allow_mult_default_type_)*/ false

  , /*decltype(_impl_.player_speed_max_delta_min_)*/ 0

  , /*decltype(_impl_.player_speed_max_delta_max_)*/ 0

  , /*decltype(_impl_.stamina_inc_max_delta_factor_)*/ 0

  , /*decltype(_impl_.player_decay_delta_min_)*/ 0

  , /*decltype(_impl_.player_decay_delta_max_)*/ 0

  , /*decltype(_impl_.inertia_moment_delta_factor_)*/ 0

  , /*decltype(_impl_.dash_power_rate_delta_min_)*/ 0

  , /*decltype(_impl_.dash_power_rate_delta_max_)*/ 0

  , /*decltype(_impl_.player_size_delta_factor_)*/ 0

  , /*decltype(_impl_.kickable_margin_delta_min_)*/ 0

  , /*decltype(_impl_.kickable_margin_delta_max_)*/ 0

  , /*decltype(_impl_.kick_rand_delta_factor_)*/ 0

  , /*decltype(_impl_.extra_stamina_delta_min_)*/ 0

  , /*decltype(_impl_.extra_stamina_delta_max_)*/ 0

  , /*decltype(_impl_.effort_max_delta_factor_)*/ 0

  , /*decltype(_impl_.effort_min_delta_factor_)*/ 0

  , /*decltype(_impl_.random_seed_)*/ 0

  , /*decltype(_impl_.new_dash_power_rate_delta_min_)*/ 0

  , /*decltype(_impl_.new_dash_power_rate_delta_max_)*/ 0

  , /*decltype(_impl_.new_stamina_inc_max_delta_factor_)*/ 0

  , /*decltype(_impl_.kick_power_rate_delta_min_)*/ 0

  , /*decltype(_impl_.kick_power_rate_delta_max_)*/ 0

  , /*decltype(_impl_.foul_detect_probability_delta_factor_)*/ 0

  , /*decltype(_impl_.catchable_area_l_stretch_min_)*/ 0

  , /*decltype(_impl_.catchable_area_l_stretch_max_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerParamDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerParamDefaultTypeInternal() {}
  union {
    PlayerParam _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerParamDefaultTypeInternal _PlayerParam_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PlayerType::PlayerType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.agent_type_)*/ 0

  , /*decltype(_impl_.id_)*/ 0

  , /*decltype(_impl_.stamina_inc_max_)*/ 0

  , /*decltype(_impl_.player_decay_)*/ 0

  , /*decltype(_impl_.inertia_moment_)*/ 0

  , /*decltype(_impl_.dash_power_rate_)*/ 0

  , /*decltype(_impl_.player_size_)*/ 0

  , /*decltype(_impl_.kickable_margin_)*/ 0

  , /*decltype(_impl_.kick_rand_)*/ 0

  , /*decltype(_impl_.extra_stamina_)*/ 0

  , /*decltype(_impl_.effort_max_)*/ 0

  , /*decltype(_impl_.effort_min_)*/ 0

  , /*decltype(_impl_.kick_power_rate_)*/ 0

  , /*decltype(_impl_.foul_detect_probability_)*/ 0

  , /*decltype(_impl_.catchable_area_l_stretch_)*/ 0

  , /*decltype(_impl_.unum_far_length_)*/ 0

  , /*decltype(_impl_.unum_too_far_length_)*/ 0

  , /*decltype(_impl_.team_far_length_)*/ 0

  , /*decltype(_impl_.team_too_far_length_)*/ 0

  , /*decltype(_impl_.player_max_observation_length_)*/ 0

  , /*decltype(_impl_.ball_vel_far_length_)*/ 0

  , /*decltype(_impl_.ball_vel_too_far_length_)*/ 0

  , /*decltype(_impl_.ball_max_observation_length_)*/ 0

  , /*decltype(_impl_.flag_chg_far_length_)*/ 0

  , /*decltype(_impl_.flag_chg_too_far_length_)*/ 0

  , /*decltype(_impl_.flag_max_observation_length_)*/ 0

  , /*decltype(_impl_.kickable_area_)*/ 0

  , /*decltype(_impl_.reliable_catchable_dist_)*/ 0

  , /*decltype(_impl_.max_catchable_dist_)*/ 0

  , /*decltype(_impl_.real_speed_max_)*/ 0

  , /*decltype(_impl_.player_speed_max2_)*/ 0

  , /*decltype(_impl_.real_speed_max2_)*/ 0

  , /*decltype(_impl_.cycles_to_reach_max_speed_)*/ 0

  , /*decltype(_impl_.player_speed_max_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerTypeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerTypeDefaultTypeInternal() {}
  union {
    PlayerType _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerTypeDefaultTypeInternal _PlayerType_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Empty::Empty(
    ::_pbi::ConstantInitialized) {}
struct EmptyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyDefaultTypeInternal _Empty_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InitMessageFromServer::InitMessageFromServer(
    ::_pbi::ConstantInitialized) {}
struct InitMessageFromServerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitMessageFromServerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitMessageFromServerDefaultTypeInternal() {}
  union {
    InitMessageFromServer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitMessageFromServerDefaultTypeInternal _InitMessageFromServer_default_instance_;
}  // namespace protos
static ::_pb::Metadata file_level_metadata_service_2eproto[127];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_service_2eproto[6];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_service_2eproto = nullptr;
const ::uint32_t TableStruct_service_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.dist_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.angle_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.relative_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.lost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.dist_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.angle_from_self_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.dist_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.angle_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.uniform_number_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_goalie_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.body_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.face_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.face_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.point_to_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.point_to_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_kicking_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.dist_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.angle_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.ball_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_tackling_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.type_id_),
    0,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.uniform_number_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_goalie_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.body_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.face_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.face_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.point_to_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.point_to_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_kicking_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.dist_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.angle_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.ball_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_tackling_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.relative_neck_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_kickable_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.catch_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.tackle_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.foul_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.view_width_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.type_id_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.kick_rate_),
    0,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.action_type_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.turn_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.turn_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_power_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_self_position_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_ball_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.value_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.self_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_teammate_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_teammate_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_opponent_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_opponent_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.self_intercept_info_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.intercept_table_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_team_name_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_team_name_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_side_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_set_play_start_time_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.self_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.ball_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.teammates_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.opponents_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.unknowns_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_players_dict_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_players_dict_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.offside_line_x_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.ofside_line_x_count_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.kickable_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.kickable_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_kick_side_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_kicker_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.game_mode_type_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.left_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.right_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.is_our_set_play_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.is_their_set_play_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.stoped_cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.is_penalty_kick_mode_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.helios_home_positions_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::State, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_.agent_type_),
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_.world_model_),
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_.full_world_model_),
    ~0u,
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::InitMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InitMessage, _impl_.agent_type_),
    PROTOBUF_FIELD_OFFSET(::protos::InitMessage, _impl_.debug_mode_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _impl_.power_),
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Turn, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Turn, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _impl_.power_),
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _impl_.power_or_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _impl_.foul_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Catch, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Move, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Move, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::Move, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::TurnNeck, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TurnNeck, _impl_.moment_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::ChangeView, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::ChangeView, _impl_.view_width_),
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _impl_.ball_velocity_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.receiver_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.receiver_point_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.ball_velocity_),
    ~0u,
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _impl_.our_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _impl_.cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_.goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_.goalie_position_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_.goalie_body_direction_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.goalie_position_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.goalie_body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.player_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.player_position_),
    ~0u,
    0,
    ~0u,
    ~0u,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::OffsideLineMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::OffsideLineMessage, _impl_.offside_line_x_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DefenseLineMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DefenseLineMessage, _impl_.defense_line_x_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::WaitRequestMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::SetplayMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::SetplayMessage, _impl_.wait_step_),
    PROTOBUF_FIELD_OFFSET(::protos::PassRequestMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::PassRequestMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PassRequestMessage, _impl_.target_point_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::StaminaMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::StaminaMessage, _impl_.stamina_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::RecoveryMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::RecoveryMessage, _impl_.recovery_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::StaminaCapacityMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::StaminaCapacityMessage, _impl_.stamina_capacity_),
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _impl_.queue_count_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.ball_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.goalie_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.goalie_body_direction_),
    0,
    1,
    2,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _impl_.position_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.first_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.first_position_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.second_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.second_position_),
    ~0u,
    0,
    ~0u,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.first_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.first_position_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.second_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.second_position_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.third_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.third_position_),
    ~0u,
    0,
    ~0u,
    1,
    ~0u,
    2,
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_.self_position_),
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_.self_body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_.self_stamina_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_.body_direction_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_.body_direction_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.ball_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.player_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.body_direction_),
    0,
    1,
    ~0u,
    2,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Say, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::Say, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::Say, _impl_.message_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PointToOf, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _impl_.unum_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AttentionToOf, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AddText, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddText, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddText, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_.point_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_.color_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.end_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.color_),
    ~0u,
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.center_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.start_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.span_angel_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.color_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.center_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.fill_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.point1_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.point2_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.point3_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.fill_),
    ~0u,
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.left_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.top_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.length_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.width_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.fill_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.center_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.min_radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.max_radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.start_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.span_angel_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.fill_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.color_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Log, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::Log, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::Log, _impl_.log_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DebugClient, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DebugClient, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPoint, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPoint, _impl_.distance_threshold_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPoint, _impl_.max_dash_power_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Body_SmartKick, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_SmartKick, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_SmartKick, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_SmartKick, _impl_.first_speed_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_SmartKick, _impl_.first_speed_threshold_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_SmartKick, _impl_.max_steps_),
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_BeforeKickOff, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_BeforeKickOff, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_BeforeKickOff, _impl_.point_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_BodyNeckToBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_BodyNeckToPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_BodyNeckToPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_BodyNeckToPoint, _impl_.point_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_Emergency, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_GoToPointLookBall, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_GoToPointLookBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_GoToPointLookBall, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_GoToPointLookBall, _impl_.distance_threshold_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_GoToPointLookBall, _impl_.max_dash_power_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_NeckBodyToBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_NeckBodyToBall, _impl_.angle_buf_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_NeckBodyToPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_NeckBodyToPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_NeckBodyToPoint, _impl_.point_),
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_NeckBodyToPoint, _impl_.angle_buf_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Bhv_ScanField, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Body_AdvanceBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Body_ClearBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_Dribble, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_Dribble, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_Dribble, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_Dribble, _impl_.distance_threshold_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_Dribble, _impl_.dash_power_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_Dribble, _impl_.dash_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_Dribble, _impl_.dodge_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPointDodge, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPointDodge, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPointDodge, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_GoToPointDodge, _impl_.dash_power_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Body_HoldBall, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_HoldBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_HoldBall, _impl_.do_turn_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_HoldBall, _impl_.turn_target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_HoldBall, _impl_.kick_target_point_),
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::Body_Intercept, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_Intercept, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_Intercept, _impl_.save_recovery_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_Intercept, _impl_.face_point_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::protos::Body_KickOneStep, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_KickOneStep, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_KickOneStep, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_KickOneStep, _impl_.first_speed_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_KickOneStep, _impl_.force_mode_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Body_StopBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Body_StopDash, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_StopDash, _impl_.save_recovery_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_TackleToPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_TackleToPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_TackleToPoint, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_TackleToPoint, _impl_.min_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_TackleToPoint, _impl_.min_speed_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToAngle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToAngle, _impl_.angle_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToBall, _impl_.cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToPoint, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::Body_TurnToPoint, _impl_.cycle_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Focus_MoveToPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Focus_MoveToPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Focus_MoveToPoint, _impl_.target_point_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Focus_Reset, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_ScanField, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_ScanPlayers, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToBallAndPlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToBallAndPlayer, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToBallAndPlayer, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToBallAndPlayer, _impl_.count_threshold_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToBallOrScan, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToBallOrScan, _impl_.count_threshold_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToGoalieOrScan, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToGoalieOrScan, _impl_.count_threshold_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToLowConfTeammate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToPlayerOrScan, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToPlayerOrScan, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToPlayerOrScan, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToPlayerOrScan, _impl_.count_threshold_),
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToPoint, _impl_.target_point_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToRelative, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Neck_TurnToRelative, _impl_.angle_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::View_ChangeWidth, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::View_ChangeWidth, _impl_.view_width_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::View_Normal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::View_Synch, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::View_Wide, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosGoalie, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosGoalieMove, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosGoalieKick, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosShoot, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.direct_pass_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.lead_pass_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.through_pass_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.short_dribble_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.long_dribble_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.cross_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.simple_pass_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.simple_dribble_),
    PROTOBUF_FIELD_OFFSET(::protos::HeliosChainAction, _impl_.simple_shoot_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosBasicOffensive, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosBasicMove, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosSetPlay, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosPenalty, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::HeliosCommunicaion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PlayerAction, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::PlayerAction, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::PlayerAction, _impl_.action_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PlayerActions, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PlayerActions, _impl_.actions_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::ChangePlayerType, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::ChangePlayerType, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ChangePlayerType, _impl_.type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DoHeliosSubstitute, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DoHeliosSayPlayerTypes, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::CoachAction, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::CoachAction, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::CoachAction, _impl_.action_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::CoachActions, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::CoachActions, _impl_.actions_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DoKickOff, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DoMoveBall, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::DoMoveBall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DoMoveBall, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::DoMoveBall, _impl_.velocity_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::DoMovePlayer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::DoMovePlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DoMovePlayer, _impl_.our_side_),
    PROTOBUF_FIELD_OFFSET(::protos::DoMovePlayer, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::DoMovePlayer, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::DoMovePlayer, _impl_.body_direction_),
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DoRecover, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DoChangeMode, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DoChangeMode, _impl_.game_mode_type_),
    PROTOBUF_FIELD_OFFSET(::protos::DoChangeMode, _impl_.side_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DoChangePlayerType, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DoChangePlayerType, _impl_.our_side_),
    PROTOBUF_FIELD_OFFSET(::protos::DoChangePlayerType, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::DoChangePlayerType, _impl_.type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::TrainerAction, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::TrainerAction, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::TrainerAction, _impl_.action_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::TrainerActions, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TrainerActions, _impl_.actions_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.agent_type_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.inertia_moment_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_size_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_decay_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_rand_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_weight_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_speed_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_accel_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.stamina_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.stamina_inc_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.recover_init_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.recover_dec_thr_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.recover_min_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.recover_dec_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.effort_init_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.effort_dec_thr_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.effort_min_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.effort_dec_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.effort_inc_thr_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.effort_inc_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kick_rand_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.team_actuator_noise_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_rand_factor_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_rand_factor_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kick_rand_factor_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kick_rand_factor_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.ball_size_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.ball_decay_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.ball_rand_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.ball_weight_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.ball_speed_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.ball_accel_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dash_power_rate_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kick_power_rate_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kickable_margin_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.control_radius_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.control_radius_width_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_power_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.min_power_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_moment_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.min_moment_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_neck_moment_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.min_neck_moment_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_neck_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.min_neck_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.visible_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.visible_distance_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.wind_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.wind_force_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.wind_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.wind_rand_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kickable_area_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.catch_area_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.catch_area_w_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.catch_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.goalie_max_moves_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.corner_kick_margin_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.offside_active_area_size_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.wind_none_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_wind_random_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.coach_say_count_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.coach_say_msg_size_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_win_size_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_define_win_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_meta_win_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_advice_win_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_info_win_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_mess_delay_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_mess_per_cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.half_time_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.simulator_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.send_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.recv_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.sense_body_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.lcm_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_say_msg_size_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_hear_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_hear_inc_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_hear_decay_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.catch_ban_cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.slow_down_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_offside_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kickoff_offside_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.offside_kick_margin_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.audio_cut_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dist_quantize_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.landmark_dist_quantize_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dir_quantize_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dist_quantize_step_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dist_quantize_step_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.landmark_dist_quantize_step_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.landmark_dist_quantize_step_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dir_quantize_step_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dir_quantize_step_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.coach_mode_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.coach_with_referee_mode_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_old_coach_hear_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.slowness_on_top_for_left_team_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.slowness_on_top_for_right_team_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.start_goal_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.start_goal_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.fullstate_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.fullstate_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.drop_ball_time_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.synch_mode_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.synch_offset_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.synch_micro_sleep_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.point_to_ban_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.point_to_duration_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_port_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.trainer_port_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.online_coach_port_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.verbose_mode_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.coach_send_vi_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.replay_file_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.landmark_file_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.send_comms_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.text_logging_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.game_logging_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.game_log_version_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.text_log_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.game_log_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.text_log_fixed_name_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.game_log_fixed_name_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_text_log_fixed_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_game_log_fixed_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_text_log_dated_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_game_log_dated_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.log_date_format_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.log_times_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.record_message_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.text_log_compression_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.game_log_compression_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.use_profile_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.tackle_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.tackle_back_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.tackle_width_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.tackle_exponent_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.tackle_cycles_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.tackle_power_rate_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.freeform_wait_period_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.freeform_send_period_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.free_kick_faults_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.back_passes_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.proper_goal_kicks_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.stopped_ball_vel_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_goal_kicks_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_del_win_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.clang_rule_win_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.auto_mode_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.kick_off_wait_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.connect_wait_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.game_over_wait_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.team_l_start_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.team_r_start_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_mode_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_length_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_width_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_logging_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_log_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_log_fixed_name_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_log_fixed_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_log_dated_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.keepaway_start_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.nr_normal_halfs_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.nr_extra_halfs_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.penalty_shoot_outs_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_before_setup_wait_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_setup_wait_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_ready_wait_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_taken_wait_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_nr_kicks_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_max_extra_kicks_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_dist_x_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_random_winner_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_allow_mult_kicks_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_max_goalie_dist_x_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pen_coach_moves_players_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.module_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.ball_stuck_area_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.coach_msg_file_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_tackle_power_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_back_tackle_power_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.player_speed_max_min_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.extra_stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.synch_see_offset_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.extra_half_time_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.stamina_capacity_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_dash_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.min_dash_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.dash_angle_step_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.side_dash_rate_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.back_dash_rate_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_dash_power_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.min_dash_power_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.tackle_rand_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.foul_detect_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.foul_exponent_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.foul_cycles_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.golden_goal_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.red_card_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.illegal_defense_duration_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.illegal_defense_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.illegal_defense_dist_x_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.illegal_defense_width_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.fixed_teamname_l_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.fixed_teamname_r_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_catch_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.min_catch_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.random_seed_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.long_kick_power_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.long_kick_delay_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.max_monitors_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.catchable_area_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.real_speed_max_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pitch_half_length_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.pitch_half_width_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.our_penalty_area_line_x_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.their_penalty_area_line_x_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.penalty_area_half_width_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.penalty_area_length_),
    PROTOBUF_FIELD_OFFSET(::protos::ServerParam, _impl_.goal_width_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.agent_type_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.player_types_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.subs_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.pt_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.allow_mult_default_type_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.player_speed_max_delta_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.player_speed_max_delta_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.stamina_inc_max_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.player_decay_delta_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.player_decay_delta_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.inertia_moment_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.dash_power_rate_delta_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.dash_power_rate_delta_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.player_size_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.kickable_margin_delta_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.kickable_margin_delta_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.kick_rand_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.extra_stamina_delta_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.extra_stamina_delta_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.effort_max_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.effort_min_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.random_seed_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.new_dash_power_rate_delta_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.new_dash_power_rate_delta_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.new_stamina_inc_max_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.kick_power_rate_delta_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.kick_power_rate_delta_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.foul_detect_probability_delta_factor_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.catchable_area_l_stretch_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerParam, _impl_.catchable_area_l_stretch_max_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.agent_type_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.stamina_inc_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.player_decay_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.inertia_moment_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.dash_power_rate_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.player_size_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.kickable_margin_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.kick_rand_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.extra_stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.effort_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.effort_min_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.kick_power_rate_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.foul_detect_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.catchable_area_l_stretch_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.unum_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.unum_too_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.team_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.team_too_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.player_max_observation_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.ball_vel_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.ball_vel_too_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.ball_max_observation_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.flag_chg_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.flag_chg_too_far_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.flag_max_observation_length_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.kickable_area_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.reliable_catchable_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.max_catchable_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.real_speed_max_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.player_speed_max2_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.real_speed_max2_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.cycles_to_reach_max_speed_),
    PROTOBUF_FIELD_OFFSET(::protos::PlayerType, _impl_.player_speed_max_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Empty, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::InitMessageFromServer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::protos::Vector2D)},
        { 12, 37, -1, sizeof(::protos::Ball)},
        { 54, 92, -1, sizeof(::protos::Player)},
        { 122, 166, -1, sizeof(::protos::Self)},
        { 202, 220, -1, sizeof(::protos::InterceptInfo)},
        { 230, -1, -1, sizeof(::protos::InterceptTable)},
        { 248, 258, -1, sizeof(::protos::WorldModel_OurPlayersDictEntry_DoNotUse)},
        { 260, 270, -1, sizeof(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse)},
        { 272, 282, -1, sizeof(::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse)},
        { 284, 323, -1, sizeof(::protos::WorldModel)},
        { 354, 365, -1, sizeof(::protos::State)},
        { 368, -1, -1, sizeof(::protos::InitMessage)},
        { 378, -1, -1, sizeof(::protos::Dash)},
        { 388, -1, -1, sizeof(::protos::Turn)},
        { 397, -1, -1, sizeof(::protos::Kick)},
        { 407, -1, -1, sizeof(::protos::Tackle)},
        { 417, -1, -1, sizeof(::protos::Catch)},
        { 425, -1, -1, sizeof(::protos::Move)},
        { 435, -1, -1, sizeof(::protos::TurnNeck)},
        { 444, -1, -1, sizeof(::protos::ChangeView)},
        { 453, 463, -1, sizeof(::protos::BallMessage)},
        { 465, 477, -1, sizeof(::protos::PassMessage)},
        { 481, -1, -1, sizeof(::protos::InterceptMessage)},
        { 492, 503, -1, sizeof(::protos::GoalieMessage)},
        { 506, 519, -1, sizeof(::protos::GoalieAndPlayerMessage)},
        { 524, -1, -1, sizeof(::protos::OffsideLineMessage)},
        { 533, -1, -1, sizeof(::protos::DefenseLineMessage)},
        { 542, -1, -1, sizeof(::protos::WaitRequestMessage)},
        { 550, -1, -1, sizeof(::protos::SetplayMessage)},
        { 559, 568, -1, sizeof(::protos::PassRequestMessage)},
        { 569, -1, -1, sizeof(::protos::StaminaMessage)},
        { 578, -1, -1, sizeof(::protos::RecoveryMessage)},
        { 587, -1, -1, sizeof(::protos::StaminaCapacityMessage)},
        { 596, 606, -1, sizeof(::protos::DribbleMessage)},
        { 608, 620, -1, sizeof(::protos::BallGoalieMessage)},
        { 624, 634, -1, sizeof(::protos::OnePlayerMessage)},
        { 636, 648, -1, sizeof(::protos::TwoPlayerMessage)},
        { 652, 666, -1, sizeof(::protos::ThreePlayerMessage)},
        { 672, 683, -1, sizeof(::protos::SelfMessage)},
        { 686, 697, -1, sizeof(::protos::TeammateMessage)},
        { 700, 711, -1, sizeof(::protos::OpponentMessage)},
        { 714, 727, -1, sizeof(::protos::BallPlayerMessage)},
        { 732, -1, -1, sizeof(::protos::Say)},
        { 763, -1, -1, sizeof(::protos::PointTo)},
        { 773, -1, -1, sizeof(::protos::PointToOf)},
        { 781, -1, -1, sizeof(::protos::AttentionTo)},
        { 791, -1, -1, sizeof(::protos::AttentionToOf)},
        { 799, -1, -1, sizeof(::protos::AddText)},
        { 809, 820, -1, sizeof(::protos::AddPoint)},
        { 823, 835, -1, sizeof(::protos::AddLine)},
        { 839, 853, -1, sizeof(::protos::AddArc)},
        { 859, 872, -1, sizeof(::protos::AddCircle)},
        { 877, 891, -1, sizeof(::protos::AddTriangle)},
        { 897, -1, -1, sizeof(::protos::AddRectangle)},
        { 912, 928, -1, sizeof(::protos::AddSector)},
        { 936, 948, -1, sizeof(::protos::AddMessage)},
        { 952, -1, -1, sizeof(::protos::Log)},
        { 970, -1, -1, sizeof(::protos::DebugClient)},
        { 979, 990, -1, sizeof(::protos::Body_GoToPoint)},
        { 993, 1005, -1, sizeof(::protos::Body_SmartKick)},
        { 1009, 1018, -1, sizeof(::protos::Bhv_BeforeKickOff)},
        { 1019, -1, -1, sizeof(::protos::Bhv_BodyNeckToBall)},
        { 1027, 1036, -1, sizeof(::protos::Bhv_BodyNeckToPoint)},
        { 1037, -1, -1, sizeof(::protos::Bhv_Emergency)},
        { 1045, 1056, -1, sizeof(::protos::Bhv_GoToPointLookBall)},
        { 1059, -1, -1, sizeof(::protos::Bhv_NeckBodyToBall)},
        { 1068, 1078, -1, sizeof(::protos::Bhv_NeckBodyToPoint)},
        { 1080, -1, -1, sizeof(::protos::Bhv_ScanField)},
        { 1088, -1, -1, sizeof(::protos::Body_AdvanceBall)},
        { 1096, -1, -1, sizeof(::protos::Body_ClearBall)},
        { 1104, 1117, -1, sizeof(::protos::Body_Dribble)},
        { 1122, 1132, -1, sizeof(::protos::Body_GoToPointDodge)},
        { 1134, 1145, -1, sizeof(::protos::Body_HoldBall)},
        { 1148, 1158, -1, sizeof(::protos::Body_Intercept)},
        { 1160, 1171, -1, sizeof(::protos::Body_KickOneStep)},
        { 1174, -1, -1, sizeof(::protos::Body_StopBall)},
        { 1182, -1, -1, sizeof(::protos::Body_StopDash)},
        { 1191, 1202, -1, sizeof(::protos::Body_TackleToPoint)},
        { 1205, -1, -1, sizeof(::protos::Body_TurnToAngle)},
        { 1214, -1, -1, sizeof(::protos::Body_TurnToBall)},
        { 1223, 1233, -1, sizeof(::protos::Body_TurnToPoint)},
        { 1235, 1244, -1, sizeof(::protos::Focus_MoveToPoint)},
        { 1245, -1, -1, sizeof(::protos::Focus_Reset)},
        { 1253, -1, -1, sizeof(::protos::Neck_ScanField)},
        { 1261, -1, -1, sizeof(::protos::Neck_ScanPlayers)},
        { 1269, -1, -1, sizeof(::protos::Neck_TurnToBallAndPlayer)},
        { 1280, -1, -1, sizeof(::protos::Neck_TurnToBallOrScan)},
        { 1289, -1, -1, sizeof(::protos::Neck_TurnToBall)},
        { 1297, -1, -1, sizeof(::protos::Neck_TurnToGoalieOrScan)},
        { 1306, -1, -1, sizeof(::protos::Neck_TurnToLowConfTeammate)},
        { 1314, -1, -1, sizeof(::protos::Neck_TurnToPlayerOrScan)},
        { 1325, 1334, -1, sizeof(::protos::Neck_TurnToPoint)},
        { 1335, -1, -1, sizeof(::protos::Neck_TurnToRelative)},
        { 1344, -1, -1, sizeof(::protos::View_ChangeWidth)},
        { 1353, -1, -1, sizeof(::protos::View_Normal)},
        { 1361, -1, -1, sizeof(::protos::View_Synch)},
        { 1369, -1, -1, sizeof(::protos::View_Wide)},
        { 1377, -1, -1, sizeof(::protos::HeliosGoalie)},
        { 1385, -1, -1, sizeof(::protos::HeliosGoalieMove)},
        { 1393, -1, -1, sizeof(::protos::HeliosGoalieKick)},
        { 1401, -1, -1, sizeof(::protos::HeliosShoot)},
        { 1409, -1, -1, sizeof(::protos::HeliosChainAction)},
        { 1426, -1, -1, sizeof(::protos::HeliosBasicOffensive)},
        { 1434, -1, -1, sizeof(::protos::HeliosBasicMove)},
        { 1442, -1, -1, sizeof(::protos::HeliosSetPlay)},
        { 1450, -1, -1, sizeof(::protos::HeliosPenalty)},
        { 1458, -1, -1, sizeof(::protos::HeliosCommunicaion)},
        { 1466, -1, -1, sizeof(::protos::PlayerAction)},
        { 1539, -1, -1, sizeof(::protos::PlayerActions)},
        { 1548, -1, -1, sizeof(::protos::ChangePlayerType)},
        { 1558, -1, -1, sizeof(::protos::DoHeliosSubstitute)},
        { 1566, -1, -1, sizeof(::protos::DoHeliosSayPlayerTypes)},
        { 1574, -1, -1, sizeof(::protos::CoachAction)},
        { 1586, -1, -1, sizeof(::protos::CoachActions)},
        { 1595, -1, -1, sizeof(::protos::DoKickOff)},
        { 1603, 1613, -1, sizeof(::protos::DoMoveBall)},
        { 1615, 1627, -1, sizeof(::protos::DoMovePlayer)},
        { 1631, -1, -1, sizeof(::protos::DoRecover)},
        { 1639, -1, -1, sizeof(::protos::DoChangeMode)},
        { 1649, -1, -1, sizeof(::protos::DoChangePlayerType)},
        { 1660, -1, -1, sizeof(::protos::TrainerAction)},
        { 1675, -1, -1, sizeof(::protos::TrainerActions)},
        { 1684, -1, -1, sizeof(::protos::ServerParam)},
        { 1914, -1, -1, sizeof(::protos::PlayerParam)},
        { 1952, -1, -1, sizeof(::protos::PlayerType)},
        { 1994, -1, -1, sizeof(::protos::Empty)},
        { 2002, -1, -1, sizeof(::protos::InitMessageFromServer)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::protos::_Vector2D_default_instance_._instance,
    &::protos::_Ball_default_instance_._instance,
    &::protos::_Player_default_instance_._instance,
    &::protos::_Self_default_instance_._instance,
    &::protos::_InterceptInfo_default_instance_._instance,
    &::protos::_InterceptTable_default_instance_._instance,
    &::protos::_WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_._instance,
    &::protos::_WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_._instance,
    &::protos::_WorldModel_HeliosHomePositionsEntry_DoNotUse_default_instance_._instance,
    &::protos::_WorldModel_default_instance_._instance,
    &::protos::_State_default_instance_._instance,
    &::protos::_InitMessage_default_instance_._instance,
    &::protos::_Dash_default_instance_._instance,
    &::protos::_Turn_default_instance_._instance,
    &::protos::_Kick_default_instance_._instance,
    &::protos::_Tackle_default_instance_._instance,
    &::protos::_Catch_default_instance_._instance,
    &::protos::_Move_default_instance_._instance,
    &::protos::_TurnNeck_default_instance_._instance,
    &::protos::_ChangeView_default_instance_._instance,
    &::protos::_BallMessage_default_instance_._instance,
    &::protos::_PassMessage_default_instance_._instance,
    &::protos::_InterceptMessage_default_instance_._instance,
    &::protos::_GoalieMessage_default_instance_._instance,
    &::protos::_GoalieAndPlayerMessage_default_instance_._instance,
    &::protos::_OffsideLineMessage_default_instance_._instance,
    &::protos::_DefenseLineMessage_default_instance_._instance,
    &::protos::_WaitRequestMessage_default_instance_._instance,
    &::protos::_SetplayMessage_default_instance_._instance,
    &::protos::_PassRequestMessage_default_instance_._instance,
    &::protos::_StaminaMessage_default_instance_._instance,
    &::protos::_RecoveryMessage_default_instance_._instance,
    &::protos::_StaminaCapacityMessage_default_instance_._instance,
    &::protos::_DribbleMessage_default_instance_._instance,
    &::protos::_BallGoalieMessage_default_instance_._instance,
    &::protos::_OnePlayerMessage_default_instance_._instance,
    &::protos::_TwoPlayerMessage_default_instance_._instance,
    &::protos::_ThreePlayerMessage_default_instance_._instance,
    &::protos::_SelfMessage_default_instance_._instance,
    &::protos::_TeammateMessage_default_instance_._instance,
    &::protos::_OpponentMessage_default_instance_._instance,
    &::protos::_BallPlayerMessage_default_instance_._instance,
    &::protos::_Say_default_instance_._instance,
    &::protos::_PointTo_default_instance_._instance,
    &::protos::_PointToOf_default_instance_._instance,
    &::protos::_AttentionTo_default_instance_._instance,
    &::protos::_AttentionToOf_default_instance_._instance,
    &::protos::_AddText_default_instance_._instance,
    &::protos::_AddPoint_default_instance_._instance,
    &::protos::_AddLine_default_instance_._instance,
    &::protos::_AddArc_default_instance_._instance,
    &::protos::_AddCircle_default_instance_._instance,
    &::protos::_AddTriangle_default_instance_._instance,
    &::protos::_AddRectangle_default_instance_._instance,
    &::protos::_AddSector_default_instance_._instance,
    &::protos::_AddMessage_default_instance_._instance,
    &::protos::_Log_default_instance_._instance,
    &::protos::_DebugClient_default_instance_._instance,
    &::protos::_Body_GoToPoint_default_instance_._instance,
    &::protos::_Body_SmartKick_default_instance_._instance,
    &::protos::_Bhv_BeforeKickOff_default_instance_._instance,
    &::protos::_Bhv_BodyNeckToBall_default_instance_._instance,
    &::protos::_Bhv_BodyNeckToPoint_default_instance_._instance,
    &::protos::_Bhv_Emergency_default_instance_._instance,
    &::protos::_Bhv_GoToPointLookBall_default_instance_._instance,
    &::protos::_Bhv_NeckBodyToBall_default_instance_._instance,
    &::protos::_Bhv_NeckBodyToPoint_default_instance_._instance,
    &::protos::_Bhv_ScanField_default_instance_._instance,
    &::protos::_Body_AdvanceBall_default_instance_._instance,
    &::protos::_Body_ClearBall_default_instance_._instance,
    &::protos::_Body_Dribble_default_instance_._instance,
    &::protos::_Body_GoToPointDodge_default_instance_._instance,
    &::protos::_Body_HoldBall_default_instance_._instance,
    &::protos::_Body_Intercept_default_instance_._instance,
    &::protos::_Body_KickOneStep_default_instance_._instance,
    &::protos::_Body_StopBall_default_instance_._instance,
    &::protos::_Body_StopDash_default_instance_._instance,
    &::protos::_Body_TackleToPoint_default_instance_._instance,
    &::protos::_Body_TurnToAngle_default_instance_._instance,
    &::protos::_Body_TurnToBall_default_instance_._instance,
    &::protos::_Body_TurnToPoint_default_instance_._instance,
    &::protos::_Focus_MoveToPoint_default_instance_._instance,
    &::protos::_Focus_Reset_default_instance_._instance,
    &::protos::_Neck_ScanField_default_instance_._instance,
    &::protos::_Neck_ScanPlayers_default_instance_._instance,
    &::protos::_Neck_TurnToBallAndPlayer_default_instance_._instance,
    &::protos::_Neck_TurnToBallOrScan_default_instance_._instance,
    &::protos::_Neck_TurnToBall_default_instance_._instance,
    &::protos::_Neck_TurnToGoalieOrScan_default_instance_._instance,
    &::protos::_Neck_TurnToLowConfTeammate_default_instance_._instance,
    &::protos::_Neck_TurnToPlayerOrScan_default_instance_._instance,
    &::protos::_Neck_TurnToPoint_default_instance_._instance,
    &::protos::_Neck_TurnToRelative_default_instance_._instance,
    &::protos::_View_ChangeWidth_default_instance_._instance,
    &::protos::_View_Normal_default_instance_._instance,
    &::protos::_View_Synch_default_instance_._instance,
    &::protos::_View_Wide_default_instance_._instance,
    &::protos::_HeliosGoalie_default_instance_._instance,
    &::protos::_HeliosGoalieMove_default_instance_._instance,
    &::protos::_HeliosGoalieKick_default_instance_._instance,
    &::protos::_HeliosShoot_default_instance_._instance,
    &::protos::_HeliosChainAction_default_instance_._instance,
    &::protos::_HeliosBasicOffensive_default_instance_._instance,
    &::protos::_HeliosBasicMove_default_instance_._instance,
    &::protos::_HeliosSetPlay_default_instance_._instance,
    &::protos::_HeliosPenalty_default_instance_._instance,
    &::protos::_HeliosCommunicaion_default_instance_._instance,
    &::protos::_PlayerAction_default_instance_._instance,
    &::protos::_PlayerActions_default_instance_._instance,
    &::protos::_ChangePlayerType_default_instance_._instance,
    &::protos::_DoHeliosSubstitute_default_instance_._instance,
    &::protos::_DoHeliosSayPlayerTypes_default_instance_._instance,
    &::protos::_CoachAction_default_instance_._instance,
    &::protos::_CoachActions_default_instance_._instance,
    &::protos::_DoKickOff_default_instance_._instance,
    &::protos::_DoMoveBall_default_instance_._instance,
    &::protos::_DoMovePlayer_default_instance_._instance,
    &::protos::_DoRecover_default_instance_._instance,
    &::protos::_DoChangeMode_default_instance_._instance,
    &::protos::_DoChangePlayerType_default_instance_._instance,
    &::protos::_TrainerAction_default_instance_._instance,
    &::protos::_TrainerActions_default_instance_._instance,
    &::protos::_ServerParam_default_instance_._instance,
    &::protos::_PlayerParam_default_instance_._instance,
    &::protos::_PlayerType_default_instance_._instance,
    &::protos::_Empty_default_instance_._instance,
    &::protos::_InitMessageFromServer_default_instance_._instance,
};
const char descriptor_table_protodef_service_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\rservice.proto\022\006protos\"=\n\010Vector2D\022\t\n\001x"
    "\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\014\n\004dist\030\003 \001(\002\022\r\n\005angle"
    "\030\004 \001(\002\"\203\004\n\004Ball\022\"\n\010position\030\001 \001(\0132\020.prot"
    "os.Vector2D\022+\n\021relative_position\030\002 \001(\0132\020"
    ".protos.Vector2D\022\'\n\rseen_position\030\003 \001(\0132"
    "\020.protos.Vector2D\022(\n\016heard_position\030\004 \001("
    "\0132\020.protos.Vector2D\022\"\n\010velocity\030\005 \001(\0132\020."
    "protos.Vector2D\022\'\n\rseen_velocity\030\006 \001(\0132\020"
    ".protos.Vector2D\022(\n\016heard_velocity\030\007 \001(\013"
    "2\020.protos.Vector2D\022\021\n\tpos_count\030\010 \001(\005\022\026\n"
    "\016seen_pos_count\030\t \001(\005\022\027\n\017heard_pos_count"
    "\030\n \001(\005\022\021\n\tvel_count\030\013 \001(\005\022\026\n\016seen_vel_co"
    "unt\030\014 \001(\005\022\027\n\017heard_vel_count\030\r \001(\005\022\022\n\nlo"
    "st_count\030\016 \001(\005\022\023\n\013ghost_count\030\017 \001(\005\022\026\n\016d"
    "ist_from_self\030\020 \001(\002\022\027\n\017angle_from_self\030\021"
    " \001(\002\"\241\006\n\006Player\022\"\n\010position\030\001 \001(\0132\020.prot"
    "os.Vector2D\022\'\n\rseen_position\030\002 \001(\0132\020.pro"
    "tos.Vector2D\022(\n\016heard_position\030\003 \001(\0132\020.p"
    "rotos.Vector2D\022\"\n\010velocity\030\004 \001(\0132\020.proto"
    "s.Vector2D\022\'\n\rseen_velocity\030\005 \001(\0132\020.prot"
    "os.Vector2D\022\021\n\tpos_count\030\006 \001(\005\022\026\n\016seen_p"
    "os_count\030\007 \001(\005\022\027\n\017heard_pos_count\030\010 \001(\005\022"
    "\021\n\tvel_count\030\t \001(\005\022\026\n\016seen_vel_count\030\n \001"
    "(\005\022\023\n\013ghost_count\030\013 \001(\005\022\026\n\016dist_from_sel"
    "f\030\014 \001(\002\022\027\n\017angle_from_self\030\r \001(\002\022\n\n\002id\030\016"
    " \001(\005\022\032\n\004side\030\017 \001(\0162\014.protos.Side\022\026\n\016unif"
    "orm_number\030\020 \001(\005\022\034\n\024uniform_number_count"
    "\030\021 \001(\005\022\021\n\tis_goalie\030\022 \001(\010\022\026\n\016body_direct"
    "ion\030\023 \001(\002\022\034\n\024body_direction_count\030\024 \001(\005\022"
    "\026\n\016face_direction\030\025 \001(\002\022\034\n\024face_directio"
    "n_count\030\026 \001(\005\022\032\n\022point_to_direction\030\027 \001("
    "\002\022 \n\030point_to_direction_count\030\030 \001(\005\022\022\n\ni"
    "s_kicking\030\031 \001(\010\022\026\n\016dist_from_ball\030\032 \001(\002\022"
    "\027\n\017angle_from_ball\030\033 \001(\002\022\030\n\020ball_reach_s"
    "teps\030\034 \001(\005\022\023\n\013is_tackling\030\035 \001(\010\022\017\n\007type_"
    "id\030\036 \001(\005\"\300\007\n\004Self\022\"\n\010position\030\001 \001(\0132\020.pr"
    "otos.Vector2D\022\'\n\rseen_position\030\002 \001(\0132\020.p"
    "rotos.Vector2D\022(\n\016heard_position\030\003 \001(\0132\020"
    ".protos.Vector2D\022\"\n\010velocity\030\004 \001(\0132\020.pro"
    "tos.Vector2D\022\'\n\rseen_velocity\030\005 \001(\0132\020.pr"
    "otos.Vector2D\022\021\n\tpos_count\030\006 \001(\005\022\026\n\016seen"
    "_pos_count\030\007 \001(\005\022\027\n\017heard_pos_count\030\010 \001("
    "\005\022\021\n\tvel_count\030\t \001(\005\022\026\n\016seen_vel_count\030\n"
    " \001(\005\022\023\n\013ghost_count\030\013 \001(\005\022\n\n\002id\030\014 \001(\005\022\032\n"
    "\004side\030\r \001(\0162\014.protos.Side\022\026\n\016uniform_num"
    "ber\030\016 \001(\005\022\034\n\024uniform_number_count\030\017 \001(\005\022"
    "\021\n\tis_goalie\030\020 \001(\010\022\026\n\016body_direction\030\021 \001"
    "(\002\022\034\n\024body_direction_count\030\022 \001(\005\022\026\n\016face"
    "_direction\030\023 \001(\002\022\034\n\024face_direction_count"
    "\030\024 \001(\005\022\032\n\022point_to_direction\030\025 \001(\002\022 \n\030po"
    "int_to_direction_count\030\026 \001(\005\022\022\n\nis_kicki"
    "ng\030\027 \001(\010\022\026\n\016dist_from_ball\030\030 \001(\002\022\027\n\017angl"
    "e_from_ball\030\031 \001(\002\022\030\n\020ball_reach_steps\030\032 "
    "\001(\005\022\023\n\013is_tackling\030\033 \001(\010\022\037\n\027relative_nec"
    "k_direction\030\034 \001(\002\022\017\n\007stamina\030\035 \001(\002\022\023\n\013is"
    "_kickable\030\036 \001(\010\022\031\n\021catch_probability\030\037 \001"
    "(\002\022\032\n\022tackle_probability\030  \001(\002\022\030\n\020foul_p"
    "robability\030! \001(\002\022%\n\nview_width\030\" \001(\0162\021.p"
    "rotos.ViewWidth\022\017\n\007type_id\030# \001(\005\022\021\n\tkick"
    "_rate\030$ \001(\002\"\221\002\n\rInterceptInfo\0220\n\013action_"
    "type\030\001 \001(\0162\033.protos.InterceptActionType\022"
    "\022\n\nturn_steps\030\002 \001(\005\022\022\n\nturn_angle\030\003 \001(\002\022"
    "\022\n\ndash_steps\030\004 \001(\005\022\022\n\ndash_power\030\005 \001(\002\022"
    "\020\n\010dash_dir\030\006 \001(\002\022-\n\023final_self_position"
    "\030\007 \001(\0132\020.protos.Vector2D\022\027\n\017final_ball_d"
    "ist\030\010 \001(\002\022\025\n\rfinal_stamina\030\t \001(\002\022\r\n\005valu"
    "e\030\n \001(\002\"\336\002\n\016InterceptTable\022\030\n\020self_reach"
    "_steps\030\001 \001(\005\022\"\n\032first_teammate_reach_ste"
    "ps\030\002 \001(\005\022#\n\033second_teammate_reach_steps\030"
    "\003 \001(\005\022\"\n\032first_opponent_reach_steps\030\004 \001("
    "\005\022#\n\033second_opponent_reach_steps\030\005 \001(\005\022\031"
    "\n\021first_teammate_id\030\006 \001(\005\022\032\n\022second_team"
    "mate_id\030\007 \001(\005\022\031\n\021first_opponent_id\030\010 \001(\005"
    "\022\032\n\022second_opponent_id\030\t \001(\005\0222\n\023self_int"
    "ercept_info\030\n \003(\0132\025.protos.InterceptInfo"
    "\"\216\n\n\nWorldModel\022/\n\017intercept_table\030\001 \001(\013"
    "2\026.protos.InterceptTable\022\025\n\rour_team_nam"
    "e\030\002 \001(\t\022\027\n\017their_team_name\030\003 \001(\t\022\036\n\010our_"
    "side\030\004 \001(\0162\014.protos.Side\022 \n\030last_set_pla"
    "y_start_time\030\005 \001(\005\022\032\n\004self\030\006 \001(\0132\014.proto"
    "s.Self\022\032\n\004ball\030\007 \001(\0132\014.protos.Ball\022!\n\tte"
    "ammates\030\010 \003(\0132\016.protos.Player\022!\n\topponen"
    "ts\030\t \003(\0132\016.protos.Player\022 \n\010unknowns\030\n \003"
    "(\0132\016.protos.Player\022@\n\020our_players_dict\030\013"
    " \003(\0132&.protos.WorldModel.OurPlayersDictE"
    "ntry\022D\n\022their_players_dict\030\014 \003(\0132(.proto"
    "s.WorldModel.TheirPlayersDictEntry\022!\n\031ou"
    "r_goalie_uniform_number\030\r \001(\005\022#\n\033their_g"
    "oalie_uniform_number\030\016 \001(\005\022\026\n\016offside_li"
    "ne_x\030\017 \001(\002\022\033\n\023ofside_line_x_count\030\020 \001(\005\022"
    "\034\n\024kickable_teammate_id\030\021 \001(\005\022\034\n\024kickabl"
    "e_opponent_id\030\022 \001(\005\022$\n\016last_kick_side\030\023 "
    "\001(\0162\014.protos.Side\022\"\n\032last_kicker_uniform"
    "_number\030\024 \001(\005\022\r\n\005cycle\030\025 \001(\005\022,\n\016game_mod"
    "e_type\030\026 \001(\0162\024.protos.GameModeType\022\027\n\017le"
    "ft_team_score\030\027 \001(\005\022\030\n\020right_team_score\030"
    "\030 \001(\005\022\027\n\017is_our_set_play\030\031 \001(\010\022\031\n\021is_the"
    "ir_set_play\030\032 \001(\010\022\024\n\014stoped_cycle\030\033 \001(\005\022"
    "\026\n\016our_team_score\030\034 \001(\005\022\030\n\020their_team_sc"
    "ore\030\035 \001(\005\022\034\n\024is_penalty_kick_mode\030\036 \001(\010\022"
    "J\n\025helios_home_positions\030\037 \003(\0132+.protos."
    "WorldModel.HeliosHomePositionsEntry\032E\n\023O"
    "urPlayersDictEntry\022\013\n\003key\030\001 \001(\005\022\035\n\005value"
    "\030\002 \001(\0132\016.protos.Player:\0028\001\032G\n\025TheirPlaye"
    "rsDictEntry\022\013\n\003key\030\001 \001(\005\022\035\n\005value\030\002 \001(\0132"
    "\016.protos.Player:\0028\001\032L\n\030HeliosHomePositio"
    "nsEntry\022\013\n\003key\030\001 \001(\005\022\037\n\005value\030\002 \001(\0132\020.pr"
    "otos.Vector2D:\0028\001\"\205\001\n\005State\022%\n\nagent_typ"
    "e\030\001 \001(\0162\021.protos.AgentType\022\'\n\013world_mode"
    "l\030\002 \001(\0132\022.protos.WorldModel\022,\n\020full_worl"
    "d_model\030\003 \001(\0132\022.protos.WorldModel\"H\n\013Ini"
    "tMessage\022%\n\nagent_type\030\001 \001(\0162\021.protos.Ag"
    "entType\022\022\n\ndebug_mode\030\002 \001(\010\"1\n\004Dash\022\r\n\005p"
    "ower\030\001 \001(\002\022\032\n\022relative_direction\030\002 \001(\002\"\""
    "\n\004Turn\022\032\n\022relative_direction\030\001 \001(\002\"1\n\004Ki"
    "ck\022\r\n\005power\030\001 \001(\002\022\032\n\022relative_direction\030"
    "\002 \001(\002\",\n\006Tackle\022\024\n\014power_or_dir\030\001 \001(\002\022\014\n"
    "\004foul\030\002 \001(\010\"\007\n\005Catch\"\034\n\004Move\022\t\n\001x\030\001 \001(\002\022"
    "\t\n\001y\030\002 \001(\002\"\032\n\010TurnNeck\022\016\n\006moment\030\001 \001(\002\"3"
    "\n\nChangeView\022%\n\nview_width\030\001 \001(\0162\021.proto"
    "s.ViewWidth\"_\n\013BallMessage\022\'\n\rball_posit"
    "ion\030\001 \001(\0132\020.protos.Vector2D\022\'\n\rball_velo"
    "city\030\002 \001(\0132\020.protos.Vector2D\"\252\001\n\013PassMes"
    "sage\022\037\n\027receiver_uniform_number\030\001 \001(\005\022(\n"
    "\016receiver_point\030\002 \001(\0132\020.protos.Vector2D\022"
    "\'\n\rball_position\030\003 \001(\0132\020.protos.Vector2D"
    "\022\'\n\rball_velocity\030\004 \001(\0132\020.protos.Vector2"
    "D\"F\n\020InterceptMessage\022\013\n\003our\030\001 \001(\010\022\026\n\016un"
    "iform_number\030\002 \001(\005\022\r\n\005cycle\030\003 \001(\005\"x\n\rGoa"
    "lieMessage\022\035\n\025goalie_uniform_number\030\001 \001("
    "\005\022)\n\017goalie_position\030\002 \001(\0132\020.protos.Vect"
    "or2D\022\035\n\025goalie_body_direction\030\003 \001(\002\"\313\001\n\026"
    "GoalieAndPlayerMessage\022\035\n\025goalie_uniform"
    "_number\030\001 \001(\005\022)\n\017goalie_position\030\002 \001(\0132\020"
    ".protos.Vector2D\022\035\n\025goalie_body_directio"
    "n\030\003 \001(\002\022\035\n\025player_uniform_number\030\004 \001(\005\022)"
    "\n\017player_position\030\005 \001(\0132\020.protos.Vector2"
    "D\",\n\022OffsideLineMessage\022\026\n\016offside_line_"
    "x\030\001 \001(\002\",\n\022DefenseLineMessage\022\026\n\016defense"
    "_line_x\030\001 \001(\002\"\024\n\022WaitRequestMessage\"#\n\016S"
    "etplayMessage\022\021\n\twait_step\030\001 \001(\005\"<\n\022Pass"
    "RequestMessage\022&\n\014target_point\030\001 \001(\0132\020.p"
    "rotos.Vector2D\"!\n\016StaminaMessage\022\017\n\007stam"
    "ina\030\001 \001(\002\"#\n\017RecoveryMessage\022\020\n\010recovery"
    "\030\001 \001(\002\"2\n\026StaminaCapacityMessage\022\030\n\020stam"
    "ina_capacity\030\001 \001(\002\"M\n\016DribbleMessage\022&\n\014"
    "target_point\030\001 \001(\0132\020.protos.Vector2D\022\023\n\013"
    "queue_count\030\002 \001(\005\"\257\001\n\021BallGoalieMessage\022"
    "\'\n\rball_position\030\001 \001(\0132\020.protos.Vector2D"
    "\022\'\n\rball_velocity\030\002 \001(\0132\020.protos.Vector2"
    "D\022)\n\017goalie_position\030\003 \001(\0132\020.protos.Vect"
    "or2D\022\035\n\025goalie_body_direction\030\004 \001(\002\"N\n\020O"
    "nePlayerMessage\022\026\n\016uniform_number\030\001 \001(\005\022"
    "\"\n\010position\030\002 \001(\0132\020.protos.Vector2D\"\244\001\n\020"
    "TwoPlayerMessage\022\034\n\024first_uniform_number"
    "\030\001 \001(\005\022(\n\016first_position\030\002 \001(\0132\020.protos."
    "Vector2D\022\035\n\025second_uniform_number\030\003 \001(\005\022"
    ")\n\017second_position\030\004 \001(\0132\020.protos.Vector"
    "2D\"\356\001\n\022ThreePlayerMessage\022\034\n\024first_unifo"
    "rm_number\030\001 \001(\005\022(\n\016first_position\030\002 \001(\0132"
    "\020.protos.Vector2D\022\035\n\025second_uniform_numb"
    "er\030\003 \001(\005\022)\n\017second_position\030\004 \001(\0132\020.prot"
    "os.Vector2D\022\034\n\024third_uniform_number\030\005 \001("
    "\005\022(\n\016third_position\030\006 \001(\0132\020.protos.Vecto"
    "r2D\"i\n\013SelfMessage\022\'\n\rself_position\030\001 \001("
    "\0132\020.protos.Vector2D\022\033\n\023self_body_directi"
    "on\030\002 \001(\002\022\024\n\014self_stamina\030\003 \001(\002\"e\n\017Teamma"
    "teMessage\022\026\n\016uniform_number\030\001 \001(\005\022\"\n\010pos"
    "ition\030\002 \001(\0132\020.protos.Vector2D\022\026\n\016body_di"
    "rection\030\003 \001(\002\"e\n\017OpponentMessage\022\026\n\016unif"
    "orm_number\030\001 \001(\005\022\"\n\010position\030\002 \001(\0132\020.pro"
    "tos.Vector2D\022\026\n\016body_direction\030\003 \001(\002\"\300\001\n"
    "\021BallPlayerMessage\022\'\n\rball_position\030\001 \001("
    "\0132\020.protos.Vector2D\022\'\n\rball_velocity\030\002 \001"
    "(\0132\020.protos.Vector2D\022\026\n\016uniform_number\030\003"
    " \001(\005\022)\n\017player_position\030\004 \001(\0132\020.protos.V"
    "ector2D\022\026\n\016body_direction\030\005 \001(\002\"\320\t\n\003Say\022"
    "+\n\014ball_message\030\001 \001(\0132\023.protos.BallMessa"
    "geH\000\022+\n\014pass_message\030\002 \001(\0132\023.protos.Pass"
    "MessageH\000\0225\n\021intercept_message\030\003 \001(\0132\030.p"
    "rotos.InterceptMessageH\000\022/\n\016goalie_messa"
    "ge\030\004 \001(\0132\025.protos.GoalieMessageH\000\022C\n\031goa"
    "lie_and_player_message\030\005 \001(\0132\036.protos.Go"
    "alieAndPlayerMessageH\000\022:\n\024offside_line_m"
    "essage\030\006 \001(\0132\032.protos.OffsideLineMessage"
    "H\000\022:\n\024defense_line_message\030\007 \001(\0132\032.proto"
    "s.DefenseLineMessageH\000\022:\n\024wait_request_m"
    "essage\030\010 \001(\0132\032.protos.WaitRequestMessage"
    "H\000\0221\n\017setplay_message\030\t \001(\0132\026.protos.Set"
    "playMessageH\000\022:\n\024pass_request_message\030\n "
    "\001(\0132\032.protos.PassRequestMessageH\000\0221\n\017sta"
    "mina_message\030\013 \001(\0132\026.protos.StaminaMessa"
    "geH\000\0223\n\020recovery_message\030\014 \001(\0132\027.protos."
    "RecoveryMessageH\000\022B\n\030stamina_capacity_me"
    "ssage\030\r \001(\0132\036.protos.StaminaCapacityMess"
    "ageH\000\0221\n\017dribble_message\030\016 \001(\0132\026.protos."
    "DribbleMessageH\000\0228\n\023ball_goalie_message\030"
    "\017 \001(\0132\031.protos.BallGoalieMessageH\000\0226\n\022on"
    "e_player_message\030\020 \001(\0132\030.protos.OnePlaye"
    "rMessageH\000\0226\n\022two_player_message\030\021 \001(\0132\030"
    ".protos.TwoPlayerMessageH\000\022:\n\024three_play"
    "er_message\030\022 \001(\0132\032.protos.ThreePlayerMes"
    "sageH\000\022+\n\014self_message\030\023 \001(\0132\023.protos.Se"
    "lfMessageH\000\0223\n\020teammate_message\030\024 \001(\0132\027."
    "protos.TeammateMessageH\000\0223\n\020opponent_mes"
    "sage\030\025 \001(\0132\027.protos.OpponentMessageH\000\0228\n"
    "\023ball_player_message\030\026 \001(\0132\031.protos.Ball"
    "PlayerMessageH\000B\t\n\007message\"\037\n\007PointTo\022\t\n"
    "\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"\013\n\tPointToOf\"7\n\013Atte"
    "ntionTo\022\032\n\004side\030\001 \001(\0162\014.protos.Side\022\014\n\004u"
    "num\030\002 \001(\005\"\017\n\rAttentionToOf\">\n\007AddText\022\"\n"
    "\005level\030\001 \001(\0162\023.protos.LoggerLevel\022\017\n\007mes"
    "sage\030\002 \001(\t\"^\n\010AddPoint\022\"\n\005level\030\001 \001(\0162\023."
    "protos.LoggerLevel\022\037\n\005point\030\002 \001(\0132\020.prot"
    "os.Vector2D\022\r\n\005color\030\003 \001(\t\"|\n\007AddLine\022\"\n"
    "\005level\030\001 \001(\0162\023.protos.LoggerLevel\022\037\n\005sta"
    "rt\030\002 \001(\0132\020.protos.Vector2D\022\035\n\003end\030\003 \001(\0132"
    "\020.protos.Vector2D\022\r\n\005color\030\004 \001(\t\"\226\001\n\006Add"
    "Arc\022\"\n\005level\030\001 \001(\0162\023.protos.LoggerLevel\022"
    " \n\006center\030\002 \001(\0132\020.protos.Vector2D\022\016\n\006rad"
    "ius\030\003 \001(\002\022\023\n\013start_angle\030\004 \001(\002\022\022\n\nspan_a"
    "ngel\030\005 \001(\002\022\r\n\005color\030\006 \001(\t\"~\n\tAddCircle\022\""
    "\n\005level\030\001 \001(\0162\023.protos.LoggerLevel\022 \n\006ce"
    "nter\030\002 \001(\0132\020.protos.Vector2D\022\016\n\006radius\030\003"
    " \001(\002\022\r\n\005color\030\004 \001(\t\022\014\n\004fill\030\005 \001(\010\"\264\001\n\013Ad"
    "dTriangle\022\"\n\005level\030\001 \001(\0162\023.protos.Logger"
    "Level\022 \n\006point1\030\002 \001(\0132\020.protos.Vector2D\022"
    " \n\006point2\030\003 \001(\0132\020.protos.Vector2D\022 \n\006poi"
    "nt3\030\004 \001(\0132\020.protos.Vector2D\022\r\n\005color\030\005 \001"
    "(\t\022\014\n\004fill\030\006 \001(\010\"\211\001\n\014AddRectangle\022\"\n\005lev"
    "el\030\001 \001(\0162\023.protos.LoggerLevel\022\014\n\004left\030\002 "
    "\001(\002\022\013\n\003top\030\003 \001(\002\022\016\n\006length\030\004 \001(\002\022\r\n\005widt"
    "h\030\005 \001(\002\022\r\n\005color\030\006 \001(\t\022\014\n\004fill\030\007 \001(\010\"\277\001\n"
    "\tAddSector\022\"\n\005level\030\001 \001(\0162\023.protos.Logge"
    "rLevel\022 \n\006center\030\002 \001(\0132\020.protos.Vector2D"
    "\022\022\n\nmin_radius\030\003 \001(\002\022\022\n\nmax_radius\030\004 \001(\002"
    "\022\023\n\013start_angle\030\005 \001(\002\022\022\n\nspan_angel\030\006 \001("
    "\002\022\r\n\005color\030\007 \001(\t\022\014\n\004fill\030\010 \001(\010\"t\n\nAddMes"
    "sage\022\"\n\005level\030\001 \001(\0162\023.protos.LoggerLevel"
    "\022\"\n\010position\030\002 \001(\0132\020.protos.Vector2D\022\017\n\007"
    "message\030\003 \001(\t\022\r\n\005color\030\004 \001(\t\"\371\002\n\003Log\022#\n\010"
    "add_text\030\001 \001(\0132\017.protos.AddTextH\000\022%\n\tadd"
    "_point\030\002 \001(\0132\020.protos.AddPointH\000\022#\n\010add_"
    "line\030\003 \001(\0132\017.protos.AddLineH\000\022!\n\007add_arc"
    "\030\004 \001(\0132\016.protos.AddArcH\000\022\'\n\nadd_circle\030\005"
    " \001(\0132\021.protos.AddCircleH\000\022+\n\014add_triangl"
    "e\030\006 \001(\0132\023.protos.AddTriangleH\000\022-\n\radd_re"
    "ctangle\030\007 \001(\0132\024.protos.AddRectangleH\000\022\'\n"
    "\nadd_sector\030\010 \001(\0132\021.protos.AddSectorH\000\022)"
    "\n\013add_message\030\t \001(\0132\022.protos.AddMessageH"
    "\000B\005\n\003log\"\036\n\013DebugClient\022\017\n\007message\030\001 \001(\t"
    "\"l\n\016Body_GoToPoint\022&\n\014target_point\030\001 \001(\013"
    "2\020.protos.Vector2D\022\032\n\022distance_threshold"
    "\030\002 \001(\002\022\026\n\016max_dash_power\030\003 \001(\002\"\177\n\016Body_S"
    "martKick\022&\n\014target_point\030\001 \001(\0132\020.protos."
    "Vector2D\022\023\n\013first_speed\030\002 \001(\002\022\035\n\025first_s"
    "peed_threshold\030\003 \001(\002\022\021\n\tmax_steps\030\004 \001(\005\""
    "4\n\021Bhv_BeforeKickOff\022\037\n\005point\030\001 \001(\0132\020.pr"
    "otos.Vector2D\"\024\n\022Bhv_BodyNeckToBall\"6\n\023B"
    "hv_BodyNeckToPoint\022\037\n\005point\030\001 \001(\0132\020.prot"
    "os.Vector2D\"\017\n\rBhv_Emergency\"s\n\025Bhv_GoTo"
    "PointLookBall\022&\n\014target_point\030\001 \001(\0132\020.pr"
    "otos.Vector2D\022\032\n\022distance_threshold\030\002 \001("
    "\002\022\026\n\016max_dash_power\030\003 \001(\002\"\'\n\022Bhv_NeckBod"
    "yToBall\022\021\n\tangle_buf\030\001 \001(\002\"I\n\023Bhv_NeckBo"
    "dyToPoint\022\037\n\005point\030\001 \001(\0132\020.protos.Vector"
    "2D\022\021\n\tangle_buf\030\002 \001(\002\"\017\n\rBhv_ScanField\"\022"
    "\n\020Body_AdvanceBall\"\020\n\016Body_ClearBall\"\211\001\n"
    "\014Body_Dribble\022&\n\014target_point\030\001 \001(\0132\020.pr"
    "otos.Vector2D\022\032\n\022distance_threshold\030\002 \001("
    "\002\022\022\n\ndash_power\030\003 \001(\002\022\022\n\ndash_count\030\004 \001("
    "\005\022\r\n\005dodge\030\005 \001(\010\"Q\n\023Body_GoToPointDodge\022"
    "&\n\014target_point\030\001 \001(\0132\020.protos.Vector2D\022"
    "\022\n\ndash_power\030\002 \001(\002\"z\n\rBody_HoldBall\022\017\n\007"
    "do_turn\030\001 \001(\010\022+\n\021turn_target_point\030\002 \001(\013"
    "2\020.protos.Vector2D\022+\n\021kick_target_point\030"
    "\003 \001(\0132\020.protos.Vector2D\"M\n\016Body_Intercep"
    "t\022\025\n\rsave_recovery\030\001 \001(\010\022$\n\nface_point\030\002"
    " \001(\0132\020.protos.Vector2D\"c\n\020Body_KickOneSt"
    "ep\022&\n\014target_point\030\001 \001(\0132\020.protos.Vector"
    "2D\022\023\n\013first_speed\030\002 \001(\002\022\022\n\nforce_mode\030\003 "
    "\001(\010\"\017\n\rBody_StopBall\"&\n\rBody_StopDash\022\025\n"
    "\rsave_recovery\030\001 \001(\010\"h\n\022Body_TackleToPoi"
    "nt\022&\n\014target_point\030\001 \001(\0132\020.protos.Vector"
    "2D\022\027\n\017min_probability\030\002 \001(\002\022\021\n\tmin_speed"
    "\030\003 \001(\002\"!\n\020Body_TurnToAngle\022\r\n\005angle\030\001 \001("
    "\002\" \n\017Body_TurnToBall\022\r\n\005cycle\030\001 \001(\005\"I\n\020B"
    "ody_TurnToPoint\022&\n\014target_point\030\001 \001(\0132\020."
    "protos.Vector2D\022\r\n\005cycle\030\002 \001(\005\";\n\021Focus_"
    "MoveToPoint\022&\n\014target_point\030\001 \001(\0132\020.prot"
    "os.Vector2D\"\r\n\013Focus_Reset\"\020\n\016Neck_ScanF"
    "ield\"\022\n\020Neck_ScanPlayers\"g\n\030Neck_TurnToB"
    "allAndPlayer\022\032\n\004side\030\001 \001(\0162\014.protos.Side"
    "\022\026\n\016uniform_number\030\002 \001(\005\022\027\n\017count_thresh"
    "old\030\003 \001(\005\"0\n\025Neck_TurnToBallOrScan\022\027\n\017co"
    "unt_threshold\030\001 \001(\005\"\021\n\017Neck_TurnToBall\"2"
    "\n\027Neck_TurnToGoalieOrScan\022\027\n\017count_thres"
    "hold\030\001 \001(\005\"\034\n\032Neck_TurnToLowConfTeammate"
    "\"f\n\027Neck_TurnToPlayerOrScan\022\032\n\004side\030\001 \001("
    "\0162\014.protos.Side\022\026\n\016uniform_number\030\002 \001(\005\022"
    "\027\n\017count_threshold\030\003 \001(\005\":\n\020Neck_TurnToP"
    "oint\022&\n\014target_point\030\001 \001(\0132\020.protos.Vect"
    "or2D\"$\n\023Neck_TurnToRelative\022\r\n\005angle\030\001 \001"
    "(\002\"9\n\020View_ChangeWidth\022%\n\nview_width\030\001 \001"
    "(\0162\021.protos.ViewWidth\"\r\n\013View_Normal\"\014\n\n"
    "View_Synch\"\013\n\tView_Wide\"\016\n\014HeliosGoalie\""
    "\022\n\020HeliosGoalieMove\"\022\n\020HeliosGoalieKick\""
    "\r\n\013HeliosShoot\"\320\001\n\021HeliosChainAction\022\023\n\013"
    "direct_pass\030\001 \001(\010\022\021\n\tlead_pass\030\002 \001(\010\022\024\n\014"
    "through_pass\030\003 \001(\010\022\025\n\rshort_dribble\030\004 \001("
    "\010\022\024\n\014long_dribble\030\005 \001(\010\022\r\n\005cross\030\006 \001(\010\022\023"
    "\n\013simple_pass\030\007 \001(\010\022\026\n\016simple_dribble\030\010 "
    "\001(\010\022\024\n\014simple_shoot\030\t \001(\010\"\026\n\024HeliosBasic"
    "Offensive\"\021\n\017HeliosBasicMove\"\017\n\rHeliosSe"
    "tPlay\"\017\n\rHeliosPenalty\"\024\n\022HeliosCommunic"
    "aion\"\343\031\n\014PlayerAction\022\034\n\004dash\030\001 \001(\0132\014.pr"
    "otos.DashH\000\022\034\n\004turn\030\002 \001(\0132\014.protos.TurnH"
    "\000\022\034\n\004kick\030\003 \001(\0132\014.protos.KickH\000\022 \n\006tackl"
    "e\030\004 \001(\0132\016.protos.TackleH\000\022\036\n\005catch\030\005 \001(\013"
    "2\r.protos.CatchH\000\022\034\n\004move\030\006 \001(\0132\014.protos"
    ".MoveH\000\022%\n\tturn_neck\030\007 \001(\0132\020.protos.Turn"
    "NeckH\000\022)\n\013change_view\030\010 \001(\0132\022.protos.Cha"
    "ngeViewH\000\022\032\n\003say\030\t \001(\0132\013.protos.SayH\000\022#\n"
    "\010point_to\030\n \001(\0132\017.protos.PointToH\000\022(\n\013po"
    "int_to_of\030\013 \001(\0132\021.protos.PointToOfH\000\022+\n\014"
    "attention_to\030\014 \001(\0132\023.protos.AttentionToH"
    "\000\0220\n\017attention_to_of\030\r \001(\0132\025.protos.Atte"
    "ntionToOfH\000\022\032\n\003log\030\016 \001(\0132\013.protos.LogH\000\022"
    "+\n\014debug_client\030\017 \001(\0132\023.protos.DebugClie"
    "ntH\000\0222\n\020body_go_to_point\030\020 \001(\0132\026.protos."
    "Body_GoToPointH\000\0221\n\017body_smart_kick\030\021 \001("
    "\0132\026.protos.Body_SmartKickH\000\0228\n\023bhv_befor"
    "e_kick_off\030\022 \001(\0132\031.protos.Bhv_BeforeKick"
    "OffH\000\022;\n\025bhv_body_neck_to_ball\030\023 \001(\0132\032.p"
    "rotos.Bhv_BodyNeckToBallH\000\022=\n\026bhv_body_n"
    "eck_to_point\030\024 \001(\0132\033.protos.Bhv_BodyNeck"
    "ToPointH\000\022.\n\rbhv_emergency\030\025 \001(\0132\025.proto"
    "s.Bhv_EmergencyH\000\022B\n\031bhv_go_to_point_loo"
    "k_ball\030\026 \001(\0132\035.protos.Bhv_GoToPointLookB"
    "allH\000\022;\n\025bhv_neck_body_to_ball\030\027 \001(\0132\032.p"
    "rotos.Bhv_NeckBodyToBallH\000\022=\n\026bhv_neck_b"
    "ody_to_point\030\030 \001(\0132\033.protos.Bhv_NeckBody"
    "ToPointH\000\022/\n\016bhv_scan_field\030\031 \001(\0132\025.prot"
    "os.Bhv_ScanFieldH\000\0225\n\021body_advance_ball\030"
    "\032 \001(\0132\030.protos.Body_AdvanceBallH\000\0221\n\017bod"
    "y_clear_ball\030\033 \001(\0132\026.protos.Body_ClearBa"
    "llH\000\022,\n\014body_dribble\030\034 \001(\0132\024.protos.Body"
    "_DribbleH\000\022=\n\026body_go_to_point_dodge\030\035 \001"
    "(\0132\033.protos.Body_GoToPointDodgeH\000\022/\n\016bod"
    "y_hold_ball\030\036 \001(\0132\025.protos.Body_HoldBall"
    "H\000\0220\n\016body_intercept\030\037 \001(\0132\026.protos.Body"
    "_InterceptH\000\0226\n\022body_kick_one_step\030  \001(\013"
    "2\030.protos.Body_KickOneStepH\000\022/\n\016body_sto"
    "p_ball\030! \001(\0132\025.protos.Body_StopBallH\000\022/\n"
    "\016body_stop_dash\030\" \001(\0132\025.protos.Body_Stop"
    "DashH\000\022:\n\024body_tackle_to_point\030# \001(\0132\032.p"
    "rotos.Body_TackleToPointH\000\0226\n\022body_turn_"
    "to_angle\030$ \001(\0132\030.protos.Body_TurnToAngle"
    "H\000\0224\n\021body_turn_to_ball\030% \001(\0132\027.protos.B"
    "ody_TurnToBallH\000\0226\n\022body_turn_to_point\030&"
    " \001(\0132\030.protos.Body_TurnToPointH\000\0228\n\023focu"
    "s_move_to_point\030\' \001(\0132\031.protos.Focus_Mov"
    "eToPointH\000\022*\n\013focus_reset\030( \001(\0132\023.protos"
    ".Focus_ResetH\000\0221\n\017neck_scan_field\030) \001(\0132"
    "\026.protos.Neck_ScanFieldH\000\0225\n\021neck_scan_p"
    "layers\030* \001(\0132\030.protos.Neck_ScanPlayersH\000"
    "\022H\n\034neck_turn_to_ball_and_player\030+ \001(\0132 "
    ".protos.Neck_TurnToBallAndPlayerH\000\022B\n\031ne"
    "ck_turn_to_ball_or_scan\030, \001(\0132\035.protos.N"
    "eck_TurnToBallOrScanH\000\0224\n\021neck_turn_to_b"
    "all\030- \001(\0132\027.protos.Neck_TurnToBallH\000\022F\n\033"
    "neck_turn_to_goalie_or_scan\030. \001(\0132\037.prot"
    "os.Neck_TurnToGoalieOrScanH\000\022L\n\036neck_tur"
    "n_to_low_conf_teammate\030/ \001(\0132\".protos.Ne"
    "ck_TurnToLowConfTeammateH\000\022F\n\033neck_turn_"
    "to_player_or_scan\0300 \001(\0132\037.protos.Neck_Tu"
    "rnToPlayerOrScanH\000\0226\n\022neck_turn_to_point"
    "\0301 \001(\0132\030.protos.Neck_TurnToPointH\000\022<\n\025ne"
    "ck_turn_to_relative\0302 \001(\0132\033.protos.Neck_"
    "TurnToRelativeH\000\0225\n\021view_change_width\0303 "
    "\001(\0132\030.protos.View_ChangeWidthH\000\022*\n\013view_"
    "normal\0304 \001(\0132\023.protos.View_NormalH\000\022(\n\nv"
    "iew_synch\0305 \001(\0132\022.protos.View_SynchH\000\022&\n"
    "\tview_wide\0306 \001(\0132\021.protos.View_WideH\000\022-\n"
    "\rhelios_goalie\0307 \001(\0132\024.protos.HeliosGoal"
    "ieH\000\0226\n\022helios_goalie_move\0308 \001(\0132\030.proto"
    "s.HeliosGoalieMoveH\000\0226\n\022helios_goalie_ki"
    "ck\0309 \001(\0132\030.protos.HeliosGoalieKickH\000\022+\n\014"
    "helios_shoot\030: \001(\0132\023.protos.HeliosShootH"
    "\000\0228\n\023helios_chain_action\030; \001(\0132\031.protos."
    "HeliosChainActionH\000\022>\n\026helios_basic_offe"
    "nsive\030< \001(\0132\034.protos.HeliosBasicOffensiv"
    "eH\000\0224\n\021helios_basic_move\030= \001(\0132\027.protos."
    "HeliosBasicMoveH\000\0220\n\017helios_set_play\030> \001"
    "(\0132\025.protos.HeliosSetPlayH\000\022/\n\016helios_pe"
    "nalty\030\? \001(\0132\025.protos.HeliosPenaltyH\000\022:\n\024"
    "helios_communication\030@ \001(\0132\032.protos.Heli"
    "osCommunicaionH\000B\010\n\006action\"6\n\rPlayerActi"
    "ons\022%\n\007actions\030\001 \003(\0132\024.protos.PlayerActi"
    "on\"8\n\020ChangePlayerType\022\026\n\016uniform_number"
    "\030\001 \001(\005\022\014\n\004type\030\002 \001(\005\"\024\n\022DoHeliosSubstitu"
    "te\"\030\n\026DoHeliosSayPlayerTypes\"\322\001\n\013CoachAc"
    "tion\0227\n\023change_player_types\030\001 \001(\0132\030.prot"
    "os.ChangePlayerTypeH\000\022:\n\024do_helios_subst"
    "itute\030\002 \001(\0132\032.protos.DoHeliosSubstituteH"
    "\000\022D\n\032do_helios_say_player_types\030\003 \001(\0132\036."
    "protos.DoHeliosSayPlayerTypesH\000B\010\n\006actio"
    "n\"4\n\014CoachActions\022$\n\007actions\030\001 \003(\0132\023.pro"
    "tos.CoachAction\"\013\n\tDoKickOff\"T\n\nDoMoveBa"
    "ll\022\"\n\010position\030\001 \001(\0132\020.protos.Vector2D\022\""
    "\n\010velocity\030\002 \001(\0132\020.protos.Vector2D\"t\n\014Do"
    "MovePlayer\022\020\n\010our_side\030\001 \001(\010\022\026\n\016uniform_"
    "number\030\002 \001(\005\022\"\n\010position\030\003 \001(\0132\020.protos."
    "Vector2D\022\026\n\016body_direction\030\004 \001(\002\"\013\n\tDoRe"
    "cover\"X\n\014DoChangeMode\022,\n\016game_mode_type\030"
    "\001 \001(\0162\024.protos.GameModeType\022\032\n\004side\030\002 \001("
    "\0162\014.protos.Side\"L\n\022DoChangePlayerType\022\020\n"
    "\010our_side\030\001 \001(\010\022\026\n\016uniform_number\030\002 \001(\005\022"
    "\014\n\004type\030\003 \001(\005\"\265\002\n\rTrainerAction\022(\n\013do_ki"
    "ck_off\030\001 \001(\0132\021.protos.DoKickOffH\000\022*\n\014do_"
    "move_ball\030\002 \001(\0132\022.protos.DoMoveBallH\000\022.\n"
    "\016do_move_player\030\003 \001(\0132\024.protos.DoMovePla"
    "yerH\000\022\'\n\ndo_recover\030\004 \001(\0132\021.protos.DoRec"
    "overH\000\022.\n\016do_change_mode\030\005 \001(\0132\024.protos."
    "DoChangeModeH\000\022;\n\025do_change_player_type\030"
    "\006 \001(\0132\032.protos.DoChangePlayerTypeH\000B\010\n\006a"
    "ction\"8\n\016TrainerActions\022&\n\007actions\030\001 \003(\013"
    "2\025.protos.TrainerAction\"\317,\n\013ServerParam\022"
    "%\n\nagent_type\030\001 \001(\0162\021.protos.AgentType\022\026"
    "\n\016inertia_moment\030\002 \001(\002\022\023\n\013player_size\030\003 "
    "\001(\002\022\024\n\014player_decay\030\004 \001(\002\022\023\n\013player_rand"
    "\030\005 \001(\002\022\025\n\rplayer_weight\030\006 \001(\002\022\030\n\020player_"
    "speed_max\030\007 \001(\002\022\030\n\020player_accel_max\030\010 \001("
    "\002\022\023\n\013stamina_max\030\t \001(\002\022\027\n\017stamina_inc_ma"
    "x\030\n \001(\002\022\024\n\014recover_init\030\013 \001(\002\022\027\n\017recover"
    "_dec_thr\030\014 \001(\002\022\023\n\013recover_min\030\r \001(\002\022\023\n\013r"
    "ecover_dec\030\016 \001(\002\022\023\n\013effort_init\030\017 \001(\002\022\026\n"
    "\016effort_dec_thr\030\020 \001(\002\022\022\n\neffort_min\030\021 \001("
    "\002\022\022\n\neffort_dec\030\022 \001(\002\022\026\n\016effort_inc_thr\030"
    "\023 \001(\002\022\022\n\neffort_inc\030\024 \001(\002\022\021\n\tkick_rand\030\025"
    " \001(\002\022\033\n\023team_actuator_noise\030\026 \001(\010\022\034\n\024pla"
    "yer_rand_factor_l\030\027 \001(\002\022\034\n\024player_rand_f"
    "actor_r\030\030 \001(\002\022\032\n\022kick_rand_factor_l\030\031 \001("
    "\002\022\032\n\022kick_rand_factor_r\030\032 \001(\002\022\021\n\tball_si"
    "ze\030\033 \001(\002\022\022\n\nball_decay\030\034 \001(\002\022\021\n\tball_ran"
    "d\030\035 \001(\002\022\023\n\013ball_weight\030\036 \001(\002\022\026\n\016ball_spe"
    "ed_max\030\037 \001(\002\022\026\n\016ball_accel_max\030  \001(\002\022\027\n\017"
    "dash_power_rate\030! \001(\002\022\027\n\017kick_power_rate"
    "\030\" \001(\002\022\027\n\017kickable_margin\030# \001(\002\022\026\n\016contr"
    "ol_radius\030$ \001(\002\022\034\n\024control_radius_width\030"
    "% \001(\002\022\021\n\tmax_power\030& \001(\002\022\021\n\tmin_power\030\' "
    "\001(\002\022\022\n\nmax_moment\030( \001(\002\022\022\n\nmin_moment\030) "
    "\001(\002\022\027\n\017max_neck_moment\030* \001(\002\022\027\n\017min_neck"
    "_moment\030+ \001(\002\022\026\n\016max_neck_angle\030, \001(\002\022\026\n"
    "\016min_neck_angle\030- \001(\002\022\025\n\rvisible_angle\030."
    " \001(\002\022\030\n\020visible_distance\030/ \001(\002\022\020\n\010wind_d"
    "ir\0300 \001(\002\022\022\n\nwind_force\0301 \001(\002\022\022\n\nwind_ang"
    "le\0302 \001(\002\022\021\n\twind_rand\0303 \001(\002\022\025\n\rkickable_"
    "area\0304 \001(\002\022\024\n\014catch_area_l\0305 \001(\002\022\024\n\014catc"
    "h_area_w\0306 \001(\002\022\031\n\021catch_probability\0307 \001("
    "\002\022\030\n\020goalie_max_moves\0308 \001(\005\022\032\n\022corner_ki"
    "ck_margin\0309 \001(\002\022 \n\030offside_active_area_s"
    "ize\030: \001(\002\022\021\n\twind_none\030; \001(\010\022\027\n\017use_wind"
    "_random\030< \001(\010\022\033\n\023coach_say_count_max\030= \001"
    "(\005\022\032\n\022coach_say_msg_size\030> \001(\005\022\026\n\016clang_"
    "win_size\030\? \001(\005\022\030\n\020clang_define_win\030@ \001(\005"
    "\022\026\n\016clang_meta_win\030A \001(\005\022\030\n\020clang_advice"
    "_win\030B \001(\005\022\026\n\016clang_info_win\030C \001(\005\022\030\n\020cl"
    "ang_mess_delay\030D \001(\005\022\034\n\024clang_mess_per_c"
    "ycle\030E \001(\005\022\021\n\thalf_time\030F \001(\005\022\026\n\016simulat"
    "or_step\030G \001(\005\022\021\n\tsend_step\030H \001(\005\022\021\n\trecv"
    "_step\030I \001(\005\022\027\n\017sense_body_step\030J \001(\005\022\020\n\010"
    "lcm_step\030K \001(\005\022\033\n\023player_say_msg_size\030L "
    "\001(\005\022\027\n\017player_hear_max\030M \001(\005\022\027\n\017player_h"
    "ear_inc\030N \001(\005\022\031\n\021player_hear_decay\030O \001(\005"
    "\022\027\n\017catch_ban_cycle\030P \001(\005\022\030\n\020slow_down_f"
    "actor\030Q \001(\005\022\023\n\013use_offside\030R \001(\010\022\027\n\017kick"
    "off_offside\030S \001(\010\022\033\n\023offside_kick_margin"
    "\030T \001(\002\022\026\n\016audio_cut_dist\030U \001(\002\022\032\n\022dist_q"
    "uantize_step\030V \001(\002\022#\n\033landmark_dist_quan"
    "tize_step\030W \001(\002\022\031\n\021dir_quantize_step\030X \001"
    "(\002\022\034\n\024dist_quantize_step_l\030Y \001(\002\022\034\n\024dist"
    "_quantize_step_r\030Z \001(\002\022%\n\035landmark_dist_"
    "quantize_step_l\030[ \001(\002\022%\n\035landmark_dist_q"
    "uantize_step_r\030\\ \001(\002\022\033\n\023dir_quantize_ste"
    "p_l\030] \001(\002\022\033\n\023dir_quantize_step_r\030^ \001(\002\022\022"
    "\n\ncoach_mode\030_ \001(\010\022\037\n\027coach_with_referee"
    "_mode\030` \001(\010\022\032\n\022use_old_coach_hear\030a \001(\010\022"
    "%\n\035slowness_on_top_for_left_team\030b \001(\002\022&"
    "\n\036slowness_on_top_for_right_team\030c \001(\002\022\024"
    "\n\014start_goal_l\030d \001(\005\022\024\n\014start_goal_r\030e \001"
    "(\005\022\023\n\013fullstate_l\030f \001(\010\022\023\n\013fullstate_r\030g"
    " \001(\010\022\026\n\016drop_ball_time\030h \001(\005\022\022\n\nsynch_mo"
    "de\030i \001(\010\022\024\n\014synch_offset\030j \001(\005\022\031\n\021synch_"
    "micro_sleep\030k \001(\005\022\024\n\014point_to_ban\030l \001(\005\022"
    "\031\n\021point_to_duration\030m \001(\005\022\023\n\013player_por"
    "t\030n \001(\005\022\024\n\014trainer_port\030o \001(\005\022\031\n\021online_"
    "coach_port\030p \001(\005\022\024\n\014verbose_mode\030q \001(\010\022\032"
    "\n\022coach_send_vi_step\030r \001(\005\022\023\n\013replay_fil"
    "e\030s \001(\t\022\025\n\rlandmark_file\030t \001(\t\022\022\n\nsend_c"
    "omms\030u \001(\010\022\024\n\014text_logging\030v \001(\010\022\024\n\014game"
    "_logging\030w \001(\010\022\030\n\020game_log_version\030x \001(\005"
    "\022\024\n\014text_log_dir\030y \001(\t\022\024\n\014game_log_dir\030z"
    " \001(\t\022\033\n\023text_log_fixed_name\030{ \001(\t\022\033\n\023gam"
    "e_log_fixed_name\030| \001(\t\022\032\n\022use_text_log_f"
    "ixed\030} \001(\010\022\032\n\022use_game_log_fixed\030~ \001(\010\022\032"
    "\n\022use_text_log_dated\030\177 \001(\010\022\033\n\022use_game_l"
    "og_dated\030\200\001 \001(\010\022\030\n\017log_date_format\030\201\001 \001("
    "\t\022\022\n\tlog_times\030\202\001 \001(\010\022\027\n\016record_message\030"
    "\203\001 \001(\010\022\035\n\024text_log_compression\030\204\001 \001(\005\022\035\n"
    "\024game_log_compression\030\205\001 \001(\005\022\024\n\013use_prof"
    "ile\030\206\001 \001(\010\022\024\n\013tackle_dist\030\207\001 \001(\002\022\031\n\020tack"
    "le_back_dist\030\210\001 \001(\002\022\025\n\014tackle_width\030\211\001 \001"
    "(\002\022\030\n\017tackle_exponent\030\212\001 \001(\002\022\026\n\rtackle_c"
    "ycles\030\213\001 \001(\005\022\032\n\021tackle_power_rate\030\214\001 \001(\002"
    "\022\035\n\024freeform_wait_period\030\215\001 \001(\005\022\035\n\024freef"
    "orm_send_period\030\216\001 \001(\005\022\031\n\020free_kick_faul"
    "ts\030\217\001 \001(\010\022\024\n\013back_passes\030\220\001 \001(\010\022\032\n\021prope"
    "r_goal_kicks\030\221\001 \001(\010\022\031\n\020stopped_ball_vel\030"
    "\222\001 \001(\002\022\027\n\016max_goal_kicks\030\223\001 \001(\005\022\026\n\rclang"
    "_del_win\030\224\001 \001(\005\022\027\n\016clang_rule_win\030\225\001 \001(\005"
    "\022\022\n\tauto_mode\030\226\001 \001(\010\022\026\n\rkick_off_wait\030\227\001"
    " \001(\005\022\025\n\014connect_wait\030\230\001 \001(\005\022\027\n\016game_over"
    "_wait\030\231\001 \001(\005\022\025\n\014team_l_start\030\232\001 \001(\t\022\025\n\014t"
    "eam_r_start\030\233\001 \001(\t\022\026\n\rkeepaway_mode\030\234\001 \001"
    "(\010\022\030\n\017keepaway_length\030\235\001 \001(\002\022\027\n\016keepaway"
    "_width\030\236\001 \001(\002\022\031\n\020keepaway_logging\030\237\001 \001(\010"
    "\022\031\n\020keepaway_log_dir\030\240\001 \001(\t\022 \n\027keepaway_"
    "log_fixed_name\030\241\001 \001(\t\022\033\n\022keepaway_log_fi"
    "xed\030\242\001 \001(\010\022\033\n\022keepaway_log_dated\030\243\001 \001(\010\022"
    "\027\n\016keepaway_start\030\244\001 \001(\005\022\030\n\017nr_normal_ha"
    "lfs\030\245\001 \001(\005\022\027\n\016nr_extra_halfs\030\246\001 \001(\005\022\033\n\022p"
    "enalty_shoot_outs\030\247\001 \001(\010\022\036\n\025pen_before_s"
    "etup_wait\030\250\001 \001(\005\022\027\n\016pen_setup_wait\030\251\001 \001("
    "\005\022\027\n\016pen_ready_wait\030\252\001 \001(\005\022\027\n\016pen_taken_"
    "wait\030\253\001 \001(\005\022\025\n\014pen_nr_kicks\030\254\001 \001(\005\022\034\n\023pe"
    "n_max_extra_kicks\030\255\001 \001(\005\022\023\n\npen_dist_x\030\256"
    "\001 \001(\002\022\032\n\021pen_random_winner\030\257\001 \001(\010\022\035\n\024pen"
    "_allow_mult_kicks\030\260\001 \001(\010\022\036\n\025pen_max_goal"
    "ie_dist_x\030\261\001 \001(\002\022 \n\027pen_coach_moves_play"
    "ers\030\262\001 \001(\010\022\023\n\nmodule_dir\030\263\001 \001(\t\022\030\n\017ball_"
    "stuck_area\030\264\001 \001(\002\022\027\n\016coach_msg_file\030\265\001 \001"
    "(\t\022\031\n\020max_tackle_power\030\266\001 \001(\002\022\036\n\025max_bac"
    "k_tackle_power\030\267\001 \001(\002\022\035\n\024player_speed_ma"
    "x_min\030\270\001 \001(\002\022\026\n\rextra_stamina\030\271\001 \001(\002\022\031\n\020"
    "synch_see_offset\030\272\001 \001(\005\022\030\n\017extra_half_ti"
    "me\030\273\001 \001(\005\022\031\n\020stamina_capacity\030\274\001 \001(\002\022\027\n\016"
    "max_dash_angle\030\275\001 \001(\002\022\027\n\016min_dash_angle\030"
    "\276\001 \001(\002\022\030\n\017dash_angle_step\030\277\001 \001(\002\022\027\n\016side"
    "_dash_rate\030\300\001 \001(\002\022\027\n\016back_dash_rate\030\301\001 \001"
    "(\002\022\027\n\016max_dash_power\030\302\001 \001(\002\022\027\n\016min_dash_"
    "power\030\303\001 \001(\002\022\033\n\022tackle_rand_factor\030\304\001 \001("
    "\002\022 \n\027foul_detect_probability\030\305\001 \001(\002\022\026\n\rf"
    "oul_exponent\030\306\001 \001(\002\022\024\n\013foul_cycles\030\307\001 \001("
    "\005\022\024\n\013golden_goal\030\310\001 \001(\010\022\035\n\024red_card_prob"
    "ability\030\311\001 \001(\002\022!\n\030illegal_defense_durati"
    "on\030\312\001 \001(\005\022\037\n\026illegal_defense_number\030\313\001 \001"
    "(\005\022\037\n\026illegal_defense_dist_x\030\314\001 \001(\002\022\036\n\025i"
    "llegal_defense_width\030\315\001 \001(\002\022\031\n\020fixed_tea"
    "mname_l\030\316\001 \001(\t\022\031\n\020fixed_teamname_r\030\317\001 \001("
    "\t\022\030\n\017max_catch_angle\030\320\001 \001(\002\022\030\n\017min_catch"
    "_angle\030\321\001 \001(\002\022\024\n\013random_seed\030\322\001 \001(\005\022\037\n\026l"
    "ong_kick_power_factor\030\323\001 \001(\002\022\030\n\017long_kic"
    "k_delay\030\324\001 \001(\005\022\025\n\014max_monitors\030\325\001 \001(\005\022\027\n"
    "\016catchable_area\030\326\001 \001(\002\022\027\n\016real_speed_max"
    "\030\327\001 \001(\002\022\032\n\021pitch_half_length\030\330\001 \001(\002\022\031\n\020p"
    "itch_half_width\030\331\001 \001(\002\022 \n\027our_penalty_ar"
    "ea_line_x\030\332\001 \001(\002\022\"\n\031their_penalty_area_l"
    "ine_x\030\333\001 \001(\002\022 \n\027penalty_area_half_width\030"
    "\334\001 \001(\002\022\034\n\023penalty_area_length\030\335\001 \001(\002\022\023\n\n"
    "goal_width\030\336\001 \001(\002\"\377\007\n\013PlayerParam\022%\n\nage"
    "nt_type\030\001 \001(\0162\021.protos.AgentType\022\024\n\014play"
    "er_types\030\002 \001(\005\022\020\n\010subs_max\030\003 \001(\005\022\016\n\006pt_m"
    "ax\030\004 \001(\005\022\037\n\027allow_mult_default_type\030\005 \001("
    "\010\022\"\n\032player_speed_max_delta_min\030\006 \001(\002\022\"\n"
    "\032player_speed_max_delta_max\030\007 \001(\002\022$\n\034sta"
    "mina_inc_max_delta_factor\030\010 \001(\002\022\036\n\026playe"
    "r_decay_delta_min\030\t \001(\002\022\036\n\026player_decay_"
    "delta_max\030\n \001(\002\022#\n\033inertia_moment_delta_"
    "factor\030\013 \001(\002\022!\n\031dash_power_rate_delta_mi"
    "n\030\014 \001(\002\022!\n\031dash_power_rate_delta_max\030\r \001"
    "(\002\022 \n\030player_size_delta_factor\030\016 \001(\002\022!\n\031"
    "kickable_margin_delta_min\030\017 \001(\002\022!\n\031kicka"
    "ble_margin_delta_max\030\020 \001(\002\022\036\n\026kick_rand_"
    "delta_factor\030\021 \001(\002\022\037\n\027extra_stamina_delt"
    "a_min\030\022 \001(\002\022\037\n\027extra_stamina_delta_max\030\023"
    " \001(\002\022\037\n\027effort_max_delta_factor\030\024 \001(\002\022\037\n"
    "\027effort_min_delta_factor\030\025 \001(\002\022\023\n\013random"
    "_seed\030\026 \001(\005\022%\n\035new_dash_power_rate_delta"
    "_min\030\027 \001(\002\022%\n\035new_dash_power_rate_delta_"
    "max\030\030 \001(\002\022(\n new_stamina_inc_max_delta_f"
    "actor\030\031 \001(\002\022!\n\031kick_power_rate_delta_min"
    "\030\032 \001(\002\022!\n\031kick_power_rate_delta_max\030\033 \001("
    "\002\022,\n$foul_detect_probability_delta_facto"
    "r\030\034 \001(\002\022$\n\034catchable_area_l_stretch_min\030"
    "\035 \001(\002\022$\n\034catchable_area_l_stretch_max\030\036 "
    "\001(\002\"\261\007\n\nPlayerType\022%\n\nagent_type\030\001 \001(\0162\021"
    ".protos.AgentType\022\n\n\002id\030\002 \001(\005\022\027\n\017stamina"
    "_inc_max\030\003 \001(\002\022\024\n\014player_decay\030\004 \001(\002\022\026\n\016"
    "inertia_moment\030\005 \001(\002\022\027\n\017dash_power_rate\030"
    "\006 \001(\002\022\023\n\013player_size\030\007 \001(\002\022\027\n\017kickable_m"
    "argin\030\010 \001(\002\022\021\n\tkick_rand\030\t \001(\002\022\025\n\rextra_"
    "stamina\030\n \001(\002\022\022\n\neffort_max\030\013 \001(\002\022\022\n\neff"
    "ort_min\030\014 \001(\002\022\027\n\017kick_power_rate\030\r \001(\002\022\037"
    "\n\027foul_detect_probability\030\016 \001(\002\022 \n\030catch"
    "able_area_l_stretch\030\017 \001(\002\022\027\n\017unum_far_le"
    "ngth\030\020 \001(\002\022\033\n\023unum_too_far_length\030\021 \001(\002\022"
    "\027\n\017team_far_length\030\022 \001(\002\022\033\n\023team_too_far"
    "_length\030\023 \001(\002\022%\n\035player_max_observation_"
    "length\030\024 \001(\002\022\033\n\023ball_vel_far_length\030\025 \001("
    "\002\022\037\n\027ball_vel_too_far_length\030\026 \001(\002\022#\n\033ba"
    "ll_max_observation_length\030\027 \001(\002\022\033\n\023flag_"
    "chg_far_length\030\030 \001(\002\022\037\n\027flag_chg_too_far"
    "_length\030\031 \001(\002\022#\n\033flag_max_observation_le"
    "ngth\030\032 \001(\002\022\025\n\rkickable_area\030\033 \001(\002\022\037\n\027rel"
    "iable_catchable_dist\030\034 \001(\002\022\032\n\022max_catcha"
    "ble_dist\030\035 \001(\002\022\026\n\016real_speed_max\030\036 \001(\002\022\031"
    "\n\021player_speed_max2\030\037 \001(\002\022\027\n\017real_speed_"
    "max2\030  \001(\002\022!\n\031cycles_to_reach_max_speed\030"
    "! \001(\005\022\030\n\020player_speed_max\030\" \001(\002\"\007\n\005Empty"
    "\"\027\n\025InitMessageFromServer*-\n\tViewWidth\022\n"
    "\n\006NARROW\020\000\022\n\n\006NORMAL\020\001\022\010\n\004WIDE\020\002*(\n\004Side"
    "\022\013\n\007UNKNOWN\020\000\022\010\n\004LEFT\020\001\022\t\n\005RIGHT\020\002*\255\002\n\013L"
    "oggerLevel\022\010\n\004None\020\000\022\n\n\006SYSTEM\020\001\022\n\n\006SENS"
    "OR\020\002\022\t\n\005WORLD\020\004\022\n\n\006ACTION\020\010\022\r\n\tINTERCEPT"
    "\020\020\022\010\n\004KICK\020 \022\010\n\004HOLD\020@\022\014\n\007DRIBBLE\020\200\001\022\t\n\004"
    "PASS\020\200\002\022\n\n\005CROSS\020\200\004\022\n\n\005SHOOT\020\200\010\022\n\n\005CLEAR"
    "\020\200\020\022\n\n\005BLOCK\020\200 \022\t\n\004MARK\020\200@\022\021\n\013POSITIONIN"
    "G\020\200\200\001\022\n\n\004ROLE\020\200\200\002\022\n\n\004TEAM\020\200\200\004\022\023\n\rCOMMUNI"
    "CATION\020\200\200\010\022\016\n\010ANALYZER\020\200\200\020\022\022\n\014ACTION_CHA"
    "IN\020\200\200 \022\n\n\004PLAN\020\200\200@*v\n\023InterceptActionTyp"
    "e\022!\n\035UNKNOWN_Intercept_Action_Type\020\000\022\r\n\t"
    "OMNI_DASH\020\001\022\025\n\021TURN_FORWARD_DASH\020\002\022\026\n\022TU"
    "RN_BACKWARD_DASH\020\003*\273\004\n\014GameModeType\022\021\n\rB"
    "eforeKickOff\020\000\022\014\n\010TimeOver\020\001\022\n\n\006PlayOn\020\002"
    "\022\014\n\010KickOff_\020\003\022\013\n\007KickIn_\020\004\022\r\n\tFreeKick_"
    "\020\005\022\017\n\013CornerKick_\020\006\022\r\n\tGoalKick_\020\007\022\016\n\nAf"
    "terGoal_\020\010\022\014\n\010OffSide_\020\t\022\020\n\014PenaltyKick_"
    "\020\n\022\021\n\rFirstHalfOver\020\013\022\t\n\005Pause\020\014\022\t\n\005Huma"
    "n\020\r\022\017\n\013FoulCharge_\020\016\022\r\n\tFoulPush_\020\017\022\031\n\025F"
    "oulMultipleAttacker_\020\020\022\020\n\014FoulBallOut_\020\021"
    "\022\r\n\tBackPass_\020\022\022\022\n\016FreeKickFault_\020\023\022\017\n\013C"
    "atchFault_\020\024\022\020\n\014IndFreeKick_\020\025\022\021\n\rPenalt"
    "ySetup_\020\026\022\021\n\rPenaltyReady_\020\027\022\021\n\rPenaltyT"
    "aken_\020\030\022\020\n\014PenaltyMiss_\020\031\022\021\n\rPenaltyScor"
    "e_\020\032\022\023\n\017IllegalDefense_\020\033\022\023\n\017PenaltyOnfi"
    "eld_\020\034\022\020\n\014PenaltyFoul_\020\035\022\020\n\014GoalieCatch_"
    "\020\036\022\016\n\nExtendHalf\020\037\022\014\n\010MODE_MAX\020 *2\n\tAgen"
    "tType\022\013\n\007PlayerT\020\000\022\n\n\006CoachT\020\001\022\014\n\010Traine"
    "rT\020\0022\340\003\n\004Game\022:\n\020GetPlayerActions\022\r.prot"
    "os.State\032\025.protos.PlayerActions\"\000\0228\n\017Get"
    "CoachActions\022\r.protos.State\032\024.protos.Coa"
    "chActions\"\000\022<\n\021GetTrainerActions\022\r.proto"
    "s.State\032\026.protos.TrainerActions\"\000\0227\n\017Sen"
    "dInitMessage\022\023.protos.InitMessage\032\r.prot"
    "os.Empty\"\000\0228\n\020SendServerParams\022\023.protos."
    "ServerParam\032\r.protos.Empty\"\000\0228\n\020SendPlay"
    "erParams\022\023.protos.PlayerParam\032\r.protos.E"
    "mpty\"\000\0225\n\016SendPlayerType\022\022.protos.Player"
    "Type\032\r.protos.Empty\"\000\022@\n\016GetInitMessage\022"
    "\r.protos.Empty\032\035.protos.InitMessageFromS"
    "erver\"\000b\006proto3"
};
static ::absl::once_flag descriptor_table_service_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_service_2eproto = {
    false,
    false,
    26455,
    descriptor_table_protodef_service_2eproto,
    "service.proto",
    &descriptor_table_service_2eproto_once,
    nullptr,
    0,
    127,
    schemas,
    file_default_instances,
    TableStruct_service_2eproto::offsets,
    file_level_metadata_service_2eproto,
    file_level_enum_descriptors_service_2eproto,
    file_level_service_descriptors_service_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_service_2eproto_getter() {
  return &descriptor_table_service_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_service_2eproto(&descriptor_table_service_2eproto);
namespace protos {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ViewWidth_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[0];
}
bool ViewWidth_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[1];
}
bool Side_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoggerLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[2];
}
bool LoggerLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InterceptActionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[3];
}
bool InterceptActionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameModeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[4];
}
bool GameModeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgentType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[5];
}
bool AgentType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Vector2D::_Internal {
 public:
};

Vector2D::Vector2D(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Vector2D)
}
Vector2D::Vector2D(const Vector2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Vector2D)
}

inline void Vector2D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , decltype(_impl_.dist_) { 0 }

    , decltype(_impl_.angle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector2D::~Vector2D() {
  // @@protoc_insertion_point(destructor:protos.Vector2D)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector2D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector2D::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Vector2D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.angle_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.angle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector2D::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Vector2D::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Vector2D)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float dist = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = this->_internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_dist(), target);
  }

  // float angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Vector2D)
  return target;
}

::size_t Vector2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Vector2D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float dist = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = this->_internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    total_size += 5;
  }

  // float angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector2D::GetClassData() const { return &_class_data_; }


void Vector2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector2D*>(&to_msg);
  auto& from = static_cast<const Vector2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Vector2D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = from._internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    _this->_internal_set_dist(from._internal_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = from._internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector2D::CopyFrom(const Vector2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Vector2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector2D::IsInitialized() const {
  return true;
}

void Vector2D::InternalSwap(Vector2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector2D, _impl_.angle_)
      + sizeof(Vector2D::_impl_.angle_)
      - PROTOBUF_FIELD_OFFSET(Vector2D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[0]);
}
// ===================================================================

class Ball::_Internal {
 public:
  using HasBits = decltype(std::declval<Ball>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ball, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Ball* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& relative_position(const Ball* msg);
  static void set_has_relative_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& seen_position(const Ball* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& heard_position(const Ball* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& velocity(const Ball* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::protos::Vector2D& seen_velocity(const Ball* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::protos::Vector2D& heard_velocity(const Ball* msg);
  static void set_has_heard_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::protos::Vector2D&
Ball::_Internal::position(const Ball* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Ball::_Internal::relative_position(const Ball* msg) {
  return *msg->_impl_.relative_position_;
}
const ::protos::Vector2D&
Ball::_Internal::seen_position(const Ball* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Ball::_Internal::heard_position(const Ball* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Ball::_Internal::velocity(const Ball* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Ball::_Internal::seen_velocity(const Ball* msg) {
  return *msg->_impl_.seen_velocity_;
}
const ::protos::Vector2D&
Ball::_Internal::heard_velocity(const Ball* msg) {
  return *msg->_impl_.heard_velocity_;
}
Ball::Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Ball)
}
Ball::Ball(const Ball& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Ball* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.relative_position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.heard_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.heard_vel_count_) {}

    , decltype(_impl_.lost_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.dist_from_self_) {}

    , decltype(_impl_.angle_from_self_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.relative_position_ = new ::protos::Vector2D(*from._impl_.relative_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.heard_velocity_ = new ::protos::Vector2D(*from._impl_.heard_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.angle_from_self_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.angle_from_self_));
  // @@protoc_insertion_point(copy_constructor:protos.Ball)
}

inline void Ball::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.relative_position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.heard_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.heard_vel_count_) { 0 }

    , decltype(_impl_.lost_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.dist_from_self_) { 0 }

    , decltype(_impl_.angle_from_self_) { 0 }

  };
}

Ball::~Ball() {
  // @@protoc_insertion_point(destructor:protos.Ball)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ball::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.relative_position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
  if (this != internal_default_instance()) delete _impl_.heard_velocity_;
}

void Ball::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ball::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Ball)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.relative_position_ != nullptr);
      _impl_.relative_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.heard_velocity_ != nullptr);
      _impl_.heard_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.angle_from_self_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.angle_from_self_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ball::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D relative_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_relative_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_velocity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_vel_count = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.heard_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 lost_count = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.lost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_self = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.dist_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_self = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.angle_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ball::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Ball)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D relative_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::relative_position(this),
        _Internal::relative_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_velocity = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::heard_velocity(this),
        _Internal::heard_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 8;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 9;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 10;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 11;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 12;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_seen_vel_count(), target);
  }

  // int32 heard_vel_count = 13;
  if (this->_internal_heard_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_heard_vel_count(), target);
  }

  // int32 lost_count = 14;
  if (this->_internal_lost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_lost_count(), target);
  }

  // int32 ghost_count = 15;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        15, this->_internal_ghost_count(), target);
  }

  // float dist_from_self = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_dist_from_self(), target);
  }

  // float angle_from_self = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_angle_from_self(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Ball)
  return target;
}

::size_t Ball::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Ball)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D relative_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relative_position_);
    }

    // .protos.Vector2D seen_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

    // .protos.Vector2D heard_velocity = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_velocity_);
    }

  }
  // int32 pos_count = 8;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 9;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 10;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 11;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 12;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 heard_vel_count = 13;
  if (this->_internal_heard_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_vel_count());
  }

  // int32 lost_count = 14;
  if (this->_internal_lost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_lost_count());
  }

  // int32 ghost_count = 15;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // float dist_from_self = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    total_size += 6;
  }

  // float angle_from_self = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ball::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ball::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ball::GetClassData() const { return &_class_data_; }


void Ball::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ball*>(&to_msg);
  auto& from = static_cast<const Ball&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Ball)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_relative_position()->::protos::Vector2D::MergeFrom(
          from._internal_relative_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_heard_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_heard_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_heard_vel_count() != 0) {
    _this->_internal_set_heard_vel_count(from._internal_heard_vel_count());
  }
  if (from._internal_lost_count() != 0) {
    _this->_internal_set_lost_count(from._internal_lost_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = from._internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    _this->_internal_set_dist_from_self(from._internal_dist_from_self());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = from._internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    _this->_internal_set_angle_from_self(from._internal_angle_from_self());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ball::CopyFrom(const Ball& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Ball)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ball::IsInitialized() const {
  return true;
}

void Ball::InternalSwap(Ball* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ball, _impl_.angle_from_self_)
      + sizeof(Ball::_impl_.angle_from_self_)
      - PROTOBUF_FIELD_OFFSET(Ball, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ball::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[1]);
}
// ===================================================================

class Player::_Internal {
 public:
  using HasBits = decltype(std::declval<Player>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Player, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Player* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& seen_position(const Player* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& heard_position(const Player* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& velocity(const Player* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& seen_velocity(const Player* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::protos::Vector2D&
Player::_Internal::position(const Player* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Player::_Internal::seen_position(const Player* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Player::_Internal::heard_position(const Player* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Player::_Internal::velocity(const Player* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Player::_Internal::seen_velocity(const Player* msg) {
  return *msg->_impl_.seen_velocity_;
}
Player::Player(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Player)
}
Player::Player(const Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.dist_from_self_) {}

    , decltype(_impl_.angle_from_self_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.side_) {}

    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.uniform_number_count_) {}

    , decltype(_impl_.body_direction_) {}

    , decltype(_impl_.body_direction_count_) {}

    , decltype(_impl_.face_direction_) {}

    , decltype(_impl_.face_direction_count_) {}

    , decltype(_impl_.point_to_direction_) {}

    , decltype(_impl_.point_to_direction_count_) {}

    , decltype(_impl_.is_goalie_) {}

    , decltype(_impl_.is_kicking_) {}

    , decltype(_impl_.is_tackling_) {}

    , decltype(_impl_.dist_from_ball_) {}

    , decltype(_impl_.angle_from_ball_) {}

    , decltype(_impl_.ball_reach_steps_) {}

    , decltype(_impl_.type_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.type_id_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.type_id_));
  // @@protoc_insertion_point(copy_constructor:protos.Player)
}

inline void Player::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.dist_from_self_) { 0 }

    , decltype(_impl_.angle_from_self_) { 0 }

    , decltype(_impl_.id_) { 0 }

    , decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.uniform_number_count_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

    , decltype(_impl_.body_direction_count_) { 0 }

    , decltype(_impl_.face_direction_) { 0 }

    , decltype(_impl_.face_direction_count_) { 0 }

    , decltype(_impl_.point_to_direction_) { 0 }

    , decltype(_impl_.point_to_direction_count_) { 0 }

    , decltype(_impl_.is_goalie_) { false }

    , decltype(_impl_.is_kicking_) { false }

    , decltype(_impl_.is_tackling_) { false }

    , decltype(_impl_.dist_from_ball_) { 0 }

    , decltype(_impl_.angle_from_ball_) { 0 }

    , decltype(_impl_.ball_reach_steps_) { 0 }

    , decltype(_impl_.type_id_) { 0 }

  };
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:protos.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Player::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
}

void Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Player)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.type_id_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.type_id_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_self = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.dist_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_self = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.angle_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side side = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number_count = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.uniform_number_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_goalie = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.is_goalie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 body_direction_count = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.body_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float face_direction = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.face_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 face_direction_count = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.face_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float point_to_direction = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.point_to_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_direction_count = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.point_to_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kicking = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.is_kicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_ball = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.dist_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_ball = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.angle_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ball_reach_steps = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.ball_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_tackling = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.is_tackling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 type_id = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Player::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Player)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_seen_vel_count(), target);
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_ghost_count(), target);
  }

  // float dist_from_self = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_dist_from_self(), target);
  }

  // float angle_from_self = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_angle_from_self(), target);
  }

  // int32 id = 14;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_id(), target);
  }

  // .protos.Side side = 15;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        15, this->_internal_side(), target);
  }

  // int32 uniform_number = 16;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_uniform_number(), target);
  }

  // int32 uniform_number_count = 17;
  if (this->_internal_uniform_number_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_uniform_number_count(), target);
  }

  // bool is_goalie = 18;
  if (this->_internal_is_goalie() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this->_internal_is_goalie(), target);
  }

  // float body_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_body_direction(), target);
  }

  // int32 body_direction_count = 20;
  if (this->_internal_body_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_body_direction_count(), target);
  }

  // float face_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_face_direction(), target);
  }

  // int32 face_direction_count = 22;
  if (this->_internal_face_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_face_direction_count(), target);
  }

  // float point_to_direction = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        23, this->_internal_point_to_direction(), target);
  }

  // int32 point_to_direction_count = 24;
  if (this->_internal_point_to_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_point_to_direction_count(), target);
  }

  // bool is_kicking = 25;
  if (this->_internal_is_kicking() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_is_kicking(), target);
  }

  // float dist_from_ball = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        26, this->_internal_dist_from_ball(), target);
  }

  // float angle_from_ball = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        27, this->_internal_angle_from_ball(), target);
  }

  // int32 ball_reach_steps = 28;
  if (this->_internal_ball_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        28, this->_internal_ball_reach_steps(), target);
  }

  // bool is_tackling = 29;
  if (this->_internal_is_tackling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        29, this->_internal_is_tackling(), target);
  }

  // int32 type_id = 30;
  if (this->_internal_type_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        30, this->_internal_type_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Player)
  return target;
}

::size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Player)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D seen_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

  }
  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // float dist_from_self = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    total_size += 5;
  }

  // float angle_from_self = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    total_size += 5;
  }

  // int32 id = 14;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // .protos.Side side = 15;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 16;
  if (this->_internal_uniform_number() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_uniform_number());
  }

  // int32 uniform_number_count = 17;
  if (this->_internal_uniform_number_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_uniform_number_count());
  }

  // float body_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 6;
  }

  // int32 body_direction_count = 20;
  if (this->_internal_body_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_body_direction_count());
  }

  // float face_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    total_size += 6;
  }

  // int32 face_direction_count = 22;
  if (this->_internal_face_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_face_direction_count());
  }

  // float point_to_direction = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    total_size += 6;
  }

  // int32 point_to_direction_count = 24;
  if (this->_internal_point_to_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_direction_count());
  }

  // bool is_goalie = 18;
  if (this->_internal_is_goalie() != 0) {
    total_size += 3;
  }

  // bool is_kicking = 25;
  if (this->_internal_is_kicking() != 0) {
    total_size += 3;
  }

  // bool is_tackling = 29;
  if (this->_internal_is_tackling() != 0) {
    total_size += 3;
  }

  // float dist_from_ball = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    total_size += 6;
  }

  // float angle_from_ball = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    total_size += 6;
  }

  // int32 ball_reach_steps = 28;
  if (this->_internal_ball_reach_steps() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ball_reach_steps());
  }

  // int32 type_id = 30;
  if (this->_internal_type_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_type_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Player::GetClassData() const { return &_class_data_; }


void Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Player*>(&to_msg);
  auto& from = static_cast<const Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Player)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = from._internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    _this->_internal_set_dist_from_self(from._internal_dist_from_self());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = from._internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    _this->_internal_set_angle_from_self(from._internal_angle_from_self());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_uniform_number_count() != 0) {
    _this->_internal_set_uniform_number_count(from._internal_uniform_number_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  if (from._internal_body_direction_count() != 0) {
    _this->_internal_set_body_direction_count(from._internal_body_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = from._internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    _this->_internal_set_face_direction(from._internal_face_direction());
  }
  if (from._internal_face_direction_count() != 0) {
    _this->_internal_set_face_direction_count(from._internal_face_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = from._internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    _this->_internal_set_point_to_direction(from._internal_point_to_direction());
  }
  if (from._internal_point_to_direction_count() != 0) {
    _this->_internal_set_point_to_direction_count(from._internal_point_to_direction_count());
  }
  if (from._internal_is_goalie() != 0) {
    _this->_internal_set_is_goalie(from._internal_is_goalie());
  }
  if (from._internal_is_kicking() != 0) {
    _this->_internal_set_is_kicking(from._internal_is_kicking());
  }
  if (from._internal_is_tackling() != 0) {
    _this->_internal_set_is_tackling(from._internal_is_tackling());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = from._internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    _this->_internal_set_dist_from_ball(from._internal_dist_from_ball());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = from._internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    _this->_internal_set_angle_from_ball(from._internal_angle_from_ball());
  }
  if (from._internal_ball_reach_steps() != 0) {
    _this->_internal_set_ball_reach_steps(from._internal_ball_reach_steps());
  }
  if (from._internal_type_id() != 0) {
    _this->_internal_set_type_id(from._internal_type_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  return true;
}

void Player::InternalSwap(Player* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Player, _impl_.type_id_)
      + sizeof(Player::_impl_.type_id_)
      - PROTOBUF_FIELD_OFFSET(Player, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[2]);
}
// ===================================================================

class Self::_Internal {
 public:
  using HasBits = decltype(std::declval<Self>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Self, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Self* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& seen_position(const Self* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& heard_position(const Self* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& velocity(const Self* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& seen_velocity(const Self* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::protos::Vector2D&
Self::_Internal::position(const Self* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Self::_Internal::seen_position(const Self* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Self::_Internal::heard_position(const Self* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Self::_Internal::velocity(const Self* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Self::_Internal::seen_velocity(const Self* msg) {
  return *msg->_impl_.seen_velocity_;
}
Self::Self(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Self)
}
Self::Self(const Self& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Self* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.side_) {}

    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.uniform_number_count_) {}

    , decltype(_impl_.body_direction_) {}

    , decltype(_impl_.body_direction_count_) {}

    , decltype(_impl_.face_direction_) {}

    , decltype(_impl_.face_direction_count_) {}

    , decltype(_impl_.point_to_direction_) {}

    , decltype(_impl_.point_to_direction_count_) {}

    , decltype(_impl_.dist_from_ball_) {}

    , decltype(_impl_.is_goalie_) {}

    , decltype(_impl_.is_kicking_) {}

    , decltype(_impl_.is_tackling_) {}

    , decltype(_impl_.is_kickable_) {}

    , decltype(_impl_.angle_from_ball_) {}

    , decltype(_impl_.ball_reach_steps_) {}

    , decltype(_impl_.relative_neck_direction_) {}

    , decltype(_impl_.stamina_) {}

    , decltype(_impl_.catch_probability_) {}

    , decltype(_impl_.tackle_probability_) {}

    , decltype(_impl_.foul_probability_) {}

    , decltype(_impl_.view_width_) {}

    , decltype(_impl_.type_id_) {}

    , decltype(_impl_.kick_rate_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.kick_rate_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.kick_rate_));
  // @@protoc_insertion_point(copy_constructor:protos.Self)
}

inline void Self::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.id_) { 0 }

    , decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.uniform_number_count_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

    , decltype(_impl_.body_direction_count_) { 0 }

    , decltype(_impl_.face_direction_) { 0 }

    , decltype(_impl_.face_direction_count_) { 0 }

    , decltype(_impl_.point_to_direction_) { 0 }

    , decltype(_impl_.point_to_direction_count_) { 0 }

    , decltype(_impl_.dist_from_ball_) { 0 }

    , decltype(_impl_.is_goalie_) { false }

    , decltype(_impl_.is_kicking_) { false }

    , decltype(_impl_.is_tackling_) { false }

    , decltype(_impl_.is_kickable_) { false }

    , decltype(_impl_.angle_from_ball_) { 0 }

    , decltype(_impl_.ball_reach_steps_) { 0 }

    , decltype(_impl_.relative_neck_direction_) { 0 }

    , decltype(_impl_.stamina_) { 0 }

    , decltype(_impl_.catch_probability_) { 0 }

    , decltype(_impl_.tackle_probability_) { 0 }

    , decltype(_impl_.foul_probability_) { 0 }

    , decltype(_impl_.view_width_) { 0 }

    , decltype(_impl_.type_id_) { 0 }

    , decltype(_impl_.kick_rate_) { 0 }

  };
}

Self::~Self() {
  // @@protoc_insertion_point(destructor:protos.Self)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Self::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
}

void Self::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Self::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Self)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.kick_rate_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.kick_rate_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Self::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side side = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.uniform_number_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_goalie = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.is_goalie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 body_direction_count = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.body_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float face_direction = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.face_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 face_direction_count = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.face_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float point_to_direction = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.point_to_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_direction_count = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.point_to_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kicking = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.is_kicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_ball = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.dist_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_ball = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.angle_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ball_reach_steps = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.ball_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_tackling = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.is_tackling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_neck_direction = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.relative_neck_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kickable = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _impl_.is_kickable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catch_probability = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 253)) {
          _impl_.catch_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_probability = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 5)) {
          _impl_.tackle_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float foul_probability = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.foul_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ViewWidth view_width = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_view_width(static_cast<::protos::ViewWidth>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 type_id = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_rate = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.kick_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Self::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Self)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_seen_vel_count(), target);
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_ghost_count(), target);
  }

  // int32 id = 12;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_id(), target);
  }

  // .protos.Side side = 13;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        13, this->_internal_side(), target);
  }

  // int32 uniform_number = 14;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_uniform_number(), target);
  }

  // int32 uniform_number_count = 15;
  if (this->_internal_uniform_number_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        15, this->_internal_uniform_number_count(), target);
  }

  // bool is_goalie = 16;
  if (this->_internal_is_goalie() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this->_internal_is_goalie(), target);
  }

  // float body_direction = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_body_direction(), target);
  }

  // int32 body_direction_count = 18;
  if (this->_internal_body_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        18, this->_internal_body_direction_count(), target);
  }

  // float face_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_face_direction(), target);
  }

  // int32 face_direction_count = 20;
  if (this->_internal_face_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_face_direction_count(), target);
  }

  // float point_to_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_point_to_direction(), target);
  }

  // int32 point_to_direction_count = 22;
  if (this->_internal_point_to_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_point_to_direction_count(), target);
  }

  // bool is_kicking = 23;
  if (this->_internal_is_kicking() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        23, this->_internal_is_kicking(), target);
  }

  // float dist_from_ball = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        24, this->_internal_dist_from_ball(), target);
  }

  // float angle_from_ball = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        25, this->_internal_angle_from_ball(), target);
  }

  // int32 ball_reach_steps = 26;
  if (this->_internal_ball_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        26, this->_internal_ball_reach_steps(), target);
  }

  // bool is_tackling = 27;
  if (this->_internal_is_tackling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        27, this->_internal_is_tackling(), target);
  }

  // float relative_neck_direction = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = this->_internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        28, this->_internal_relative_neck_direction(), target);
  }

  // float stamina = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        29, this->_internal_stamina(), target);
  }

  // bool is_kickable = 30;
  if (this->_internal_is_kickable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        30, this->_internal_is_kickable(), target);
  }

  // float catch_probability = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        31, this->_internal_catch_probability(), target);
  }

  // float tackle_probability = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = this->_internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        32, this->_internal_tackle_probability(), target);
  }

  // float foul_probability = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = this->_internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        33, this->_internal_foul_probability(), target);
  }

  // .protos.ViewWidth view_width = 34;
  if (this->_internal_view_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        34, this->_internal_view_width(), target);
  }

  // int32 type_id = 35;
  if (this->_internal_type_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        35, this->_internal_type_id(), target);
  }

  // float kick_rate = 36;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rate = this->_internal_kick_rate();
  ::uint32_t raw_kick_rate;
  memcpy(&raw_kick_rate, &tmp_kick_rate, sizeof(tmp_kick_rate));
  if (raw_kick_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        36, this->_internal_kick_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Self)
  return target;
}

::size_t Self::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Self)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D seen_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

  }
  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // int32 id = 12;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // .protos.Side side = 13;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 14;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 uniform_number_count = 15;
  if (this->_internal_uniform_number_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number_count());
  }

  // float body_direction = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 6;
  }

  // int32 body_direction_count = 18;
  if (this->_internal_body_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_body_direction_count());
  }

  // float face_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    total_size += 6;
  }

  // int32 face_direction_count = 20;
  if (this->_internal_face_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_face_direction_count());
  }

  // float point_to_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    total_size += 6;
  }

  // int32 point_to_direction_count = 22;
  if (this->_internal_point_to_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_direction_count());
  }

  // float dist_from_ball = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    total_size += 6;
  }

  // bool is_goalie = 16;
  if (this->_internal_is_goalie() != 0) {
    total_size += 3;
  }

  // bool is_kicking = 23;
  if (this->_internal_is_kicking() != 0) {
    total_size += 3;
  }

  // bool is_tackling = 27;
  if (this->_internal_is_tackling() != 0) {
    total_size += 3;
  }

  // bool is_kickable = 30;
  if (this->_internal_is_kickable() != 0) {
    total_size += 3;
  }

  // float angle_from_ball = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    total_size += 6;
  }

  // int32 ball_reach_steps = 26;
  if (this->_internal_ball_reach_steps() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ball_reach_steps());
  }

  // float relative_neck_direction = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = this->_internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    total_size += 6;
  }

  // float stamina = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    total_size += 6;
  }

  // float catch_probability = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    total_size += 6;
  }

  // float tackle_probability = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = this->_internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    total_size += 6;
  }

  // float foul_probability = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = this->_internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    total_size += 6;
  }

  // .protos.ViewWidth view_width = 34;
  if (this->_internal_view_width() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_view_width());
  }

  // int32 type_id = 35;
  if (this->_internal_type_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_type_id());
  }

  // float kick_rate = 36;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rate = this->_internal_kick_rate();
  ::uint32_t raw_kick_rate;
  memcpy(&raw_kick_rate, &tmp_kick_rate, sizeof(tmp_kick_rate));
  if (raw_kick_rate != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Self::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Self::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Self::GetClassData() const { return &_class_data_; }


void Self::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Self*>(&to_msg);
  auto& from = static_cast<const Self&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Self)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_uniform_number_count() != 0) {
    _this->_internal_set_uniform_number_count(from._internal_uniform_number_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  if (from._internal_body_direction_count() != 0) {
    _this->_internal_set_body_direction_count(from._internal_body_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = from._internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    _this->_internal_set_face_direction(from._internal_face_direction());
  }
  if (from._internal_face_direction_count() != 0) {
    _this->_internal_set_face_direction_count(from._internal_face_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = from._internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    _this->_internal_set_point_to_direction(from._internal_point_to_direction());
  }
  if (from._internal_point_to_direction_count() != 0) {
    _this->_internal_set_point_to_direction_count(from._internal_point_to_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = from._internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    _this->_internal_set_dist_from_ball(from._internal_dist_from_ball());
  }
  if (from._internal_is_goalie() != 0) {
    _this->_internal_set_is_goalie(from._internal_is_goalie());
  }
  if (from._internal_is_kicking() != 0) {
    _this->_internal_set_is_kicking(from._internal_is_kicking());
  }
  if (from._internal_is_tackling() != 0) {
    _this->_internal_set_is_tackling(from._internal_is_tackling());
  }
  if (from._internal_is_kickable() != 0) {
    _this->_internal_set_is_kickable(from._internal_is_kickable());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = from._internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    _this->_internal_set_angle_from_ball(from._internal_angle_from_ball());
  }
  if (from._internal_ball_reach_steps() != 0) {
    _this->_internal_set_ball_reach_steps(from._internal_ball_reach_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = from._internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    _this->_internal_set_relative_neck_direction(from._internal_relative_neck_direction());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = from._internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    _this->_internal_set_stamina(from._internal_stamina());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = from._internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    _this->_internal_set_catch_probability(from._internal_catch_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = from._internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    _this->_internal_set_tackle_probability(from._internal_tackle_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = from._internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    _this->_internal_set_foul_probability(from._internal_foul_probability());
  }
  if (from._internal_view_width() != 0) {
    _this->_internal_set_view_width(from._internal_view_width());
  }
  if (from._internal_type_id() != 0) {
    _this->_internal_set_type_id(from._internal_type_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rate = from._internal_kick_rate();
  ::uint32_t raw_kick_rate;
  memcpy(&raw_kick_rate, &tmp_kick_rate, sizeof(tmp_kick_rate));
  if (raw_kick_rate != 0) {
    _this->_internal_set_kick_rate(from._internal_kick_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Self::CopyFrom(const Self& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Self)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Self::IsInitialized() const {
  return true;
}

void Self::InternalSwap(Self* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Self, _impl_.kick_rate_)
      + sizeof(Self::_impl_.kick_rate_)
      - PROTOBUF_FIELD_OFFSET(Self, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Self::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[3]);
}
// ===================================================================

class InterceptInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<InterceptInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_._has_bits_);
  static const ::protos::Vector2D& final_self_position(const InterceptInfo* msg);
  static void set_has_final_self_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
InterceptInfo::_Internal::final_self_position(const InterceptInfo* msg) {
  return *msg->_impl_.final_self_position_;
}
InterceptInfo::InterceptInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptInfo)
}
InterceptInfo::InterceptInfo(const InterceptInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterceptInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.final_self_position_){nullptr}
    , decltype(_impl_.action_type_) {}

    , decltype(_impl_.turn_steps_) {}

    , decltype(_impl_.turn_angle_) {}

    , decltype(_impl_.dash_steps_) {}

    , decltype(_impl_.dash_power_) {}

    , decltype(_impl_.dash_dir_) {}

    , decltype(_impl_.final_ball_dist_) {}

    , decltype(_impl_.final_stamina_) {}

    , decltype(_impl_.value_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.final_self_position_ = new ::protos::Vector2D(*from._impl_.final_self_position_);
  }
  ::memcpy(&_impl_.action_type_, &from._impl_.action_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:protos.InterceptInfo)
}

inline void InterceptInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.final_self_position_){nullptr}
    , decltype(_impl_.action_type_) { 0 }

    , decltype(_impl_.turn_steps_) { 0 }

    , decltype(_impl_.turn_angle_) { 0 }

    , decltype(_impl_.dash_steps_) { 0 }

    , decltype(_impl_.dash_power_) { 0 }

    , decltype(_impl_.dash_dir_) { 0 }

    , decltype(_impl_.final_ball_dist_) { 0 }

    , decltype(_impl_.final_stamina_) { 0 }

    , decltype(_impl_.value_) { 0 }

  };
}

InterceptInfo::~InterceptInfo() {
  // @@protoc_insertion_point(destructor:protos.InterceptInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.final_self_position_;
}

void InterceptInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.final_self_position_ != nullptr);
    _impl_.final_self_position_->Clear();
  }
  ::memset(&_impl_.action_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.value_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.InterceptActionType action_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_action_type(static_cast<::protos::InterceptActionType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 turn_steps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.turn_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float turn_angle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.turn_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 dash_steps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.dash_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_dir = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.dash_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D final_self_position = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_final_self_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float final_ball_dist = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.final_ball_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float final_stamina = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.final_stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float value = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.InterceptActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_action_type(), target);
  }

  // int32 turn_steps = 2;
  if (this->_internal_turn_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_turn_steps(), target);
  }

  // float turn_angle = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = this->_internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_turn_angle(), target);
  }

  // int32 dash_steps = 4;
  if (this->_internal_dash_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_dash_steps(), target);
  }

  // float dash_power = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_dash_power(), target);
  }

  // float dash_dir = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = this->_internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_dash_dir(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D final_self_position = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::final_self_position(this),
        _Internal::final_self_position(this).GetCachedSize(), target, stream);
  }

  // float final_ball_dist = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = this->_internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_final_ball_dist(), target);
  }

  // float final_stamina = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = this->_internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_final_stamina(), target);
  }

  // float value = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptInfo)
  return target;
}

::size_t InterceptInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D final_self_position = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.final_self_position_);
  }

  // .protos.InterceptActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_action_type());
  }

  // int32 turn_steps = 2;
  if (this->_internal_turn_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_turn_steps());
  }

  // float turn_angle = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = this->_internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    total_size += 5;
  }

  // int32 dash_steps = 4;
  if (this->_internal_dash_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_dash_steps());
  }

  // float dash_power = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    total_size += 5;
  }

  // float dash_dir = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = this->_internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    total_size += 5;
  }

  // float final_ball_dist = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = this->_internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    total_size += 5;
  }

  // float final_stamina = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = this->_internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    total_size += 5;
  }

  // float value = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptInfo::GetClassData() const { return &_class_data_; }


void InterceptInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptInfo*>(&to_msg);
  auto& from = static_cast<const InterceptInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_final_self_position()->::protos::Vector2D::MergeFrom(
        from._internal_final_self_position());
  }
  if (from._internal_action_type() != 0) {
    _this->_internal_set_action_type(from._internal_action_type());
  }
  if (from._internal_turn_steps() != 0) {
    _this->_internal_set_turn_steps(from._internal_turn_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = from._internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    _this->_internal_set_turn_angle(from._internal_turn_angle());
  }
  if (from._internal_dash_steps() != 0) {
    _this->_internal_set_dash_steps(from._internal_dash_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = from._internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    _this->_internal_set_dash_power(from._internal_dash_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = from._internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    _this->_internal_set_dash_dir(from._internal_dash_dir());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = from._internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    _this->_internal_set_final_ball_dist(from._internal_final_ball_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = from._internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    _this->_internal_set_final_stamina(from._internal_final_stamina());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptInfo::CopyFrom(const InterceptInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptInfo::IsInitialized() const {
  return true;
}

void InterceptInfo::InternalSwap(InterceptInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_.value_)
      + sizeof(InterceptInfo::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_.final_self_position_)>(
          reinterpret_cast<char*>(&_impl_.final_self_position_),
          reinterpret_cast<char*>(&other->_impl_.final_self_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[4]);
}
// ===================================================================

class InterceptTable::_Internal {
 public:
};

InterceptTable::InterceptTable(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptTable)
}
InterceptTable::InterceptTable(const InterceptTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterceptTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.self_intercept_info_){from._impl_.self_intercept_info_}
    , decltype(_impl_.self_reach_steps_) {}

    , decltype(_impl_.first_teammate_reach_steps_) {}

    , decltype(_impl_.second_teammate_reach_steps_) {}

    , decltype(_impl_.first_opponent_reach_steps_) {}

    , decltype(_impl_.second_opponent_reach_steps_) {}

    , decltype(_impl_.first_teammate_id_) {}

    , decltype(_impl_.second_teammate_id_) {}

    , decltype(_impl_.first_opponent_id_) {}

    , decltype(_impl_.second_opponent_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.self_reach_steps_, &from._impl_.self_reach_steps_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.second_opponent_id_) -
    reinterpret_cast<char*>(&_impl_.self_reach_steps_)) + sizeof(_impl_.second_opponent_id_));
  // @@protoc_insertion_point(copy_constructor:protos.InterceptTable)
}

inline void InterceptTable::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.self_intercept_info_){arena}
    , decltype(_impl_.self_reach_steps_) { 0 }

    , decltype(_impl_.first_teammate_reach_steps_) { 0 }

    , decltype(_impl_.second_teammate_reach_steps_) { 0 }

    , decltype(_impl_.first_opponent_reach_steps_) { 0 }

    , decltype(_impl_.second_opponent_reach_steps_) { 0 }

    , decltype(_impl_.first_teammate_id_) { 0 }

    , decltype(_impl_.second_teammate_id_) { 0 }

    , decltype(_impl_.first_opponent_id_) { 0 }

    , decltype(_impl_.second_opponent_id_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InterceptTable::~InterceptTable() {
  // @@protoc_insertion_point(destructor:protos.InterceptTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptTable::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_self_intercept_info()->~RepeatedPtrField();
}

void InterceptTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptTable::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptTable)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_self_intercept_info()->Clear();
  ::memset(&_impl_.self_reach_steps_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.second_opponent_id_) -
      reinterpret_cast<char*>(&_impl_.self_reach_steps_)) + sizeof(_impl_.second_opponent_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 self_reach_steps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.self_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_teammate_reach_steps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.first_teammate_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_teammate_reach_steps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.second_teammate_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_opponent_reach_steps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.first_opponent_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_opponent_reach_steps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.second_opponent_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_teammate_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.first_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_teammate_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.second_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_opponent_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.first_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_opponent_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.second_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.InterceptInfo self_intercept_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_self_intercept_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptTable::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptTable)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 self_reach_steps = 1;
  if (this->_internal_self_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_self_reach_steps(), target);
  }

  // int32 first_teammate_reach_steps = 2;
  if (this->_internal_first_teammate_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_first_teammate_reach_steps(), target);
  }

  // int32 second_teammate_reach_steps = 3;
  if (this->_internal_second_teammate_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_second_teammate_reach_steps(), target);
  }

  // int32 first_opponent_reach_steps = 4;
  if (this->_internal_first_opponent_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_first_opponent_reach_steps(), target);
  }

  // int32 second_opponent_reach_steps = 5;
  if (this->_internal_second_opponent_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_second_opponent_reach_steps(), target);
  }

  // int32 first_teammate_id = 6;
  if (this->_internal_first_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_first_teammate_id(), target);
  }

  // int32 second_teammate_id = 7;
  if (this->_internal_second_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_second_teammate_id(), target);
  }

  // int32 first_opponent_id = 8;
  if (this->_internal_first_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_first_opponent_id(), target);
  }

  // int32 second_opponent_id = 9;
  if (this->_internal_second_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_second_opponent_id(), target);
  }

  // repeated .protos.InterceptInfo self_intercept_info = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_self_intercept_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_self_intercept_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptTable)
  return target;
}

::size_t InterceptTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptTable)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.InterceptInfo self_intercept_info = 10;
  total_size += 1UL * this->_internal_self_intercept_info_size();
  for (const auto& msg : this->_internal_self_intercept_info()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 self_reach_steps = 1;
  if (this->_internal_self_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_self_reach_steps());
  }

  // int32 first_teammate_reach_steps = 2;
  if (this->_internal_first_teammate_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_teammate_reach_steps());
  }

  // int32 second_teammate_reach_steps = 3;
  if (this->_internal_second_teammate_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_teammate_reach_steps());
  }

  // int32 first_opponent_reach_steps = 4;
  if (this->_internal_first_opponent_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_opponent_reach_steps());
  }

  // int32 second_opponent_reach_steps = 5;
  if (this->_internal_second_opponent_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_opponent_reach_steps());
  }

  // int32 first_teammate_id = 6;
  if (this->_internal_first_teammate_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_teammate_id());
  }

  // int32 second_teammate_id = 7;
  if (this->_internal_second_teammate_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_teammate_id());
  }

  // int32 first_opponent_id = 8;
  if (this->_internal_first_opponent_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_opponent_id());
  }

  // int32 second_opponent_id = 9;
  if (this->_internal_second_opponent_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_opponent_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptTable::GetClassData() const { return &_class_data_; }


void InterceptTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptTable*>(&to_msg);
  auto& from = static_cast<const InterceptTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptTable)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_self_intercept_info()->MergeFrom(from._internal_self_intercept_info());
  if (from._internal_self_reach_steps() != 0) {
    _this->_internal_set_self_reach_steps(from._internal_self_reach_steps());
  }
  if (from._internal_first_teammate_reach_steps() != 0) {
    _this->_internal_set_first_teammate_reach_steps(from._internal_first_teammate_reach_steps());
  }
  if (from._internal_second_teammate_reach_steps() != 0) {
    _this->_internal_set_second_teammate_reach_steps(from._internal_second_teammate_reach_steps());
  }
  if (from._internal_first_opponent_reach_steps() != 0) {
    _this->_internal_set_first_opponent_reach_steps(from._internal_first_opponent_reach_steps());
  }
  if (from._internal_second_opponent_reach_steps() != 0) {
    _this->_internal_set_second_opponent_reach_steps(from._internal_second_opponent_reach_steps());
  }
  if (from._internal_first_teammate_id() != 0) {
    _this->_internal_set_first_teammate_id(from._internal_first_teammate_id());
  }
  if (from._internal_second_teammate_id() != 0) {
    _this->_internal_set_second_teammate_id(from._internal_second_teammate_id());
  }
  if (from._internal_first_opponent_id() != 0) {
    _this->_internal_set_first_opponent_id(from._internal_first_opponent_id());
  }
  if (from._internal_second_opponent_id() != 0) {
    _this->_internal_set_second_opponent_id(from._internal_second_opponent_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptTable::CopyFrom(const InterceptTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptTable::IsInitialized() const {
  return true;
}

void InterceptTable::InternalSwap(InterceptTable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_self_intercept_info()->InternalSwap(other->_internal_mutable_self_intercept_info());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptTable, _impl_.second_opponent_id_)
      + sizeof(InterceptTable::_impl_.second_opponent_id_)
      - PROTOBUF_FIELD_OFFSET(InterceptTable, _impl_.self_reach_steps_)>(
          reinterpret_cast<char*>(&_impl_.self_reach_steps_),
          reinterpret_cast<char*>(&other->_impl_.self_reach_steps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[5]);
}
// ===================================================================

WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse() {}
WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WorldModel_OurPlayersDictEntry_DoNotUse::MergeFrom(const WorldModel_OurPlayersDictEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WorldModel_OurPlayersDictEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[6]);
}
// ===================================================================

WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse() {}
WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WorldModel_TheirPlayersDictEntry_DoNotUse::MergeFrom(const WorldModel_TheirPlayersDictEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WorldModel_TheirPlayersDictEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[7]);
}
// ===================================================================

WorldModel_HeliosHomePositionsEntry_DoNotUse::WorldModel_HeliosHomePositionsEntry_DoNotUse() {}
WorldModel_HeliosHomePositionsEntry_DoNotUse::WorldModel_HeliosHomePositionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WorldModel_HeliosHomePositionsEntry_DoNotUse::MergeFrom(const WorldModel_HeliosHomePositionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WorldModel_HeliosHomePositionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[8]);
}
// ===================================================================

class WorldModel::_Internal {
 public:
  using HasBits = decltype(std::declval<WorldModel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WorldModel, _impl_._has_bits_);
  static const ::protos::InterceptTable& intercept_table(const WorldModel* msg);
  static void set_has_intercept_table(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Self& self(const WorldModel* msg);
  static void set_has_self(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Ball& ball(const WorldModel* msg);
  static void set_has_ball(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::InterceptTable&
WorldModel::_Internal::intercept_table(const WorldModel* msg) {
  return *msg->_impl_.intercept_table_;
}
const ::protos::Self&
WorldModel::_Internal::self(const WorldModel* msg) {
  return *msg->_impl_.self_;
}
const ::protos::Ball&
WorldModel::_Internal::ball(const WorldModel* msg) {
  return *msg->_impl_.ball_;
}
WorldModel::WorldModel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.WorldModel)
}
WorldModel::WorldModel(const WorldModel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WorldModel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teammates_){from._impl_.teammates_}
    , decltype(_impl_.opponents_){from._impl_.opponents_}
    , decltype(_impl_.unknowns_){from._impl_.unknowns_}
    , /*decltype(_impl_.our_players_dict_)*/{}
    , /*decltype(_impl_.their_players_dict_)*/{}
    , /*decltype(_impl_.helios_home_positions_)*/{}
    , decltype(_impl_.our_team_name_) {}

    , decltype(_impl_.their_team_name_) {}

    , decltype(_impl_.intercept_table_){nullptr}
    , decltype(_impl_.self_){nullptr}
    , decltype(_impl_.ball_){nullptr}
    , decltype(_impl_.our_side_) {}

    , decltype(_impl_.last_set_play_start_time_) {}

    , decltype(_impl_.our_goalie_uniform_number_) {}

    , decltype(_impl_.their_goalie_uniform_number_) {}

    , decltype(_impl_.offside_line_x_) {}

    , decltype(_impl_.ofside_line_x_count_) {}

    , decltype(_impl_.kickable_teammate_id_) {}

    , decltype(_impl_.kickable_opponent_id_) {}

    , decltype(_impl_.last_kick_side_) {}

    , decltype(_impl_.last_kicker_uniform_number_) {}

    , decltype(_impl_.cycle_) {}

    , decltype(_impl_.game_mode_type_) {}

    , decltype(_impl_.left_team_score_) {}

    , decltype(_impl_.right_team_score_) {}

    , decltype(_impl_.stoped_cycle_) {}

    , decltype(_impl_.is_our_set_play_) {}

    , decltype(_impl_.is_their_set_play_) {}

    , decltype(_impl_.is_penalty_kick_mode_) {}

    , decltype(_impl_.our_team_score_) {}

    , decltype(_impl_.their_team_score_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.our_players_dict_.MergeFrom(from._impl_.our_players_dict_);
  _this->_impl_.their_players_dict_.MergeFrom(from._impl_.their_players_dict_);
  _this->_impl_.helios_home_positions_.MergeFrom(from._impl_.helios_home_positions_);
  _impl_.our_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.our_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_our_team_name().empty()) {
    _this->_impl_.our_team_name_.Set(from._internal_our_team_name(), _this->GetArenaForAllocation());
  }
  _impl_.their_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.their_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_their_team_name().empty()) {
    _this->_impl_.their_team_name_.Set(from._internal_their_team_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.intercept_table_ = new ::protos::InterceptTable(*from._impl_.intercept_table_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.self_ = new ::protos::Self(*from._impl_.self_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.ball_ = new ::protos::Ball(*from._impl_.ball_);
  }
  ::memcpy(&_impl_.our_side_, &from._impl_.our_side_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.their_team_score_) -
    reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.their_team_score_));
  // @@protoc_insertion_point(copy_constructor:protos.WorldModel)
}

inline void WorldModel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teammates_){arena}
    , decltype(_impl_.opponents_){arena}
    , decltype(_impl_.unknowns_){arena}
    , /*decltype(_impl_.our_players_dict_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.their_players_dict_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.helios_home_positions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.our_team_name_) {}

    , decltype(_impl_.their_team_name_) {}

    , decltype(_impl_.intercept_table_){nullptr}
    , decltype(_impl_.self_){nullptr}
    , decltype(_impl_.ball_){nullptr}
    , decltype(_impl_.our_side_) { 0 }

    , decltype(_impl_.last_set_play_start_time_) { 0 }

    , decltype(_impl_.our_goalie_uniform_number_) { 0 }

    , decltype(_impl_.their_goalie_uniform_number_) { 0 }

    , decltype(_impl_.offside_line_x_) { 0 }

    , decltype(_impl_.ofside_line_x_count_) { 0 }

    , decltype(_impl_.kickable_teammate_id_) { 0 }

    , decltype(_impl_.kickable_opponent_id_) { 0 }

    , decltype(_impl_.last_kick_side_) { 0 }

    , decltype(_impl_.last_kicker_uniform_number_) { 0 }

    , decltype(_impl_.cycle_) { 0 }

    , decltype(_impl_.game_mode_type_) { 0 }

    , decltype(_impl_.left_team_score_) { 0 }

    , decltype(_impl_.right_team_score_) { 0 }

    , decltype(_impl_.stoped_cycle_) { 0 }

    , decltype(_impl_.is_our_set_play_) { false }

    , decltype(_impl_.is_their_set_play_) { false }

    , decltype(_impl_.is_penalty_kick_mode_) { false }

    , decltype(_impl_.our_team_score_) { 0 }

    , decltype(_impl_.their_team_score_) { 0 }

  };
  _impl_.our_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.our_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.their_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.their_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WorldModel::~WorldModel() {
  // @@protoc_insertion_point(destructor:protos.WorldModel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WorldModel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_teammates()->~RepeatedPtrField();
  _internal_mutable_opponents()->~RepeatedPtrField();
  _internal_mutable_unknowns()->~RepeatedPtrField();
  _impl_.our_players_dict_.~MapField();
  _impl_.their_players_dict_.~MapField();
  _impl_.helios_home_positions_.~MapField();
  _impl_.our_team_name_.Destroy();
  _impl_.their_team_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.intercept_table_;
  if (this != internal_default_instance()) delete _impl_.self_;
  if (this != internal_default_instance()) delete _impl_.ball_;
}

void WorldModel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WorldModel::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.WorldModel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_teammates()->Clear();
  _internal_mutable_opponents()->Clear();
  _internal_mutable_unknowns()->Clear();
  _impl_.our_players_dict_.Clear();
  _impl_.their_players_dict_.Clear();
  _impl_.helios_home_positions_.Clear();
  _impl_.our_team_name_.ClearToEmpty();
  _impl_.their_team_name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.intercept_table_ != nullptr);
      _impl_.intercept_table_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.self_ != nullptr);
      _impl_.self_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.ball_ != nullptr);
      _impl_.ball_->Clear();
    }
  }
  ::memset(&_impl_.our_side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.their_team_score_) -
      reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.their_team_score_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WorldModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.InterceptTable intercept_table = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_intercept_table(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string our_team_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_our_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.WorldModel.our_team_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string their_team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_their_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.WorldModel.their_team_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side our_side = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_our_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 last_set_play_start_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.last_set_play_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Self self = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_self(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Ball ball = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player teammates = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_teammates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player opponents = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_opponents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player unknowns = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_unknowns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .protos.Player> our_players_dict = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.our_players_dict_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .protos.Player> their_players_dict = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.their_players_dict_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 our_goalie_uniform_number = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.our_goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 their_goalie_uniform_number = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.their_goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float offside_line_x = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _impl_.offside_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ofside_line_x_count = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.ofside_line_x_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 kickable_teammate_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.kickable_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 kickable_opponent_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.kickable_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side last_kick_side = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_last_kick_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 last_kicker_uniform_number = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.last_kicker_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 cycle = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.GameModeType game_mode_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_game_mode_type(static_cast<::protos::GameModeType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 left_team_score = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.left_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 right_team_score = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.right_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_our_set_play = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.is_our_set_play_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_their_set_play = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.is_their_set_play_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 stoped_cycle = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.stoped_cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 our_team_score = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.our_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 their_team_score = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.their_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_penalty_kick_mode = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _impl_.is_penalty_kick_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .protos.Vector2D> helios_home_positions = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&_impl_.helios_home_positions_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<250>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WorldModel::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.WorldModel)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.InterceptTable intercept_table = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::intercept_table(this),
        _Internal::intercept_table(this).GetCachedSize(), target, stream);
  }

  // string our_team_name = 2;
  if (!this->_internal_our_team_name().empty()) {
    const std::string& _s = this->_internal_our_team_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.WorldModel.our_team_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string their_team_name = 3;
  if (!this->_internal_their_team_name().empty()) {
    const std::string& _s = this->_internal_their_team_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.WorldModel.their_team_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .protos.Side our_side = 4;
  if (this->_internal_our_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_our_side(), target);
  }

  // int32 last_set_play_start_time = 5;
  if (this->_internal_last_set_play_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_last_set_play_start_time(), target);
  }

  // .protos.Self self = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::self(this),
        _Internal::self(this).GetCachedSize(), target, stream);
  }

  // .protos.Ball ball = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::ball(this),
        _Internal::ball(this).GetCachedSize(), target, stream);
  }

  // repeated .protos.Player teammates = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_teammates_size()); i < n; i++) {
    const auto& repfield = this->_internal_teammates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protos.Player opponents = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_opponents_size()); i < n; i++) {
    const auto& repfield = this->_internal_opponents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protos.Player unknowns = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unknowns_size()); i < n; i++) {
    const auto& repfield = this->_internal_unknowns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<int32, .protos.Player> our_players_dict = 11;
  if (!this->_internal_our_players_dict().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::protos::Player>;
    using WireHelper = WorldModel_OurPlayersDictEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_our_players_dict();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
      }
    }
  }

  // map<int32, .protos.Player> their_players_dict = 12;
  if (!this->_internal_their_players_dict().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::protos::Player>;
    using WireHelper = WorldModel_TheirPlayersDictEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_their_players_dict();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
      }
    }
  }

  // int32 our_goalie_uniform_number = 13;
  if (this->_internal_our_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_our_goalie_uniform_number(), target);
  }

  // int32 their_goalie_uniform_number = 14;
  if (this->_internal_their_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_their_goalie_uniform_number(), target);
  }

  // float offside_line_x = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_offside_line_x(), target);
  }

  // int32 ofside_line_x_count = 16;
  if (this->_internal_ofside_line_x_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_ofside_line_x_count(), target);
  }

  // int32 kickable_teammate_id = 17;
  if (this->_internal_kickable_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_kickable_teammate_id(), target);
  }

  // int32 kickable_opponent_id = 18;
  if (this->_internal_kickable_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        18, this->_internal_kickable_opponent_id(), target);
  }

  // .protos.Side last_kick_side = 19;
  if (this->_internal_last_kick_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        19, this->_internal_last_kick_side(), target);
  }

  // int32 last_kicker_uniform_number = 20;
  if (this->_internal_last_kicker_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_last_kicker_uniform_number(), target);
  }

  // int32 cycle = 21;
  if (this->_internal_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        21, this->_internal_cycle(), target);
  }

  // .protos.GameModeType game_mode_type = 22;
  if (this->_internal_game_mode_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        22, this->_internal_game_mode_type(), target);
  }

  // int32 left_team_score = 23;
  if (this->_internal_left_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        23, this->_internal_left_team_score(), target);
  }

  // int32 right_team_score = 24;
  if (this->_internal_right_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_right_team_score(), target);
  }

  // bool is_our_set_play = 25;
  if (this->_internal_is_our_set_play() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_is_our_set_play(), target);
  }

  // bool is_their_set_play = 26;
  if (this->_internal_is_their_set_play() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        26, this->_internal_is_their_set_play(), target);
  }

  // int32 stoped_cycle = 27;
  if (this->_internal_stoped_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        27, this->_internal_stoped_cycle(), target);
  }

  // int32 our_team_score = 28;
  if (this->_internal_our_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        28, this->_internal_our_team_score(), target);
  }

  // int32 their_team_score = 29;
  if (this->_internal_their_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        29, this->_internal_their_team_score(), target);
  }

  // bool is_penalty_kick_mode = 30;
  if (this->_internal_is_penalty_kick_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        30, this->_internal_is_penalty_kick_mode(), target);
  }

  // map<int32, .protos.Vector2D> helios_home_positions = 31;
  if (!this->_internal_helios_home_positions().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::protos::Vector2D>;
    using WireHelper = WorldModel_HeliosHomePositionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_helios_home_positions();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(31, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(31, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.WorldModel)
  return target;
}

::size_t WorldModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.WorldModel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.Player teammates = 8;
  total_size += 1UL * this->_internal_teammates_size();
  for (const auto& msg : this->_internal_teammates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protos.Player opponents = 9;
  total_size += 1UL * this->_internal_opponents_size();
  for (const auto& msg : this->_internal_opponents()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protos.Player unknowns = 10;
  total_size += 1UL * this->_internal_unknowns_size();
  for (const auto& msg : this->_internal_unknowns()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<int32, .protos.Player> our_players_dict = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_our_players_dict_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >::const_iterator
      it = this->_internal_our_players_dict().begin();
      it != this->_internal_our_players_dict().end(); ++it) {
    total_size += WorldModel_OurPlayersDictEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<int32, .protos.Player> their_players_dict = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_their_players_dict_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >::const_iterator
      it = this->_internal_their_players_dict().begin();
      it != this->_internal_their_players_dict().end(); ++it) {
    total_size += WorldModel_TheirPlayersDictEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<int32, .protos.Vector2D> helios_home_positions = 31;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_helios_home_positions_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Vector2D >::const_iterator
      it = this->_internal_helios_home_positions().begin();
      it != this->_internal_helios_home_positions().end(); ++it) {
    total_size += WorldModel_HeliosHomePositionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string our_team_name = 2;
  if (!this->_internal_our_team_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_our_team_name());
  }

  // string their_team_name = 3;
  if (!this->_internal_their_team_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_their_team_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.InterceptTable intercept_table = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.intercept_table_);
    }

    // .protos.Self self = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.self_);
    }

    // .protos.Ball ball = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_);
    }

  }
  // .protos.Side our_side = 4;
  if (this->_internal_our_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_our_side());
  }

  // int32 last_set_play_start_time = 5;
  if (this->_internal_last_set_play_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_last_set_play_start_time());
  }

  // int32 our_goalie_uniform_number = 13;
  if (this->_internal_our_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_our_goalie_uniform_number());
  }

  // int32 their_goalie_uniform_number = 14;
  if (this->_internal_their_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_their_goalie_uniform_number());
  }

  // float offside_line_x = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    total_size += 5;
  }

  // int32 ofside_line_x_count = 16;
  if (this->_internal_ofside_line_x_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ofside_line_x_count());
  }

  // int32 kickable_teammate_id = 17;
  if (this->_internal_kickable_teammate_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_kickable_teammate_id());
  }

  // int32 kickable_opponent_id = 18;
  if (this->_internal_kickable_opponent_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_kickable_opponent_id());
  }

  // .protos.Side last_kick_side = 19;
  if (this->_internal_last_kick_side() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_last_kick_side());
  }

  // int32 last_kicker_uniform_number = 20;
  if (this->_internal_last_kicker_uniform_number() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_last_kicker_uniform_number());
  }

  // int32 cycle = 21;
  if (this->_internal_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_cycle());
  }

  // .protos.GameModeType game_mode_type = 22;
  if (this->_internal_game_mode_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode_type());
  }

  // int32 left_team_score = 23;
  if (this->_internal_left_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_left_team_score());
  }

  // int32 right_team_score = 24;
  if (this->_internal_right_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_right_team_score());
  }

  // int32 stoped_cycle = 27;
  if (this->_internal_stoped_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_stoped_cycle());
  }

  // bool is_our_set_play = 25;
  if (this->_internal_is_our_set_play() != 0) {
    total_size += 3;
  }

  // bool is_their_set_play = 26;
  if (this->_internal_is_their_set_play() != 0) {
    total_size += 3;
  }

  // bool is_penalty_kick_mode = 30;
  if (this->_internal_is_penalty_kick_mode() != 0) {
    total_size += 3;
  }

  // int32 our_team_score = 28;
  if (this->_internal_our_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_our_team_score());
  }

  // int32 their_team_score = 29;
  if (this->_internal_their_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_their_team_score());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WorldModel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WorldModel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WorldModel::GetClassData() const { return &_class_data_; }


void WorldModel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WorldModel*>(&to_msg);
  auto& from = static_cast<const WorldModel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.WorldModel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_teammates()->MergeFrom(from._internal_teammates());
  _this->_internal_mutable_opponents()->MergeFrom(from._internal_opponents());
  _this->_internal_mutable_unknowns()->MergeFrom(from._internal_unknowns());
  _this->_impl_.our_players_dict_.MergeFrom(from._impl_.our_players_dict_);
  _this->_impl_.their_players_dict_.MergeFrom(from._impl_.their_players_dict_);
  _this->_impl_.helios_home_positions_.MergeFrom(from._impl_.helios_home_positions_);
  if (!from._internal_our_team_name().empty()) {
    _this->_internal_set_our_team_name(from._internal_our_team_name());
  }
  if (!from._internal_their_team_name().empty()) {
    _this->_internal_set_their_team_name(from._internal_their_team_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_intercept_table()->::protos::InterceptTable::MergeFrom(
          from._internal_intercept_table());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_self()->::protos::Self::MergeFrom(
          from._internal_self());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ball()->::protos::Ball::MergeFrom(
          from._internal_ball());
    }
  }
  if (from._internal_our_side() != 0) {
    _this->_internal_set_our_side(from._internal_our_side());
  }
  if (from._internal_last_set_play_start_time() != 0) {
    _this->_internal_set_last_set_play_start_time(from._internal_last_set_play_start_time());
  }
  if (from._internal_our_goalie_uniform_number() != 0) {
    _this->_internal_set_our_goalie_uniform_number(from._internal_our_goalie_uniform_number());
  }
  if (from._internal_their_goalie_uniform_number() != 0) {
    _this->_internal_set_their_goalie_uniform_number(from._internal_their_goalie_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = from._internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    _this->_internal_set_offside_line_x(from._internal_offside_line_x());
  }
  if (from._internal_ofside_line_x_count() != 0) {
    _this->_internal_set_ofside_line_x_count(from._internal_ofside_line_x_count());
  }
  if (from._internal_kickable_teammate_id() != 0) {
    _this->_internal_set_kickable_teammate_id(from._internal_kickable_teammate_id());
  }
  if (from._internal_kickable_opponent_id() != 0) {
    _this->_internal_set_kickable_opponent_id(from._internal_kickable_opponent_id());
  }
  if (from._internal_last_kick_side() != 0) {
    _this->_internal_set_last_kick_side(from._internal_last_kick_side());
  }
  if (from._internal_last_kicker_uniform_number() != 0) {
    _this->_internal_set_last_kicker_uniform_number(from._internal_last_kicker_uniform_number());
  }
  if (from._internal_cycle() != 0) {
    _this->_internal_set_cycle(from._internal_cycle());
  }
  if (from._internal_game_mode_type() != 0) {
    _this->_internal_set_game_mode_type(from._internal_game_mode_type());
  }
  if (from._internal_left_team_score() != 0) {
    _this->_internal_set_left_team_score(from._internal_left_team_score());
  }
  if (from._internal_right_team_score() != 0) {
    _this->_internal_set_right_team_score(from._internal_right_team_score());
  }
  if (from._internal_stoped_cycle() != 0) {
    _this->_internal_set_stoped_cycle(from._internal_stoped_cycle());
  }
  if (from._internal_is_our_set_play() != 0) {
    _this->_internal_set_is_our_set_play(from._internal_is_our_set_play());
  }
  if (from._internal_is_their_set_play() != 0) {
    _this->_internal_set_is_their_set_play(from._internal_is_their_set_play());
  }
  if (from._internal_is_penalty_kick_mode() != 0) {
    _this->_internal_set_is_penalty_kick_mode(from._internal_is_penalty_kick_mode());
  }
  if (from._internal_our_team_score() != 0) {
    _this->_internal_set_our_team_score(from._internal_our_team_score());
  }
  if (from._internal_their_team_score() != 0) {
    _this->_internal_set_their_team_score(from._internal_their_team_score());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WorldModel::CopyFrom(const WorldModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.WorldModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldModel::IsInitialized() const {
  return true;
}

void WorldModel::InternalSwap(WorldModel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_teammates()->InternalSwap(other->_internal_mutable_teammates());
  _internal_mutable_opponents()->InternalSwap(other->_internal_mutable_opponents());
  _internal_mutable_unknowns()->InternalSwap(other->_internal_mutable_unknowns());
  _impl_.our_players_dict_.InternalSwap(&other->_impl_.our_players_dict_);
  _impl_.their_players_dict_.InternalSwap(&other->_impl_.their_players_dict_);
  _impl_.helios_home_positions_.InternalSwap(&other->_impl_.helios_home_positions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.our_team_name_, lhs_arena,
                                       &other->_impl_.our_team_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.their_team_name_, lhs_arena,
                                       &other->_impl_.their_team_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorldModel, _impl_.their_team_score_)
      + sizeof(WorldModel::_impl_.their_team_score_)
      - PROTOBUF_FIELD_OFFSET(WorldModel, _impl_.intercept_table_)>(
          reinterpret_cast<char*>(&_impl_.intercept_table_),
          reinterpret_cast<char*>(&other->_impl_.intercept_table_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WorldModel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[9]);
}
// ===================================================================

class State::_Internal {
 public:
  using HasBits = decltype(std::declval<State>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(State, _impl_._has_bits_);
  static const ::protos::WorldModel& world_model(const State* msg);
  static void set_has_world_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::WorldModel& full_world_model(const State* msg);
  static void set_has_full_world_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::WorldModel&
State::_Internal::world_model(const State* msg) {
  return *msg->_impl_.world_model_;
}
const ::protos::WorldModel&
State::_Internal::full_world_model(const State* msg) {
  return *msg->_impl_.full_world_model_;
}
State::State(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.State)
}
State::State(const State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  State* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.world_model_){nullptr}
    , decltype(_impl_.full_world_model_){nullptr}
    , decltype(_impl_.agent_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.world_model_ = new ::protos::WorldModel(*from._impl_.world_model_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.full_world_model_ = new ::protos::WorldModel(*from._impl_.full_world_model_);
  }
  _this->_impl_.agent_type_ = from._impl_.agent_type_;
  // @@protoc_insertion_point(copy_constructor:protos.State)
}

inline void State::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.world_model_){nullptr}
    , decltype(_impl_.full_world_model_){nullptr}
    , decltype(_impl_.agent_type_) { 0 }

  };
}

State::~State() {
  // @@protoc_insertion_point(destructor:protos.State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void State::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.world_model_;
  if (this != internal_default_instance()) delete _impl_.full_world_model_;
}

void State::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void State::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.State)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.world_model_ != nullptr);
      _impl_.world_model_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.full_world_model_ != nullptr);
      _impl_.full_world_model_->Clear();
    }
  }
  _impl_.agent_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.AgentType agent_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_agent_type(static_cast<::protos::AgentType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.WorldModel world_model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.WorldModel full_world_model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_full_world_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* State::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.State)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_agent_type(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.WorldModel world_model = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::world_model(this),
        _Internal::world_model(this).GetCachedSize(), target, stream);
  }

  // .protos.WorldModel full_world_model = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::full_world_model(this),
        _Internal::full_world_model(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.State)
  return target;
}

::size_t State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.State)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.WorldModel world_model = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.world_model_);
    }

    // .protos.WorldModel full_world_model = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.full_world_model_);
    }

  }
  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_agent_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*State::GetClassData() const { return &_class_data_; }


void State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<State*>(&to_msg);
  auto& from = static_cast<const State&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.State)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_world_model()->::protos::WorldModel::MergeFrom(
          from._internal_world_model());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_full_world_model()->::protos::WorldModel::MergeFrom(
          from._internal_full_world_model());
    }
  }
  if (from._internal_agent_type() != 0) {
    _this->_internal_set_agent_type(from._internal_agent_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void State::CopyFrom(const State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  return true;
}

void State::InternalSwap(State* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(State, _impl_.agent_type_)
      + sizeof(State::_impl_.agent_type_)
      - PROTOBUF_FIELD_OFFSET(State, _impl_.world_model_)>(
          reinterpret_cast<char*>(&_impl_.world_model_),
          reinterpret_cast<char*>(&other->_impl_.world_model_));
}

::PROTOBUF_NAMESPACE_ID::Metadata State::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[10]);
}
// ===================================================================

class InitMessage::_Internal {
 public:
};

InitMessage::InitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InitMessage)
}
InitMessage::InitMessage(const InitMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.InitMessage)
}

inline void InitMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.agent_type_) { 0 }

    , decltype(_impl_.debug_mode_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InitMessage::~InitMessage() {
  // @@protoc_insertion_point(destructor:protos.InitMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InitMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void InitMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InitMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InitMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.agent_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.debug_mode_) -
      reinterpret_cast<char*>(&_impl_.agent_type_)) + sizeof(_impl_.debug_mode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.AgentType agent_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_agent_type(static_cast<::protos::AgentType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool debug_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.debug_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InitMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InitMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_agent_type(), target);
  }

  // bool debug_mode = 2;
  if (this->_internal_debug_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_debug_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InitMessage)
  return target;
}

::size_t InitMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InitMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_agent_type());
  }

  // bool debug_mode = 2;
  if (this->_internal_debug_mode() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InitMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InitMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InitMessage::GetClassData() const { return &_class_data_; }


void InitMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InitMessage*>(&to_msg);
  auto& from = static_cast<const InitMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InitMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_agent_type() != 0) {
    _this->_internal_set_agent_type(from._internal_agent_type());
  }
  if (from._internal_debug_mode() != 0) {
    _this->_internal_set_debug_mode(from._internal_debug_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InitMessage::CopyFrom(const InitMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InitMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitMessage::IsInitialized() const {
  return true;
}

void InitMessage::InternalSwap(InitMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitMessage, _impl_.debug_mode_)
      + sizeof(InitMessage::_impl_.debug_mode_)
      - PROTOBUF_FIELD_OFFSET(InitMessage, _impl_.agent_type_)>(
          reinterpret_cast<char*>(&_impl_.agent_type_),
          reinterpret_cast<char*>(&other->_impl_.agent_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InitMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[11]);
}
// ===================================================================

class Dash::_Internal {
 public:
};

Dash::Dash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Dash)
}
Dash::Dash(const Dash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Dash)
}

inline void Dash::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_) { 0 }

    , decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Dash::~Dash() {
  // @@protoc_insertion_point(destructor:protos.Dash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Dash::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Dash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Dash::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Dash)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.relative_direction_) -
      reinterpret_cast<char*>(&_impl_.power_)) + sizeof(_impl_.relative_direction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Dash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Dash::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Dash)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power(), target);
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Dash)
  return target;
}

::size_t Dash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Dash)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    total_size += 5;
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Dash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Dash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Dash::GetClassData() const { return &_class_data_; }


void Dash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Dash*>(&to_msg);
  auto& from = static_cast<const Dash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Dash)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = from._internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    _this->_internal_set_power(from._internal_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Dash::CopyFrom(const Dash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Dash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dash::IsInitialized() const {
  return true;
}

void Dash::InternalSwap(Dash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Dash, _impl_.relative_direction_)
      + sizeof(Dash::_impl_.relative_direction_)
      - PROTOBUF_FIELD_OFFSET(Dash, _impl_.power_)>(
          reinterpret_cast<char*>(&_impl_.power_),
          reinterpret_cast<char*>(&other->_impl_.power_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Dash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[12]);
}
// ===================================================================

class Turn::_Internal {
 public:
};

Turn::Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Turn)
}
Turn::Turn(const Turn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Turn)
}

inline void Turn::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Turn::~Turn() {
  // @@protoc_insertion_point(destructor:protos.Turn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Turn::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Turn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Turn::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Turn)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.relative_direction_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Turn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float relative_direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Turn::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Turn)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float relative_direction = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Turn)
  return target;
}

::size_t Turn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Turn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float relative_direction = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Turn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Turn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Turn::GetClassData() const { return &_class_data_; }


void Turn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Turn*>(&to_msg);
  auto& from = static_cast<const Turn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Turn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Turn::CopyFrom(const Turn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Turn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Turn::IsInitialized() const {
  return true;
}

void Turn::InternalSwap(Turn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.relative_direction_, other->_impl_.relative_direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Turn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[13]);
}
// ===================================================================

class Kick::_Internal {
 public:
};

Kick::Kick(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Kick)
}
Kick::Kick(const Kick& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Kick)
}

inline void Kick::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_) { 0 }

    , decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Kick::~Kick() {
  // @@protoc_insertion_point(destructor:protos.Kick)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Kick::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Kick::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Kick::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Kick)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.relative_direction_) -
      reinterpret_cast<char*>(&_impl_.power_)) + sizeof(_impl_.relative_direction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Kick::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Kick::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Kick)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power(), target);
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Kick)
  return target;
}

::size_t Kick::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Kick)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    total_size += 5;
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Kick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Kick::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Kick::GetClassData() const { return &_class_data_; }


void Kick::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Kick*>(&to_msg);
  auto& from = static_cast<const Kick&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Kick)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = from._internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    _this->_internal_set_power(from._internal_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Kick::CopyFrom(const Kick& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Kick)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Kick::IsInitialized() const {
  return true;
}

void Kick::InternalSwap(Kick* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Kick, _impl_.relative_direction_)
      + sizeof(Kick::_impl_.relative_direction_)
      - PROTOBUF_FIELD_OFFSET(Kick, _impl_.power_)>(
          reinterpret_cast<char*>(&_impl_.power_),
          reinterpret_cast<char*>(&other->_impl_.power_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Kick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[14]);
}
// ===================================================================

class Tackle::_Internal {
 public:
};

Tackle::Tackle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Tackle)
}
Tackle::Tackle(const Tackle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Tackle)
}

inline void Tackle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_or_dir_) { 0 }

    , decltype(_impl_.foul_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Tackle::~Tackle() {
  // @@protoc_insertion_point(destructor:protos.Tackle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tackle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Tackle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tackle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Tackle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_or_dir_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.foul_) -
      reinterpret_cast<char*>(&_impl_.power_or_dir_)) + sizeof(_impl_.foul_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tackle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power_or_dir = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_or_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool foul = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.foul_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Tackle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Tackle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power_or_dir = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = this->_internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power_or_dir(), target);
  }

  // bool foul = 2;
  if (this->_internal_foul() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_foul(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Tackle)
  return target;
}

::size_t Tackle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Tackle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power_or_dir = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = this->_internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    total_size += 5;
  }

  // bool foul = 2;
  if (this->_internal_foul() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tackle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tackle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tackle::GetClassData() const { return &_class_data_; }


void Tackle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tackle*>(&to_msg);
  auto& from = static_cast<const Tackle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Tackle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = from._internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    _this->_internal_set_power_or_dir(from._internal_power_or_dir());
  }
  if (from._internal_foul() != 0) {
    _this->_internal_set_foul(from._internal_foul());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tackle::CopyFrom(const Tackle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Tackle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tackle::IsInitialized() const {
  return true;
}

void Tackle::InternalSwap(Tackle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tackle, _impl_.foul_)
      + sizeof(Tackle::_impl_.foul_)
      - PROTOBUF_FIELD_OFFSET(Tackle, _impl_.power_or_dir_)>(
          reinterpret_cast<char*>(&_impl_.power_or_dir_),
          reinterpret_cast<char*>(&other->_impl_.power_or_dir_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tackle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[15]);
}
// ===================================================================

class Catch::_Internal {
 public:
};

Catch::Catch(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Catch)
}
Catch::Catch(const Catch& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Catch* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Catch)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Catch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Catch::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Catch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[16]);
}
// ===================================================================

class Move::_Internal {
 public:
};

Move::Move(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Move)
}
Move::Move(const Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Move)
}

inline void Move::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Move::~Move() {
  // @@protoc_insertion_point(destructor:protos.Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Move::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Move::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Move)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Move::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Move)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Move)
  return target;
}

::size_t Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Move)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Move::GetClassData() const { return &_class_data_; }


void Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Move*>(&to_msg);
  auto& from = static_cast<const Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Move)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Move::CopyFrom(const Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Move::IsInitialized() const {
  return true;
}

void Move::InternalSwap(Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Move, _impl_.y_)
      + sizeof(Move::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Move, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[17]);
}
// ===================================================================

class TurnNeck::_Internal {
 public:
};

TurnNeck::TurnNeck(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TurnNeck)
}
TurnNeck::TurnNeck(const TurnNeck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.TurnNeck)
}

inline void TurnNeck::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.moment_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TurnNeck::~TurnNeck() {
  // @@protoc_insertion_point(destructor:protos.TurnNeck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TurnNeck::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void TurnNeck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TurnNeck::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TurnNeck)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.moment_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TurnNeck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float moment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TurnNeck::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TurnNeck)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float moment = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = this->_internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_moment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TurnNeck)
  return target;
}

::size_t TurnNeck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TurnNeck)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float moment = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = this->_internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TurnNeck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TurnNeck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TurnNeck::GetClassData() const { return &_class_data_; }


void TurnNeck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TurnNeck*>(&to_msg);
  auto& from = static_cast<const TurnNeck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TurnNeck)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = from._internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    _this->_internal_set_moment(from._internal_moment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TurnNeck::CopyFrom(const TurnNeck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TurnNeck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TurnNeck::IsInitialized() const {
  return true;
}

void TurnNeck::InternalSwap(TurnNeck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.moment_, other->_impl_.moment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TurnNeck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[18]);
}
// ===================================================================

class ChangeView::_Internal {
 public:
};

ChangeView::ChangeView(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.ChangeView)
}
ChangeView::ChangeView(const ChangeView& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.ChangeView)
}

inline void ChangeView::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.view_width_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ChangeView::~ChangeView() {
  // @@protoc_insertion_point(destructor:protos.ChangeView)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeView::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChangeView::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeView::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.ChangeView)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.view_width_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.ViewWidth view_width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_view_width(static_cast<::protos::ViewWidth>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ChangeView::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.ChangeView)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_view_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.ChangeView)
  return target;
}

::size_t ChangeView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.ChangeView)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_view_width());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeView::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeView::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeView::GetClassData() const { return &_class_data_; }


void ChangeView::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeView*>(&to_msg);
  auto& from = static_cast<const ChangeView&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.ChangeView)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_view_width() != 0) {
    _this->_internal_set_view_width(from._internal_view_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeView::CopyFrom(const ChangeView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.ChangeView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeView::IsInitialized() const {
  return true;
}

void ChangeView::InternalSwap(ChangeView* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.view_width_, other->_impl_.view_width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeView::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[19]);
}
// ===================================================================

class BallMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<BallMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BallMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& ball_position(const BallMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_velocity(const BallMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
BallMessage::_Internal::ball_position(const BallMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
BallMessage::_Internal::ball_velocity(const BallMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
BallMessage::BallMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.BallMessage)
}
BallMessage::BallMessage(const BallMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BallMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.BallMessage)
}

inline void BallMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
  };
}

BallMessage::~BallMessage() {
  // @@protoc_insertion_point(destructor:protos.BallMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BallMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
}

void BallMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BallMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.BallMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BallMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D ball_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BallMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.BallMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D ball_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.BallMessage)
  return target;
}

::size_t BallMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.BallMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D ball_position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BallMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BallMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BallMessage::GetClassData() const { return &_class_data_; }


void BallMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BallMessage*>(&to_msg);
  auto& from = static_cast<const BallMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.BallMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BallMessage::CopyFrom(const BallMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.BallMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BallMessage::IsInitialized() const {
  return true;
}

void BallMessage::InternalSwap(BallMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BallMessage, _impl_.ball_velocity_)
      + sizeof(BallMessage::_impl_.ball_velocity_)
      - PROTOBUF_FIELD_OFFSET(BallMessage, _impl_.ball_position_)>(
          reinterpret_cast<char*>(&_impl_.ball_position_),
          reinterpret_cast<char*>(&other->_impl_.ball_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BallMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[20]);
}
// ===================================================================

class PassMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PassMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PassMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& receiver_point(const PassMessage* msg);
  static void set_has_receiver_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_position(const PassMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& ball_velocity(const PassMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
PassMessage::_Internal::receiver_point(const PassMessage* msg) {
  return *msg->_impl_.receiver_point_;
}
const ::protos::Vector2D&
PassMessage::_Internal::ball_position(const PassMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
PassMessage::_Internal::ball_velocity(const PassMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
PassMessage::PassMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PassMessage)
}
PassMessage::PassMessage(const PassMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PassMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.receiver_point_){nullptr}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.receiver_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.receiver_point_ = new ::protos::Vector2D(*from._impl_.receiver_point_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  _this->_impl_.receiver_uniform_number_ = from._impl_.receiver_uniform_number_;
  // @@protoc_insertion_point(copy_constructor:protos.PassMessage)
}

inline void PassMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.receiver_point_){nullptr}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.receiver_uniform_number_) { 0 }

  };
}

PassMessage::~PassMessage() {
  // @@protoc_insertion_point(destructor:protos.PassMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PassMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.receiver_point_;
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
}

void PassMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PassMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PassMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.receiver_point_ != nullptr);
      _impl_.receiver_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
  }
  _impl_.receiver_uniform_number_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PassMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 receiver_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.receiver_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D receiver_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiver_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PassMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PassMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 receiver_uniform_number = 1;
  if (this->_internal_receiver_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_receiver_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D receiver_point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::receiver_point(this),
        _Internal::receiver_point(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PassMessage)
  return target;
}

::size_t PassMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PassMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D receiver_point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.receiver_point_);
    }

    // .protos.Vector2D ball_position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

  }
  // int32 receiver_uniform_number = 1;
  if (this->_internal_receiver_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_receiver_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PassMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PassMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PassMessage::GetClassData() const { return &_class_data_; }


void PassMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PassMessage*>(&to_msg);
  auto& from = static_cast<const PassMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PassMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_receiver_point()->::protos::Vector2D::MergeFrom(
          from._internal_receiver_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
  }
  if (from._internal_receiver_uniform_number() != 0) {
    _this->_internal_set_receiver_uniform_number(from._internal_receiver_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PassMessage::CopyFrom(const PassMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PassMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassMessage::IsInitialized() const {
  return true;
}

void PassMessage::InternalSwap(PassMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PassMessage, _impl_.receiver_uniform_number_)
      + sizeof(PassMessage::_impl_.receiver_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(PassMessage, _impl_.receiver_point_)>(
          reinterpret_cast<char*>(&_impl_.receiver_point_),
          reinterpret_cast<char*>(&other->_impl_.receiver_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PassMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[21]);
}
// ===================================================================

class InterceptMessage::_Internal {
 public:
};

InterceptMessage::InterceptMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptMessage)
}
InterceptMessage::InterceptMessage(const InterceptMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.InterceptMessage)
}

inline void InterceptMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.our_) { false }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.cycle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InterceptMessage::~InterceptMessage() {
  // @@protoc_insertion_point(destructor:protos.InterceptMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void InterceptMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.our_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.cycle_) -
      reinterpret_cast<char*>(&_impl_.our_)) + sizeof(_impl_.cycle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool our = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.our_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 cycle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool our = 1;
  if (this->_internal_our() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_our(), target);
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_uniform_number(), target);
  }

  // int32 cycle = 3;
  if (this->_internal_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_cycle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptMessage)
  return target;
}

::size_t InterceptMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool our = 1;
  if (this->_internal_our() != 0) {
    total_size += 2;
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 cycle = 3;
  if (this->_internal_cycle() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_cycle());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptMessage::GetClassData() const { return &_class_data_; }


void InterceptMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptMessage*>(&to_msg);
  auto& from = static_cast<const InterceptMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_our() != 0) {
    _this->_internal_set_our(from._internal_our());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_cycle() != 0) {
    _this->_internal_set_cycle(from._internal_cycle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptMessage::CopyFrom(const InterceptMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptMessage::IsInitialized() const {
  return true;
}

void InterceptMessage::InternalSwap(InterceptMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptMessage, _impl_.cycle_)
      + sizeof(InterceptMessage::_impl_.cycle_)
      - PROTOBUF_FIELD_OFFSET(InterceptMessage, _impl_.our_)>(
          reinterpret_cast<char*>(&_impl_.our_),
          reinterpret_cast<char*>(&other->_impl_.our_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[22]);
}
// ===================================================================

class GoalieMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GoalieMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GoalieMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& goalie_position(const GoalieMessage* msg);
  static void set_has_goalie_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
GoalieMessage::_Internal::goalie_position(const GoalieMessage* msg) {
  return *msg->_impl_.goalie_position_;
}
GoalieMessage::GoalieMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.GoalieMessage)
}
GoalieMessage::GoalieMessage(const GoalieMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GoalieMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) {}

    , decltype(_impl_.goalie_body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.goalie_position_ = new ::protos::Vector2D(*from._impl_.goalie_position_);
  }
  ::memcpy(&_impl_.goalie_uniform_number_, &from._impl_.goalie_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.goalie_body_direction_) -
    reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.goalie_body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.GoalieMessage)
}

inline void GoalieMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) { 0 }

    , decltype(_impl_.goalie_body_direction_) { 0 }

  };
}

GoalieMessage::~GoalieMessage() {
  // @@protoc_insertion_point(destructor:protos.GoalieMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GoalieMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.goalie_position_;
}

void GoalieMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GoalieMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.GoalieMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.goalie_position_ != nullptr);
    _impl_.goalie_position_->Clear();
  }
  ::memset(&_impl_.goalie_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.goalie_body_direction_) -
      reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.goalie_body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GoalieMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 goalie_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D goalie_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float goalie_body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.goalie_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GoalieMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.GoalieMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_goalie_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D goalie_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::goalie_position(this),
        _Internal::goalie_position(this).GetCachedSize(), target, stream);
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_goalie_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.GoalieMessage)
  return target;
}

::size_t GoalieMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.GoalieMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D goalie_position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.goalie_position_);
  }

  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_goalie_uniform_number());
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GoalieMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GoalieMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GoalieMessage::GetClassData() const { return &_class_data_; }


void GoalieMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GoalieMessage*>(&to_msg);
  auto& from = static_cast<const GoalieMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.GoalieMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_goalie_position()->::protos::Vector2D::MergeFrom(
        from._internal_goalie_position());
  }
  if (from._internal_goalie_uniform_number() != 0) {
    _this->_internal_set_goalie_uniform_number(from._internal_goalie_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = from._internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    _this->_internal_set_goalie_body_direction(from._internal_goalie_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GoalieMessage::CopyFrom(const GoalieMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.GoalieMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoalieMessage::IsInitialized() const {
  return true;
}

void GoalieMessage::InternalSwap(GoalieMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GoalieMessage, _impl_.goalie_body_direction_)
      + sizeof(GoalieMessage::_impl_.goalie_body_direction_)
      - PROTOBUF_FIELD_OFFSET(GoalieMessage, _impl_.goalie_position_)>(
          reinterpret_cast<char*>(&_impl_.goalie_position_),
          reinterpret_cast<char*>(&other->_impl_.goalie_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GoalieMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[23]);
}
// ===================================================================

class GoalieAndPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GoalieAndPlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GoalieAndPlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& goalie_position(const GoalieAndPlayerMessage* msg);
  static void set_has_goalie_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& player_position(const GoalieAndPlayerMessage* msg);
  static void set_has_player_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
GoalieAndPlayerMessage::_Internal::goalie_position(const GoalieAndPlayerMessage* msg) {
  return *msg->_impl_.goalie_position_;
}
const ::protos::Vector2D&
GoalieAndPlayerMessage::_Internal::player_position(const GoalieAndPlayerMessage* msg) {
  return *msg->_impl_.player_position_;
}
GoalieAndPlayerMessage::GoalieAndPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.GoalieAndPlayerMessage)
}
GoalieAndPlayerMessage::GoalieAndPlayerMessage(const GoalieAndPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GoalieAndPlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) {}

    , decltype(_impl_.goalie_body_direction_) {}

    , decltype(_impl_.player_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.goalie_position_ = new ::protos::Vector2D(*from._impl_.goalie_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.player_position_ = new ::protos::Vector2D(*from._impl_.player_position_);
  }
  ::memcpy(&_impl_.goalie_uniform_number_, &from._impl_.goalie_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.player_uniform_number_) -
    reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.player_uniform_number_));
  // @@protoc_insertion_point(copy_constructor:protos.GoalieAndPlayerMessage)
}

inline void GoalieAndPlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) { 0 }

    , decltype(_impl_.goalie_body_direction_) { 0 }

    , decltype(_impl_.player_uniform_number_) { 0 }

  };
}

GoalieAndPlayerMessage::~GoalieAndPlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.GoalieAndPlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GoalieAndPlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.goalie_position_;
  if (this != internal_default_instance()) delete _impl_.player_position_;
}

void GoalieAndPlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GoalieAndPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.GoalieAndPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.goalie_position_ != nullptr);
      _impl_.goalie_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.player_position_ != nullptr);
      _impl_.player_position_->Clear();
    }
  }
  ::memset(&_impl_.goalie_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.player_uniform_number_) -
      reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.player_uniform_number_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GoalieAndPlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 goalie_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D goalie_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float goalie_body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.goalie_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_uniform_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.player_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D player_position = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GoalieAndPlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.GoalieAndPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_goalie_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D goalie_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::goalie_position(this),
        _Internal::goalie_position(this).GetCachedSize(), target, stream);
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_goalie_body_direction(), target);
  }

  // int32 player_uniform_number = 4;
  if (this->_internal_player_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_player_uniform_number(), target);
  }

  // .protos.Vector2D player_position = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::player_position(this),
        _Internal::player_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.GoalieAndPlayerMessage)
  return target;
}

::size_t GoalieAndPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.GoalieAndPlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D goalie_position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.goalie_position_);
    }

    // .protos.Vector2D player_position = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_position_);
    }

  }
  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_goalie_uniform_number());
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    total_size += 5;
  }

  // int32 player_uniform_number = 4;
  if (this->_internal_player_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_player_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GoalieAndPlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GoalieAndPlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GoalieAndPlayerMessage::GetClassData() const { return &_class_data_; }


void GoalieAndPlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GoalieAndPlayerMessage*>(&to_msg);
  auto& from = static_cast<const GoalieAndPlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.GoalieAndPlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_goalie_position()->::protos::Vector2D::MergeFrom(
          from._internal_goalie_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_player_position()->::protos::Vector2D::MergeFrom(
          from._internal_player_position());
    }
  }
  if (from._internal_goalie_uniform_number() != 0) {
    _this->_internal_set_goalie_uniform_number(from._internal_goalie_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = from._internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    _this->_internal_set_goalie_body_direction(from._internal_goalie_body_direction());
  }
  if (from._internal_player_uniform_number() != 0) {
    _this->_internal_set_player_uniform_number(from._internal_player_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GoalieAndPlayerMessage::CopyFrom(const GoalieAndPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.GoalieAndPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoalieAndPlayerMessage::IsInitialized() const {
  return true;
}

void GoalieAndPlayerMessage::InternalSwap(GoalieAndPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GoalieAndPlayerMessage, _impl_.player_uniform_number_)
      + sizeof(GoalieAndPlayerMessage::_impl_.player_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(GoalieAndPlayerMessage, _impl_.goalie_position_)>(
          reinterpret_cast<char*>(&_impl_.goalie_position_),
          reinterpret_cast<char*>(&other->_impl_.goalie_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GoalieAndPlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[24]);
}
// ===================================================================

class OffsideLineMessage::_Internal {
 public:
};

OffsideLineMessage::OffsideLineMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.OffsideLineMessage)
}
OffsideLineMessage::OffsideLineMessage(const OffsideLineMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.OffsideLineMessage)
}

inline void OffsideLineMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.offside_line_x_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OffsideLineMessage::~OffsideLineMessage() {
  // @@protoc_insertion_point(destructor:protos.OffsideLineMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OffsideLineMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OffsideLineMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OffsideLineMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.OffsideLineMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.offside_line_x_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OffsideLineMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float offside_line_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.offside_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OffsideLineMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.OffsideLineMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float offside_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_offside_line_x(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.OffsideLineMessage)
  return target;
}

::size_t OffsideLineMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.OffsideLineMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float offside_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OffsideLineMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OffsideLineMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OffsideLineMessage::GetClassData() const { return &_class_data_; }


void OffsideLineMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OffsideLineMessage*>(&to_msg);
  auto& from = static_cast<const OffsideLineMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.OffsideLineMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = from._internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    _this->_internal_set_offside_line_x(from._internal_offside_line_x());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OffsideLineMessage::CopyFrom(const OffsideLineMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.OffsideLineMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OffsideLineMessage::IsInitialized() const {
  return true;
}

void OffsideLineMessage::InternalSwap(OffsideLineMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.offside_line_x_, other->_impl_.offside_line_x_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OffsideLineMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[25]);
}
// ===================================================================

class DefenseLineMessage::_Internal {
 public:
};

DefenseLineMessage::DefenseLineMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DefenseLineMessage)
}
DefenseLineMessage::DefenseLineMessage(const DefenseLineMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DefenseLineMessage)
}

inline void DefenseLineMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.defense_line_x_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DefenseLineMessage::~DefenseLineMessage() {
  // @@protoc_insertion_point(destructor:protos.DefenseLineMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DefenseLineMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void DefenseLineMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DefenseLineMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DefenseLineMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.defense_line_x_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DefenseLineMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float defense_line_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.defense_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DefenseLineMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DefenseLineMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float defense_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_defense_line_x = this->_internal_defense_line_x();
  ::uint32_t raw_defense_line_x;
  memcpy(&raw_defense_line_x, &tmp_defense_line_x, sizeof(tmp_defense_line_x));
  if (raw_defense_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_defense_line_x(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DefenseLineMessage)
  return target;
}

::size_t DefenseLineMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DefenseLineMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float defense_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_defense_line_x = this->_internal_defense_line_x();
  ::uint32_t raw_defense_line_x;
  memcpy(&raw_defense_line_x, &tmp_defense_line_x, sizeof(tmp_defense_line_x));
  if (raw_defense_line_x != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DefenseLineMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DefenseLineMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DefenseLineMessage::GetClassData() const { return &_class_data_; }


void DefenseLineMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DefenseLineMessage*>(&to_msg);
  auto& from = static_cast<const DefenseLineMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DefenseLineMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_defense_line_x = from._internal_defense_line_x();
  ::uint32_t raw_defense_line_x;
  memcpy(&raw_defense_line_x, &tmp_defense_line_x, sizeof(tmp_defense_line_x));
  if (raw_defense_line_x != 0) {
    _this->_internal_set_defense_line_x(from._internal_defense_line_x());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DefenseLineMessage::CopyFrom(const DefenseLineMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DefenseLineMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DefenseLineMessage::IsInitialized() const {
  return true;
}

void DefenseLineMessage::InternalSwap(DefenseLineMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.defense_line_x_, other->_impl_.defense_line_x_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DefenseLineMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[26]);
}
// ===================================================================

class WaitRequestMessage::_Internal {
 public:
};

WaitRequestMessage::WaitRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.WaitRequestMessage)
}
WaitRequestMessage::WaitRequestMessage(const WaitRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  WaitRequestMessage* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.WaitRequestMessage)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WaitRequestMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WaitRequestMessage::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata WaitRequestMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[27]);
}
// ===================================================================

class SetplayMessage::_Internal {
 public:
};

SetplayMessage::SetplayMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.SetplayMessage)
}
SetplayMessage::SetplayMessage(const SetplayMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.SetplayMessage)
}

inline void SetplayMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.wait_step_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetplayMessage::~SetplayMessage() {
  // @@protoc_insertion_point(destructor:protos.SetplayMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetplayMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetplayMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetplayMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.SetplayMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wait_step_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetplayMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 wait_step = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.wait_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetplayMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.SetplayMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 wait_step = 1;
  if (this->_internal_wait_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_wait_step(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.SetplayMessage)
  return target;
}

::size_t SetplayMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.SetplayMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 wait_step = 1;
  if (this->_internal_wait_step() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_wait_step());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetplayMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetplayMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetplayMessage::GetClassData() const { return &_class_data_; }


void SetplayMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetplayMessage*>(&to_msg);
  auto& from = static_cast<const SetplayMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.SetplayMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_wait_step() != 0) {
    _this->_internal_set_wait_step(from._internal_wait_step());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetplayMessage::CopyFrom(const SetplayMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.SetplayMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetplayMessage::IsInitialized() const {
  return true;
}

void SetplayMessage::InternalSwap(SetplayMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.wait_step_, other->_impl_.wait_step_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetplayMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[28]);
}
// ===================================================================

class PassRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PassRequestMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PassRequestMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const PassRequestMessage* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
PassRequestMessage::_Internal::target_point(const PassRequestMessage* msg) {
  return *msg->_impl_.target_point_;
}
PassRequestMessage::PassRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PassRequestMessage)
}
PassRequestMessage::PassRequestMessage(const PassRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PassRequestMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.PassRequestMessage)
}

inline void PassRequestMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
  };
}

PassRequestMessage::~PassRequestMessage() {
  // @@protoc_insertion_point(destructor:protos.PassRequestMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PassRequestMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void PassRequestMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PassRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PassRequestMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PassRequestMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PassRequestMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PassRequestMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PassRequestMessage)
  return target;
}

::size_t PassRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PassRequestMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PassRequestMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PassRequestMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PassRequestMessage::GetClassData() const { return &_class_data_; }


void PassRequestMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PassRequestMessage*>(&to_msg);
  auto& from = static_cast<const PassRequestMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PassRequestMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PassRequestMessage::CopyFrom(const PassRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PassRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassRequestMessage::IsInitialized() const {
  return true;
}

void PassRequestMessage::InternalSwap(PassRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.target_point_, other->_impl_.target_point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PassRequestMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[29]);
}
// ===================================================================

class StaminaMessage::_Internal {
 public:
};

StaminaMessage::StaminaMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.StaminaMessage)
}
StaminaMessage::StaminaMessage(const StaminaMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.StaminaMessage)
}

inline void StaminaMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.stamina_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StaminaMessage::~StaminaMessage() {
  // @@protoc_insertion_point(destructor:protos.StaminaMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaminaMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaminaMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaminaMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.StaminaMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stamina_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaminaMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float stamina = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StaminaMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.StaminaMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float stamina = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_stamina(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.StaminaMessage)
  return target;
}

::size_t StaminaMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.StaminaMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float stamina = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaminaMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaminaMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaminaMessage::GetClassData() const { return &_class_data_; }


void StaminaMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaminaMessage*>(&to_msg);
  auto& from = static_cast<const StaminaMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.StaminaMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = from._internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    _this->_internal_set_stamina(from._internal_stamina());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaminaMessage::CopyFrom(const StaminaMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.StaminaMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaminaMessage::IsInitialized() const {
  return true;
}

void StaminaMessage::InternalSwap(StaminaMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.stamina_, other->_impl_.stamina_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaminaMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[30]);
}
// ===================================================================

class RecoveryMessage::_Internal {
 public:
};

RecoveryMessage::RecoveryMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.RecoveryMessage)
}
RecoveryMessage::RecoveryMessage(const RecoveryMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.RecoveryMessage)
}

inline void RecoveryMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.recovery_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecoveryMessage::~RecoveryMessage() {
  // @@protoc_insertion_point(destructor:protos.RecoveryMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecoveryMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void RecoveryMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecoveryMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.RecoveryMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recovery_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecoveryMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float recovery = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.recovery_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RecoveryMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.RecoveryMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float recovery = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recovery = this->_internal_recovery();
  ::uint32_t raw_recovery;
  memcpy(&raw_recovery, &tmp_recovery, sizeof(tmp_recovery));
  if (raw_recovery != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_recovery(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.RecoveryMessage)
  return target;
}

::size_t RecoveryMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.RecoveryMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float recovery = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recovery = this->_internal_recovery();
  ::uint32_t raw_recovery;
  memcpy(&raw_recovery, &tmp_recovery, sizeof(tmp_recovery));
  if (raw_recovery != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecoveryMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecoveryMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecoveryMessage::GetClassData() const { return &_class_data_; }


void RecoveryMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecoveryMessage*>(&to_msg);
  auto& from = static_cast<const RecoveryMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.RecoveryMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recovery = from._internal_recovery();
  ::uint32_t raw_recovery;
  memcpy(&raw_recovery, &tmp_recovery, sizeof(tmp_recovery));
  if (raw_recovery != 0) {
    _this->_internal_set_recovery(from._internal_recovery());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecoveryMessage::CopyFrom(const RecoveryMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.RecoveryMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoveryMessage::IsInitialized() const {
  return true;
}

void RecoveryMessage::InternalSwap(RecoveryMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.recovery_, other->_impl_.recovery_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RecoveryMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[31]);
}
// ===================================================================

class StaminaCapacityMessage::_Internal {
 public:
};

StaminaCapacityMessage::StaminaCapacityMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.StaminaCapacityMessage)
}
StaminaCapacityMessage::StaminaCapacityMessage(const StaminaCapacityMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.StaminaCapacityMessage)
}

inline void StaminaCapacityMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.stamina_capacity_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StaminaCapacityMessage::~StaminaCapacityMessage() {
  // @@protoc_insertion_point(destructor:protos.StaminaCapacityMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaminaCapacityMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaminaCapacityMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaminaCapacityMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.StaminaCapacityMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stamina_capacity_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaminaCapacityMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float stamina_capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.stamina_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StaminaCapacityMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.StaminaCapacityMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float stamina_capacity = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = this->_internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_stamina_capacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.StaminaCapacityMessage)
  return target;
}

::size_t StaminaCapacityMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.StaminaCapacityMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float stamina_capacity = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = this->_internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaminaCapacityMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaminaCapacityMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaminaCapacityMessage::GetClassData() const { return &_class_data_; }


void StaminaCapacityMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaminaCapacityMessage*>(&to_msg);
  auto& from = static_cast<const StaminaCapacityMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.StaminaCapacityMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = from._internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    _this->_internal_set_stamina_capacity(from._internal_stamina_capacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaminaCapacityMessage::CopyFrom(const StaminaCapacityMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.StaminaCapacityMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaminaCapacityMessage::IsInitialized() const {
  return true;
}

void StaminaCapacityMessage::InternalSwap(StaminaCapacityMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.stamina_capacity_, other->_impl_.stamina_capacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaminaCapacityMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[32]);
}
// ===================================================================

class DribbleMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DribbleMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DribbleMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const DribbleMessage* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
DribbleMessage::_Internal::target_point(const DribbleMessage* msg) {
  return *msg->_impl_.target_point_;
}
DribbleMessage::DribbleMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DribbleMessage)
}
DribbleMessage::DribbleMessage(const DribbleMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DribbleMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.queue_count_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  _this->_impl_.queue_count_ = from._impl_.queue_count_;
  // @@protoc_insertion_point(copy_constructor:protos.DribbleMessage)
}

inline void DribbleMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.queue_count_) { 0 }

  };
}

DribbleMessage::~DribbleMessage() {
  // @@protoc_insertion_point(destructor:protos.DribbleMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DribbleMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void DribbleMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DribbleMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DribbleMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_.queue_count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DribbleMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 queue_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.queue_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DribbleMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DribbleMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // int32 queue_count = 2;
  if (this->_internal_queue_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_queue_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DribbleMessage)
  return target;
}

::size_t DribbleMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DribbleMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // int32 queue_count = 2;
  if (this->_internal_queue_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_queue_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DribbleMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DribbleMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DribbleMessage::GetClassData() const { return &_class_data_; }


void DribbleMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DribbleMessage*>(&to_msg);
  auto& from = static_cast<const DribbleMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DribbleMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  if (from._internal_queue_count() != 0) {
    _this->_internal_set_queue_count(from._internal_queue_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DribbleMessage::CopyFrom(const DribbleMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DribbleMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DribbleMessage::IsInitialized() const {
  return true;
}

void DribbleMessage::InternalSwap(DribbleMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DribbleMessage, _impl_.queue_count_)
      + sizeof(DribbleMessage::_impl_.queue_count_)
      - PROTOBUF_FIELD_OFFSET(DribbleMessage, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DribbleMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[33]);
}
// ===================================================================

class BallGoalieMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<BallGoalieMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BallGoalieMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& ball_position(const BallGoalieMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_velocity(const BallGoalieMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& goalie_position(const BallGoalieMessage* msg);
  static void set_has_goalie_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
BallGoalieMessage::_Internal::ball_position(const BallGoalieMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
BallGoalieMessage::_Internal::ball_velocity(const BallGoalieMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
const ::protos::Vector2D&
BallGoalieMessage::_Internal::goalie_position(const BallGoalieMessage* msg) {
  return *msg->_impl_.goalie_position_;
}
BallGoalieMessage::BallGoalieMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.BallGoalieMessage)
}
BallGoalieMessage::BallGoalieMessage(const BallGoalieMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BallGoalieMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.goalie_position_ = new ::protos::Vector2D(*from._impl_.goalie_position_);
  }
  _this->_impl_.goalie_body_direction_ = from._impl_.goalie_body_direction_;
  // @@protoc_insertion_point(copy_constructor:protos.BallGoalieMessage)
}

inline void BallGoalieMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_body_direction_) { 0 }

  };
}

BallGoalieMessage::~BallGoalieMessage() {
  // @@protoc_insertion_point(destructor:protos.BallGoalieMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BallGoalieMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
  if (this != internal_default_instance()) delete _impl_.goalie_position_;
}

void BallGoalieMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BallGoalieMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.BallGoalieMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.goalie_position_ != nullptr);
      _impl_.goalie_position_->Clear();
    }
  }
  _impl_.goalie_body_direction_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BallGoalieMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D ball_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D goalie_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float goalie_body_direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.goalie_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BallGoalieMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.BallGoalieMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D ball_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D goalie_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::goalie_position(this),
        _Internal::goalie_position(this).GetCachedSize(), target, stream);
  }

  // float goalie_body_direction = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_goalie_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.BallGoalieMessage)
  return target;
}

::size_t BallGoalieMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.BallGoalieMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D ball_position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

    // .protos.Vector2D goalie_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.goalie_position_);
    }

  }
  // float goalie_body_direction = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BallGoalieMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BallGoalieMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BallGoalieMessage::GetClassData() const { return &_class_data_; }


void BallGoalieMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BallGoalieMessage*>(&to_msg);
  auto& from = static_cast<const BallGoalieMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.BallGoalieMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_goalie_position()->::protos::Vector2D::MergeFrom(
          from._internal_goalie_position());
    }
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = from._internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    _this->_internal_set_goalie_body_direction(from._internal_goalie_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BallGoalieMessage::CopyFrom(const BallGoalieMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.BallGoalieMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BallGoalieMessage::IsInitialized() const {
  return true;
}

void BallGoalieMessage::InternalSwap(BallGoalieMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BallGoalieMessage, _impl_.goalie_body_direction_)
      + sizeof(BallGoalieMessage::_impl_.goalie_body_direction_)
      - PROTOBUF_FIELD_OFFSET(BallGoalieMessage, _impl_.ball_position_)>(
          reinterpret_cast<char*>(&_impl_.ball_position_),
          reinterpret_cast<char*>(&other->_impl_.ball_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BallGoalieMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[34]);
}
// ===================================================================

class OnePlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<OnePlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OnePlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const OnePlayerMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
OnePlayerMessage::_Internal::position(const OnePlayerMessage* msg) {
  return *msg->_impl_.position_;
}
OnePlayerMessage::OnePlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.OnePlayerMessage)
}
OnePlayerMessage::OnePlayerMessage(const OnePlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OnePlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  _this->_impl_.uniform_number_ = from._impl_.uniform_number_;
  // @@protoc_insertion_point(copy_constructor:protos.OnePlayerMessage)
}

inline void OnePlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

  };
}

OnePlayerMessage::~OnePlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.OnePlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnePlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void OnePlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OnePlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.OnePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_.uniform_number_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OnePlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OnePlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.OnePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.OnePlayerMessage)
  return target;
}

::size_t OnePlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.OnePlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OnePlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OnePlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OnePlayerMessage::GetClassData() const { return &_class_data_; }


void OnePlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OnePlayerMessage*>(&to_msg);
  auto& from = static_cast<const OnePlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.OnePlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OnePlayerMessage::CopyFrom(const OnePlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.OnePlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnePlayerMessage::IsInitialized() const {
  return true;
}

void OnePlayerMessage::InternalSwap(OnePlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OnePlayerMessage, _impl_.uniform_number_)
      + sizeof(OnePlayerMessage::_impl_.uniform_number_)
      - PROTOBUF_FIELD_OFFSET(OnePlayerMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OnePlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[35]);
}
// ===================================================================

class TwoPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TwoPlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TwoPlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& first_position(const TwoPlayerMessage* msg);
  static void set_has_first_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& second_position(const TwoPlayerMessage* msg);
  static void set_has_second_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
TwoPlayerMessage::_Internal::first_position(const TwoPlayerMessage* msg) {
  return *msg->_impl_.first_position_;
}
const ::protos::Vector2D&
TwoPlayerMessage::_Internal::second_position(const TwoPlayerMessage* msg) {
  return *msg->_impl_.second_position_;
}
TwoPlayerMessage::TwoPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TwoPlayerMessage)
}
TwoPlayerMessage::TwoPlayerMessage(const TwoPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TwoPlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) {}

    , decltype(_impl_.second_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.first_position_ = new ::protos::Vector2D(*from._impl_.first_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.second_position_ = new ::protos::Vector2D(*from._impl_.second_position_);
  }
  ::memcpy(&_impl_.first_uniform_number_, &from._impl_.first_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.second_uniform_number_) -
    reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.second_uniform_number_));
  // @@protoc_insertion_point(copy_constructor:protos.TwoPlayerMessage)
}

inline void TwoPlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) { 0 }

    , decltype(_impl_.second_uniform_number_) { 0 }

  };
}

TwoPlayerMessage::~TwoPlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.TwoPlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TwoPlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.first_position_;
  if (this != internal_default_instance()) delete _impl_.second_position_;
}

void TwoPlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TwoPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TwoPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.first_position_ != nullptr);
      _impl_.first_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.second_position_ != nullptr);
      _impl_.second_position_->Clear();
    }
  }
  ::memset(&_impl_.first_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.second_uniform_number_) -
      reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.second_uniform_number_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TwoPlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 first_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.first_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D first_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_uniform_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.second_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D second_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_second_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TwoPlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TwoPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_first_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D first_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::first_position(this),
        _Internal::first_position(this).GetCachedSize(), target, stream);
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_second_uniform_number(), target);
  }

  // .protos.Vector2D second_position = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::second_position(this),
        _Internal::second_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TwoPlayerMessage)
  return target;
}

::size_t TwoPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TwoPlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D first_position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.first_position_);
    }

    // .protos.Vector2D second_position = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.second_position_);
    }

  }
  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_uniform_number());
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TwoPlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TwoPlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TwoPlayerMessage::GetClassData() const { return &_class_data_; }


void TwoPlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TwoPlayerMessage*>(&to_msg);
  auto& from = static_cast<const TwoPlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TwoPlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_first_position()->::protos::Vector2D::MergeFrom(
          from._internal_first_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_second_position()->::protos::Vector2D::MergeFrom(
          from._internal_second_position());
    }
  }
  if (from._internal_first_uniform_number() != 0) {
    _this->_internal_set_first_uniform_number(from._internal_first_uniform_number());
  }
  if (from._internal_second_uniform_number() != 0) {
    _this->_internal_set_second_uniform_number(from._internal_second_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TwoPlayerMessage::CopyFrom(const TwoPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TwoPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TwoPlayerMessage::IsInitialized() const {
  return true;
}

void TwoPlayerMessage::InternalSwap(TwoPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TwoPlayerMessage, _impl_.second_uniform_number_)
      + sizeof(TwoPlayerMessage::_impl_.second_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(TwoPlayerMessage, _impl_.first_position_)>(
          reinterpret_cast<char*>(&_impl_.first_position_),
          reinterpret_cast<char*>(&other->_impl_.first_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TwoPlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[36]);
}
// ===================================================================

class ThreePlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreePlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ThreePlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& first_position(const ThreePlayerMessage* msg);
  static void set_has_first_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& second_position(const ThreePlayerMessage* msg);
  static void set_has_second_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& third_position(const ThreePlayerMessage* msg);
  static void set_has_third_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
ThreePlayerMessage::_Internal::first_position(const ThreePlayerMessage* msg) {
  return *msg->_impl_.first_position_;
}
const ::protos::Vector2D&
ThreePlayerMessage::_Internal::second_position(const ThreePlayerMessage* msg) {
  return *msg->_impl_.second_position_;
}
const ::protos::Vector2D&
ThreePlayerMessage::_Internal::third_position(const ThreePlayerMessage* msg) {
  return *msg->_impl_.third_position_;
}
ThreePlayerMessage::ThreePlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.ThreePlayerMessage)
}
ThreePlayerMessage::ThreePlayerMessage(const ThreePlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThreePlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.third_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) {}

    , decltype(_impl_.second_uniform_number_) {}

    , decltype(_impl_.third_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.first_position_ = new ::protos::Vector2D(*from._impl_.first_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.second_position_ = new ::protos::Vector2D(*from._impl_.second_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.third_position_ = new ::protos::Vector2D(*from._impl_.third_position_);
  }
  ::memcpy(&_impl_.first_uniform_number_, &from._impl_.first_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.third_uniform_number_) -
    reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.third_uniform_number_));
  // @@protoc_insertion_point(copy_constructor:protos.ThreePlayerMessage)
}

inline void ThreePlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.third_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) { 0 }

    , decltype(_impl_.second_uniform_number_) { 0 }

    , decltype(_impl_.third_uniform_number_) { 0 }

  };
}

ThreePlayerMessage::~ThreePlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.ThreePlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreePlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.first_position_;
  if (this != internal_default_instance()) delete _impl_.second_position_;
  if (this != internal_default_instance()) delete _impl_.third_position_;
}

void ThreePlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreePlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.ThreePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.first_position_ != nullptr);
      _impl_.first_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.second_position_ != nullptr);
      _impl_.second_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.third_position_ != nullptr);
      _impl_.third_position_->Clear();
    }
  }
  ::memset(&_impl_.first_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.third_uniform_number_) -
      reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.third_uniform_number_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThreePlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 first_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.first_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D first_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_uniform_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.second_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D second_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_second_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 third_uniform_number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.third_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D third_position = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_third_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ThreePlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.ThreePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_first_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D first_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::first_position(this),
        _Internal::first_position(this).GetCachedSize(), target, stream);
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_second_uniform_number(), target);
  }

  // .protos.Vector2D second_position = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::second_position(this),
        _Internal::second_position(this).GetCachedSize(), target, stream);
  }

  // int32 third_uniform_number = 5;
  if (this->_internal_third_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_third_uniform_number(), target);
  }

  // .protos.Vector2D third_position = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::third_position(this),
        _Internal::third_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.ThreePlayerMessage)
  return target;
}

::size_t ThreePlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.ThreePlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D first_position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.first_position_);
    }

    // .protos.Vector2D second_position = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.second_position_);
    }

    // .protos.Vector2D third_position = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.third_position_);
    }

  }
  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_uniform_number());
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_uniform_number());
  }

  // int32 third_uniform_number = 5;
  if (this->_internal_third_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_third_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThreePlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThreePlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThreePlayerMessage::GetClassData() const { return &_class_data_; }


void ThreePlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThreePlayerMessage*>(&to_msg);
  auto& from = static_cast<const ThreePlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.ThreePlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_first_position()->::protos::Vector2D::MergeFrom(
          from._internal_first_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_second_position()->::protos::Vector2D::MergeFrom(
          from._internal_second_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_third_position()->::protos::Vector2D::MergeFrom(
          from._internal_third_position());
    }
  }
  if (from._internal_first_uniform_number() != 0) {
    _this->_internal_set_first_uniform_number(from._internal_first_uniform_number());
  }
  if (from._internal_second_uniform_number() != 0) {
    _this->_internal_set_second_uniform_number(from._internal_second_uniform_number());
  }
  if (from._internal_third_uniform_number() != 0) {
    _this->_internal_set_third_uniform_number(from._internal_third_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThreePlayerMessage::CopyFrom(const ThreePlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.ThreePlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreePlayerMessage::IsInitialized() const {
  return true;
}

void ThreePlayerMessage::InternalSwap(ThreePlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreePlayerMessage, _impl_.third_uniform_number_)
      + sizeof(ThreePlayerMessage::_impl_.third_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(ThreePlayerMessage, _impl_.first_position_)>(
          reinterpret_cast<char*>(&_impl_.first_position_),
          reinterpret_cast<char*>(&other->_impl_.first_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ThreePlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[37]);
}
// ===================================================================

class SelfMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SelfMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SelfMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& self_position(const SelfMessage* msg);
  static void set_has_self_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
SelfMessage::_Internal::self_position(const SelfMessage* msg) {
  return *msg->_impl_.self_position_;
}
SelfMessage::SelfMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.SelfMessage)
}
SelfMessage::SelfMessage(const SelfMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SelfMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.self_position_){nullptr}
    , decltype(_impl_.self_body_direction_) {}

    , decltype(_impl_.self_stamina_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.self_position_ = new ::protos::Vector2D(*from._impl_.self_position_);
  }
  ::memcpy(&_impl_.self_body_direction_, &from._impl_.self_body_direction_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.self_stamina_) -
    reinterpret_cast<char*>(&_impl_.self_body_direction_)) + sizeof(_impl_.self_stamina_));
  // @@protoc_insertion_point(copy_constructor:protos.SelfMessage)
}

inline void SelfMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.self_position_){nullptr}
    , decltype(_impl_.self_body_direction_) { 0 }

    , decltype(_impl_.self_stamina_) { 0 }

  };
}

SelfMessage::~SelfMessage() {
  // @@protoc_insertion_point(destructor:protos.SelfMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelfMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.self_position_;
}

void SelfMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelfMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.SelfMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.self_position_ != nullptr);
    _impl_.self_position_->Clear();
  }
  ::memset(&_impl_.self_body_direction_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.self_stamina_) -
      reinterpret_cast<char*>(&_impl_.self_body_direction_)) + sizeof(_impl_.self_stamina_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelfMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D self_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_self_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float self_body_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.self_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float self_stamina = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.self_stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SelfMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.SelfMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D self_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::self_position(this),
        _Internal::self_position(this).GetCachedSize(), target, stream);
  }

  // float self_body_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_body_direction = this->_internal_self_body_direction();
  ::uint32_t raw_self_body_direction;
  memcpy(&raw_self_body_direction, &tmp_self_body_direction, sizeof(tmp_self_body_direction));
  if (raw_self_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_self_body_direction(), target);
  }

  // float self_stamina = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_stamina = this->_internal_self_stamina();
  ::uint32_t raw_self_stamina;
  memcpy(&raw_self_stamina, &tmp_self_stamina, sizeof(tmp_self_stamina));
  if (raw_self_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_self_stamina(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.SelfMessage)
  return target;
}

::size_t SelfMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.SelfMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D self_position = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.self_position_);
  }

  // float self_body_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_body_direction = this->_internal_self_body_direction();
  ::uint32_t raw_self_body_direction;
  memcpy(&raw_self_body_direction, &tmp_self_body_direction, sizeof(tmp_self_body_direction));
  if (raw_self_body_direction != 0) {
    total_size += 5;
  }

  // float self_stamina = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_stamina = this->_internal_self_stamina();
  ::uint32_t raw_self_stamina;
  memcpy(&raw_self_stamina, &tmp_self_stamina, sizeof(tmp_self_stamina));
  if (raw_self_stamina != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelfMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelfMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelfMessage::GetClassData() const { return &_class_data_; }


void SelfMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelfMessage*>(&to_msg);
  auto& from = static_cast<const SelfMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.SelfMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_self_position()->::protos::Vector2D::MergeFrom(
        from._internal_self_position());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_body_direction = from._internal_self_body_direction();
  ::uint32_t raw_self_body_direction;
  memcpy(&raw_self_body_direction, &tmp_self_body_direction, sizeof(tmp_self_body_direction));
  if (raw_self_body_direction != 0) {
    _this->_internal_set_self_body_direction(from._internal_self_body_direction());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_stamina = from._internal_self_stamina();
  ::uint32_t raw_self_stamina;
  memcpy(&raw_self_stamina, &tmp_self_stamina, sizeof(tmp_self_stamina));
  if (raw_self_stamina != 0) {
    _this->_internal_set_self_stamina(from._internal_self_stamina());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelfMessage::CopyFrom(const SelfMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.SelfMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelfMessage::IsInitialized() const {
  return true;
}

void SelfMessage::InternalSwap(SelfMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelfMessage, _impl_.self_stamina_)
      + sizeof(SelfMessage::_impl_.self_stamina_)
      - PROTOBUF_FIELD_OFFSET(SelfMessage, _impl_.self_position_)>(
          reinterpret_cast<char*>(&_impl_.self_position_),
          reinterpret_cast<char*>(&other->_impl_.self_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SelfMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[38]);
}
// ===================================================================

class TeammateMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TeammateMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TeammateMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const TeammateMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
TeammateMessage::_Internal::position(const TeammateMessage* msg) {
  return *msg->_impl_.position_;
}
TeammateMessage::TeammateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TeammateMessage)
}
TeammateMessage::TeammateMessage(const TeammateMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TeammateMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  ::memcpy(&_impl_.uniform_number_, &from._impl_.uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.body_direction_) -
    reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.TeammateMessage)
}

inline void TeammateMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

  };
}

TeammateMessage::~TeammateMessage() {
  // @@protoc_insertion_point(destructor:protos.TeammateMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TeammateMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void TeammateMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TeammateMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TeammateMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  ::memset(&_impl_.uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.body_direction_) -
      reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TeammateMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TeammateMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TeammateMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TeammateMessage)
  return target;
}

::size_t TeammateMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TeammateMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TeammateMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TeammateMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TeammateMessage::GetClassData() const { return &_class_data_; }


void TeammateMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TeammateMessage*>(&to_msg);
  auto& from = static_cast<const TeammateMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TeammateMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TeammateMessage::CopyFrom(const TeammateMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TeammateMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeammateMessage::IsInitialized() const {
  return true;
}

void TeammateMessage::InternalSwap(TeammateMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TeammateMessage, _impl_.body_direction_)
      + sizeof(TeammateMessage::_impl_.body_direction_)
      - PROTOBUF_FIELD_OFFSET(TeammateMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TeammateMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[39]);
}
// ===================================================================

class OpponentMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<OpponentMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OpponentMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const OpponentMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
OpponentMessage::_Internal::position(const OpponentMessage* msg) {
  return *msg->_impl_.position_;
}
OpponentMessage::OpponentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.OpponentMessage)
}
OpponentMessage::OpponentMessage(const OpponentMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpponentMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  ::memcpy(&_impl_.uniform_number_, &from._impl_.uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.body_direction_) -
    reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.OpponentMessage)
}

inline void OpponentMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

  };
}

OpponentMessage::~OpponentMessage() {
  // @@protoc_insertion_point(destructor:protos.OpponentMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpponentMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void OpponentMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpponentMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.OpponentMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  ::memset(&_impl_.uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.body_direction_) -
      reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpponentMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OpponentMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.OpponentMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.OpponentMessage)
  return target;
}

::size_t OpponentMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.OpponentMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpponentMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpponentMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpponentMessage::GetClassData() const { return &_class_data_; }


void OpponentMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpponentMessage*>(&to_msg);
  auto& from = static_cast<const OpponentMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.OpponentMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpponentMessage::CopyFrom(const OpponentMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.OpponentMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpponentMessage::IsInitialized() const {
  return true;
}

void OpponentMessage::InternalSwap(OpponentMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpponentMessage, _impl_.body_direction_)
      + sizeof(OpponentMessage::_impl_.body_direction_)
      - PROTOBUF_FIELD_OFFSET(OpponentMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OpponentMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[40]);
}
// ===================================================================

class BallPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<BallPlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BallPlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& ball_position(const BallPlayerMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_velocity(const BallPlayerMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& player_position(const BallPlayerMessage* msg);
  static void set_has_player_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
BallPlayerMessage::_Internal::ball_position(const BallPlayerMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
BallPlayerMessage::_Internal::ball_velocity(const BallPlayerMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
const ::protos::Vector2D&
BallPlayerMessage::_Internal::player_position(const BallPlayerMessage* msg) {
  return *msg->_impl_.player_position_;
}
BallPlayerMessage::BallPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.BallPlayerMessage)
}
BallPlayerMessage::BallPlayerMessage(const BallPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BallPlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.player_position_ = new ::protos::Vector2D(*from._impl_.player_position_);
  }
  ::memcpy(&_impl_.uniform_number_, &from._impl_.uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.body_direction_) -
    reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.BallPlayerMessage)
}

inline void BallPlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

  };
}

BallPlayerMessage::~BallPlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.BallPlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BallPlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
  if (this != internal_default_instance()) delete _impl_.player_position_;
}

void BallPlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BallPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.BallPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.player_position_ != nullptr);
      _impl_.player_position_->Clear();
    }
  }
  ::memset(&_impl_.uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.body_direction_) -
      reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BallPlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D ball_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D player_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BallPlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.BallPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D ball_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 uniform_number = 3;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_uniform_number(), target);
  }

  // .protos.Vector2D player_position = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::player_position(this),
        _Internal::player_position(this).GetCachedSize(), target, stream);
  }

  // float body_direction = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.BallPlayerMessage)
  return target;
}

::size_t BallPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.BallPlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D ball_position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

    // .protos.Vector2D player_position = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_position_);
    }

  }
  // int32 uniform_number = 3;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // float body_direction = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BallPlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BallPlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BallPlayerMessage::GetClassData() const { return &_class_data_; }


void BallPlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BallPlayerMessage*>(&to_msg);
  auto& from = static_cast<const BallPlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.BallPlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_player_position()->::protos::Vector2D::MergeFrom(
          from._internal_player_position());
    }
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BallPlayerMessage::CopyFrom(const BallPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.BallPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BallPlayerMessage::IsInitialized() const {
  return true;
}

void BallPlayerMessage::InternalSwap(BallPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BallPlayerMessage, _impl_.body_direction_)
      + sizeof(BallPlayerMessage::_impl_.body_direction_)
      - PROTOBUF_FIELD_OFFSET(BallPlayerMessage, _impl_.ball_position_)>(
          reinterpret_cast<char*>(&_impl_.ball_position_),
          reinterpret_cast<char*>(&other->_impl_.ball_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BallPlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[41]);
}
// ===================================================================

class Say::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::Say, _impl_._oneof_case_);
  static const ::protos::BallMessage& ball_message(const Say* msg);
  static const ::protos::PassMessage& pass_message(const Say* msg);
  static const ::protos::InterceptMessage& intercept_message(const Say* msg);
  static const ::protos::GoalieMessage& goalie_message(const Say* msg);
  static const ::protos::GoalieAndPlayerMessage& goalie_and_player_message(const Say* msg);
  static const ::protos::OffsideLineMessage& offside_line_message(const Say* msg);
  static const ::protos::DefenseLineMessage& defense_line_message(const Say* msg);
  static const ::protos::WaitRequestMessage& wait_request_message(const Say* msg);
  static const ::protos::SetplayMessage& setplay_message(const Say* msg);
  static const ::protos::PassRequestMessage& pass_request_message(const Say* msg);
  static const ::protos::StaminaMessage& stamina_message(const Say* msg);
  static const ::protos::RecoveryMessage& recovery_message(const Say* msg);
  static const ::protos::StaminaCapacityMessage& stamina_capacity_message(const Say* msg);
  static const ::protos::DribbleMessage& dribble_message(const Say* msg);
  static const ::protos::BallGoalieMessage& ball_goalie_message(const Say* msg);
  static const ::protos::OnePlayerMessage& one_player_message(const Say* msg);
  static const ::protos::TwoPlayerMessage& two_player_message(const Say* msg);
  static const ::protos::ThreePlayerMessage& three_player_message(const Say* msg);
  static const ::protos::SelfMessage& self_message(const Say* msg);
  static const ::protos::TeammateMessage& teammate_message(const Say* msg);
  static const ::protos::OpponentMessage& opponent_message(const Say* msg);
  static const ::protos::BallPlayerMessage& ball_player_message(const Say* msg);
};

const ::protos::BallMessage&
Say::_Internal::ball_message(const Say* msg) {
  return *msg->_impl_.message_.ball_message_;
}
const ::protos::PassMessage&
Say::_Internal::pass_message(const Say* msg) {
  return *msg->_impl_.message_.pass_message_;
}
const ::protos::InterceptMessage&
Say::_Internal::intercept_message(const Say* msg) {
  return *msg->_impl_.message_.intercept_message_;
}
const ::protos::GoalieMessage&
Say::_Internal::goalie_message(const Say* msg) {
  return *msg->_impl_.message_.goalie_message_;
}
const ::protos::GoalieAndPlayerMessage&
Say::_Internal::goalie_and_player_message(const Say* msg) {
  return *msg->_impl_.message_.goalie_and_player_message_;
}
const ::protos::OffsideLineMessage&
Say::_Internal::offside_line_message(const Say* msg) {
  return *msg->_impl_.message_.offside_line_message_;
}
const ::protos::DefenseLineMessage&
Say::_Internal::defense_line_message(const Say* msg) {
  return *msg->_impl_.message_.defense_line_message_;
}
const ::protos::WaitRequestMessage&
Say::_Internal::wait_request_message(const Say* msg) {
  return *msg->_impl_.message_.wait_request_message_;
}
const ::protos::SetplayMessage&
Say::_Internal::setplay_message(const Say* msg) {
  return *msg->_impl_.message_.setplay_message_;
}
const ::protos::PassRequestMessage&
Say::_Internal::pass_request_message(const Say* msg) {
  return *msg->_impl_.message_.pass_request_message_;
}
const ::protos::StaminaMessage&
Say::_Internal::stamina_message(const Say* msg) {
  return *msg->_impl_.message_.stamina_message_;
}
const ::protos::RecoveryMessage&
Say::_Internal::recovery_message(const Say* msg) {
  return *msg->_impl_.message_.recovery_message_;
}
const ::protos::StaminaCapacityMessage&
Say::_Internal::stamina_capacity_message(const Say* msg) {
  return *msg->_impl_.message_.stamina_capacity_message_;
}
const ::protos::DribbleMessage&
Say::_Internal::dribble_message(const Say* msg) {
  return *msg->_impl_.message_.dribble_message_;
}
const ::protos::BallGoalieMessage&
Say::_Internal::ball_goalie_message(const Say* msg) {
  return *msg->_impl_.message_.ball_goalie_message_;
}
const ::protos::OnePlayerMessage&
Say::_Internal::one_player_message(const Say* msg) {
  return *msg->_impl_.message_.one_player_message_;
}
const ::protos::TwoPlayerMessage&
Say::_Internal::two_player_message(const Say* msg) {
  return *msg->_impl_.message_.two_player_message_;
}
const ::protos::ThreePlayerMessage&
Say::_Internal::three_player_message(const Say* msg) {
  return *msg->_impl_.message_.three_player_message_;
}
const ::protos::SelfMessage&
Say::_Internal::self_message(const Say* msg) {
  return *msg->_impl_.message_.self_message_;
}
const ::protos::TeammateMessage&
Say::_Internal::teammate_message(const Say* msg) {
  return *msg->_impl_.message_.teammate_message_;
}
const ::protos::OpponentMessage&
Say::_Internal::opponent_message(const Say* msg) {
  return *msg->_impl_.message_.opponent_message_;
}
const ::protos::BallPlayerMessage&
Say::_Internal::ball_player_message(const Say* msg) {
  return *msg->_impl_.message_.ball_player_message_;
}
void Say::set_allocated_ball_message(::protos::BallMessage* ball_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ball_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_message);
    if (message_arena != submessage_arena) {
      ball_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_message, submessage_arena);
    }
    set_has_ball_message();
    _impl_.message_.ball_message_ = ball_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.ball_message)
}
void Say::set_allocated_pass_message(::protos::PassMessage* pass_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (pass_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pass_message);
    if (message_arena != submessage_arena) {
      pass_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pass_message, submessage_arena);
    }
    set_has_pass_message();
    _impl_.message_.pass_message_ = pass_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.pass_message)
}
void Say::set_allocated_intercept_message(::protos::InterceptMessage* intercept_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (intercept_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intercept_message);
    if (message_arena != submessage_arena) {
      intercept_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intercept_message, submessage_arena);
    }
    set_has_intercept_message();
    _impl_.message_.intercept_message_ = intercept_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.intercept_message)
}
void Say::set_allocated_goalie_message(::protos::GoalieMessage* goalie_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (goalie_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goalie_message);
    if (message_arena != submessage_arena) {
      goalie_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goalie_message, submessage_arena);
    }
    set_has_goalie_message();
    _impl_.message_.goalie_message_ = goalie_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.goalie_message)
}
void Say::set_allocated_goalie_and_player_message(::protos::GoalieAndPlayerMessage* goalie_and_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (goalie_and_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goalie_and_player_message);
    if (message_arena != submessage_arena) {
      goalie_and_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goalie_and_player_message, submessage_arena);
    }
    set_has_goalie_and_player_message();
    _impl_.message_.goalie_and_player_message_ = goalie_and_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.goalie_and_player_message)
}
void Say::set_allocated_offside_line_message(::protos::OffsideLineMessage* offside_line_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (offside_line_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offside_line_message);
    if (message_arena != submessage_arena) {
      offside_line_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offside_line_message, submessage_arena);
    }
    set_has_offside_line_message();
    _impl_.message_.offside_line_message_ = offside_line_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.offside_line_message)
}
void Say::set_allocated_defense_line_message(::protos::DefenseLineMessage* defense_line_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (defense_line_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(defense_line_message);
    if (message_arena != submessage_arena) {
      defense_line_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, defense_line_message, submessage_arena);
    }
    set_has_defense_line_message();
    _impl_.message_.defense_line_message_ = defense_line_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.defense_line_message)
}
void Say::set_allocated_wait_request_message(::protos::WaitRequestMessage* wait_request_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (wait_request_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_request_message);
    if (message_arena != submessage_arena) {
      wait_request_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_request_message, submessage_arena);
    }
    set_has_wait_request_message();
    _impl_.message_.wait_request_message_ = wait_request_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.wait_request_message)
}
void Say::set_allocated_setplay_message(::protos::SetplayMessage* setplay_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (setplay_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(setplay_message);
    if (message_arena != submessage_arena) {
      setplay_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setplay_message, submessage_arena);
    }
    set_has_setplay_message();
    _impl_.message_.setplay_message_ = setplay_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.setplay_message)
}
void Say::set_allocated_pass_request_message(::protos::PassRequestMessage* pass_request_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (pass_request_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pass_request_message);
    if (message_arena != submessage_arena) {
      pass_request_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pass_request_message, submessage_arena);
    }
    set_has_pass_request_message();
    _impl_.message_.pass_request_message_ = pass_request_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.pass_request_message)
}
void Say::set_allocated_stamina_message(::protos::StaminaMessage* stamina_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (stamina_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stamina_message);
    if (message_arena != submessage_arena) {
      stamina_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamina_message, submessage_arena);
    }
    set_has_stamina_message();
    _impl_.message_.stamina_message_ = stamina_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.stamina_message)
}
void Say::set_allocated_recovery_message(::protos::RecoveryMessage* recovery_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (recovery_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recovery_message);
    if (message_arena != submessage_arena) {
      recovery_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recovery_message, submessage_arena);
    }
    set_has_recovery_message();
    _impl_.message_.recovery_message_ = recovery_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.recovery_message)
}
void Say::set_allocated_stamina_capacity_message(::protos::StaminaCapacityMessage* stamina_capacity_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (stamina_capacity_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stamina_capacity_message);
    if (message_arena != submessage_arena) {
      stamina_capacity_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamina_capacity_message, submessage_arena);
    }
    set_has_stamina_capacity_message();
    _impl_.message_.stamina_capacity_message_ = stamina_capacity_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.stamina_capacity_message)
}
void Say::set_allocated_dribble_message(::protos::DribbleMessage* dribble_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (dribble_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dribble_message);
    if (message_arena != submessage_arena) {
      dribble_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dribble_message, submessage_arena);
    }
    set_has_dribble_message();
    _impl_.message_.dribble_message_ = dribble_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.dribble_message)
}
void Say::set_allocated_ball_goalie_message(::protos::BallGoalieMessage* ball_goalie_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ball_goalie_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_goalie_message);
    if (message_arena != submessage_arena) {
      ball_goalie_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_goalie_message, submessage_arena);
    }
    set_has_ball_goalie_message();
    _impl_.message_.ball_goalie_message_ = ball_goalie_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.ball_goalie_message)
}
void Say::set_allocated_one_player_message(::protos::OnePlayerMessage* one_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (one_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(one_player_message);
    if (message_arena != submessage_arena) {
      one_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, one_player_message, submessage_arena);
    }
    set_has_one_player_message();
    _impl_.message_.one_player_message_ = one_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.one_player_message)
}
void Say::set_allocated_two_player_message(::protos::TwoPlayerMessage* two_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (two_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(two_player_message);
    if (message_arena != submessage_arena) {
      two_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, two_player_message, submessage_arena);
    }
    set_has_two_player_message();
    _impl_.message_.two_player_message_ = two_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.two_player_message)
}
void Say::set_allocated_three_player_message(::protos::ThreePlayerMessage* three_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (three_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(three_player_message);
    if (message_arena != submessage_arena) {
      three_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, three_player_message, submessage_arena);
    }
    set_has_three_player_message();
    _impl_.message_.three_player_message_ = three_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.three_player_message)
}
void Say::set_allocated_self_message(::protos::SelfMessage* self_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (self_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(self_message);
    if (message_arena != submessage_arena) {
      self_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self_message, submessage_arena);
    }
    set_has_self_message();
    _impl_.message_.self_message_ = self_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.self_message)
}
void Say::set_allocated_teammate_message(::protos::TeammateMessage* teammate_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (teammate_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(teammate_message);
    if (message_arena != submessage_arena) {
      teammate_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teammate_message, submessage_arena);
    }
    set_has_teammate_message();
    _impl_.message_.teammate_message_ = teammate_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.teammate_message)
}
void Say::set_allocated_opponent_message(::protos::OpponentMessage* opponent_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (opponent_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opponent_message);
    if (message_arena != submessage_arena) {
      opponent_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opponent_message, submessage_arena);
    }
    set_has_opponent_message();
    _impl_.message_.opponent_message_ = opponent_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.opponent_message)
}
void Say::set_allocated_ball_player_message(::protos::BallPlayerMessage* ball_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ball_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_player_message);
    if (message_arena != submessage_arena) {
      ball_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_player_message, submessage_arena);
    }
    set_has_ball_player_message();
    _impl_.message_.ball_player_message_ = ball_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.ball_player_message)
}
Say::Say(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Say)
}
Say::Say(const Say& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Say* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_message();
  switch (from.message_case()) {
    case kBallMessage: {
      _this->_internal_mutable_ball_message()->::protos::BallMessage::MergeFrom(
          from._internal_ball_message());
      break;
    }
    case kPassMessage: {
      _this->_internal_mutable_pass_message()->::protos::PassMessage::MergeFrom(
          from._internal_pass_message());
      break;
    }
    case kInterceptMessage: {
      _this->_internal_mutable_intercept_message()->::protos::InterceptMessage::MergeFrom(
          from._internal_intercept_message());
      break;
    }
    case kGoalieMessage: {
      _this->_internal_mutable_goalie_message()->::protos::GoalieMessage::MergeFrom(
          from._internal_goalie_message());
      break;
    }
    case kGoalieAndPlayerMessage: {
      _this->_internal_mutable_goalie_and_player_message()->::protos::GoalieAndPlayerMessage::MergeFrom(
          from._internal_goalie_and_player_message());
      break;
    }
    case kOffsideLineMessage: {
      _this->_internal_mutable_offside_line_message()->::protos::OffsideLineMessage::MergeFrom(
          from._internal_offside_line_message());
      break;
    }
    case kDefenseLineMessage: {
      _this->_internal_mutable_defense_line_message()->::protos::DefenseLineMessage::MergeFrom(
          from._internal_defense_line_message());
      break;
    }
    case kWaitRequestMessage: {
      _this->_internal_mutable_wait_request_message()->::protos::WaitRequestMessage::MergeFrom(
          from._internal_wait_request_message());
      break;
    }
    case kSetplayMessage: {
      _this->_internal_mutable_setplay_message()->::protos::SetplayMessage::MergeFrom(
          from._internal_setplay_message());
      break;
    }
    case kPassRequestMessage: {
      _this->_internal_mutable_pass_request_message()->::protos::PassRequestMessage::MergeFrom(
          from._internal_pass_request_message());
      break;
    }
    case kStaminaMessage: {
      _this->_internal_mutable_stamina_message()->::protos::StaminaMessage::MergeFrom(
          from._internal_stamina_message());
      break;
    }
    case kRecoveryMessage: {
      _this->_internal_mutable_recovery_message()->::protos::RecoveryMessage::MergeFrom(
          from._internal_recovery_message());
      break;
    }
    case kStaminaCapacityMessage: {
      _this->_internal_mutable_stamina_capacity_message()->::protos::StaminaCapacityMessage::MergeFrom(
          from._internal_stamina_capacity_message());
      break;
    }
    case kDribbleMessage: {
      _this->_internal_mutable_dribble_message()->::protos::DribbleMessage::MergeFrom(
          from._internal_dribble_message());
      break;
    }
    case kBallGoalieMessage: {
      _this->_internal_mutable_ball_goalie_message()->::protos::BallGoalieMessage::MergeFrom(
          from._internal_ball_goalie_message());
      break;
    }
    case kOnePlayerMessage: {
      _this->_internal_mutable_one_player_message()->::protos::OnePlayerMessage::MergeFrom(
          from._internal_one_player_message());
      break;
    }
    case kTwoPlayerMessage: {
      _this->_internal_mutable_two_player_message()->::protos::TwoPlayerMessage::MergeFrom(
          from._internal_two_player_message());
      break;
    }
    case kThreePlayerMessage: {
      _this->_internal_mutable_three_player_message()->::protos::ThreePlayerMessage::MergeFrom(
          from._internal_three_player_message());
      break;
    }
    case kSelfMessage: {
      _this->_internal_mutable_self_message()->::protos::SelfMessage::MergeFrom(
          from._internal_self_message());
      break;
    }
    case kTeammateMessage: {
      _this->_internal_mutable_teammate_message()->::protos::TeammateMessage::MergeFrom(
          from._internal_teammate_message());
      break;
    }
    case kOpponentMessage: {
      _this->_internal_mutable_opponent_message()->::protos::OpponentMessage::MergeFrom(
          from._internal_opponent_message());
      break;
    }
    case kBallPlayerMessage: {
      _this->_internal_mutable_ball_player_message()->::protos::BallPlayerMessage::MergeFrom(
          from._internal_ball_player_message());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.Say)
}

inline void Say::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

Say::~Say() {
  // @@protoc_insertion_point(destructor:protos.Say)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Say::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void Say::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Say::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:protos.Say)
  switch (message_case()) {
    case kBallMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ball_message_;
      }
      break;
    }
    case kPassMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.pass_message_;
      }
      break;
    }
    case kInterceptMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.intercept_message_;
      }
      break;
    }
    case kGoalieMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.goalie_message_;
      }
      break;
    }
    case kGoalieAndPlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.goalie_and_player_message_;
      }
      break;
    }
    case kOffsideLineMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.offside_line_message_;
      }
      break;
    }
    case kDefenseLineMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.defense_line_message_;
      }
      break;
    }
    case kWaitRequestMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.wait_request_message_;
      }
      break;
    }
    case kSetplayMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.setplay_message_;
      }
      break;
    }
    case kPassRequestMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.pass_request_message_;
      }
      break;
    }
    case kStaminaMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.stamina_message_;
      }
      break;
    }
    case kRecoveryMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.recovery_message_;
      }
      break;
    }
    case kStaminaCapacityMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.stamina_capacity_message_;
      }
      break;
    }
    case kDribbleMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.dribble_message_;
      }
      break;
    }
    case kBallGoalieMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ball_goalie_message_;
      }
      break;
    }
    case kOnePlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.one_player_message_;
      }
      break;
    }
    case kTwoPlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.two_player_message_;
      }
      break;
    }
    case kThreePlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.three_player_message_;
      }
      break;
    }
    case kSelfMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.self_message_;
      }
      break;
    }
    case kTeammateMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.teammate_message_;
      }
      break;
    }
    case kOpponentMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.opponent_message_;
      }
      break;
    }
    case kBallPlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ball_player_message_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void Say::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Say)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Say::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.BallMessage ball_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PassMessage pass_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pass_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.InterceptMessage intercept_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_intercept_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.GoalieMessage goalie_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_and_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.OffsideLineMessage offside_line_message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_offside_line_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DefenseLineMessage defense_line_message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_defense_line_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.WaitRequestMessage wait_request_message = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_request_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.SetplayMessage setplay_message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_setplay_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PassRequestMessage pass_request_message = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_pass_request_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.StaminaMessage stamina_message = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_stamina_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.RecoveryMessage recovery_message = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_recovery_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.StaminaCapacityMessage stamina_capacity_message = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_stamina_capacity_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DribbleMessage dribble_message = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_dribble_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.BallGoalieMessage ball_goalie_message = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_goalie_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.OnePlayerMessage one_player_message = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_one_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.TwoPlayerMessage two_player_message = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_two_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ThreePlayerMessage three_player_message = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_three_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.SelfMessage self_message = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_self_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.TeammateMessage teammate_message = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_teammate_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.OpponentMessage opponent_message = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_opponent_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.BallPlayerMessage ball_player_message = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Say::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Say)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (message_case()) {
    case kBallMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::ball_message(this),
          _Internal::ball_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kPassMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::pass_message(this),
          _Internal::pass_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kInterceptMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::intercept_message(this),
          _Internal::intercept_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kGoalieMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::goalie_message(this),
          _Internal::goalie_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kGoalieAndPlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::goalie_and_player_message(this),
          _Internal::goalie_and_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kOffsideLineMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::offside_line_message(this),
          _Internal::offside_line_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kDefenseLineMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::defense_line_message(this),
          _Internal::defense_line_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitRequestMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::wait_request_message(this),
          _Internal::wait_request_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetplayMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::setplay_message(this),
          _Internal::setplay_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kPassRequestMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::pass_request_message(this),
          _Internal::pass_request_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kStaminaMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::stamina_message(this),
          _Internal::stamina_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kRecoveryMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::recovery_message(this),
          _Internal::recovery_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kStaminaCapacityMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::stamina_capacity_message(this),
          _Internal::stamina_capacity_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kDribbleMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::dribble_message(this),
          _Internal::dribble_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kBallGoalieMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::ball_goalie_message(this),
          _Internal::ball_goalie_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnePlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::one_player_message(this),
          _Internal::one_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kTwoPlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, _Internal::two_player_message(this),
          _Internal::two_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kThreePlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, _Internal::three_player_message(this),
          _Internal::three_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kSelfMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, _Internal::self_message(this),
          _Internal::self_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kTeammateMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, _Internal::teammate_message(this),
          _Internal::teammate_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kOpponentMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, _Internal::opponent_message(this),
          _Internal::opponent_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kBallPlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, _Internal::ball_player_message(this),
          _Internal::ball_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Say)
  return target;
}

::size_t Say::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Say)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .protos.BallMessage ball_message = 1;
    case kBallMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ball_message_);
      break;
    }
    // .protos.PassMessage pass_message = 2;
    case kPassMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.pass_message_);
      break;
    }
    // .protos.InterceptMessage intercept_message = 3;
    case kInterceptMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.intercept_message_);
      break;
    }
    // .protos.GoalieMessage goalie_message = 4;
    case kGoalieMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.goalie_message_);
      break;
    }
    // .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
    case kGoalieAndPlayerMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.goalie_and_player_message_);
      break;
    }
    // .protos.OffsideLineMessage offside_line_message = 6;
    case kOffsideLineMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.offside_line_message_);
      break;
    }
    // .protos.DefenseLineMessage defense_line_message = 7;
    case kDefenseLineMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.defense_line_message_);
      break;
    }
    // .protos.WaitRequestMessage wait_request_message = 8;
    case kWaitRequestMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.wait_request_message_);
      break;
    }
    // .protos.SetplayMessage setplay_message = 9;
    case kSetplayMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.setplay_message_);
      break;
    }
    // .protos.PassRequestMessage pass_request_message = 10;
    case kPassRequestMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.pass_request_message_);
      break;
    }
    // .protos.StaminaMessage stamina_message = 11;
    case kStaminaMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.stamina_message_);
      break;
    }
    // .protos.RecoveryMessage recovery_message = 12;
    case kRecoveryMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.recovery_message_);
      break;
    }
    // .protos.StaminaCapacityMessage stamina_capacity_message = 13;
    case kStaminaCapacityMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.stamina_capacity_message_);
      break;
    }
    // .protos.DribbleMessage dribble_message = 14;
    case kDribbleMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.dribble_message_);
      break;
    }
    // .protos.BallGoalieMessage ball_goalie_message = 15;
    case kBallGoalieMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ball_goalie_message_);
      break;
    }
    // .protos.OnePlayerMessage one_player_message = 16;
    case kOnePlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.one_player_message_);
      break;
    }
    // .protos.TwoPlayerMessage two_player_message = 17;
    case kTwoPlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.two_player_message_);
      break;
    }
    // .protos.ThreePlayerMessage three_player_message = 18;
    case kThreePlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.three_player_message_);
      break;
    }
    // .protos.SelfMessage self_message = 19;
    case kSelfMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.self_message_);
      break;
    }
    // .protos.TeammateMessage teammate_message = 20;
    case kTeammateMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.teammate_message_);
      break;
    }
    // .protos.OpponentMessage opponent_message = 21;
    case kOpponentMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.opponent_message_);
      break;
    }
    // .protos.BallPlayerMessage ball_player_message = 22;
    case kBallPlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ball_player_message_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Say::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Say::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Say::GetClassData() const { return &_class_data_; }


void Say::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Say*>(&to_msg);
  auto& from = static_cast<const Say&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Say)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.message_case()) {
    case kBallMessage: {
      _this->_internal_mutable_ball_message()->::protos::BallMessage::MergeFrom(
          from._internal_ball_message());
      break;
    }
    case kPassMessage: {
      _this->_internal_mutable_pass_message()->::protos::PassMessage::MergeFrom(
          from._internal_pass_message());
      break;
    }
    case kInterceptMessage: {
      _this->_internal_mutable_intercept_message()->::protos::InterceptMessage::MergeFrom(
          from._internal_intercept_message());
      break;
    }
    case kGoalieMessage: {
      _this->_internal_mutable_goalie_message()->::protos::GoalieMessage::MergeFrom(
          from._internal_goalie_message());
      break;
    }
    case kGoalieAndPlayerMessage: {
      _this->_internal_mutable_goalie_and_player_message()->::protos::GoalieAndPlayerMessage::MergeFrom(
          from._internal_goalie_and_player_message());
      break;
    }
    case kOffsideLineMessage: {
      _this->_internal_mutable_offside_line_message()->::protos::OffsideLineMessage::MergeFrom(
          from._internal_offside_line_message());
      break;
    }
    case kDefenseLineMessage: {
      _this->_internal_mutable_defense_line_message()->::protos::DefenseLineMessage::MergeFrom(
          from._internal_defense_line_message());
      break;
    }
    case kWaitRequestMessage: {
      _this->_internal_mutable_wait_request_message()->::protos::WaitRequestMessage::MergeFrom(
          from._internal_wait_request_message());
      break;
    }
    case kSetplayMessage: {
      _this->_internal_mutable_setplay_message()->::protos::SetplayMessage::MergeFrom(
          from._internal_setplay_message());
      break;
    }
    case kPassRequestMessage: {
      _this->_internal_mutable_pass_request_message()->::protos::PassRequestMessage::MergeFrom(
          from._internal_pass_request_message());
      break;
    }
    case kStaminaMessage: {
      _this->_internal_mutable_stamina_message()->::protos::StaminaMessage::MergeFrom(
          from._internal_stamina_message());
      break;
    }
    case kRecoveryMessage: {
      _this->_internal_mutable_recovery_message()->::protos::RecoveryMessage::MergeFrom(
          from._internal_recovery_message());
      break;
    }
    case kStaminaCapacityMessage: {
      _this->_internal_mutable_stamina_capacity_message()->::protos::StaminaCapacityMessage::MergeFrom(
          from._internal_stamina_capacity_message());
      break;
    }
    case kDribbleMessage: {
      _this->_internal_mutable_dribble_message()->::protos::DribbleMessage::MergeFrom(
          from._internal_dribble_message());
      break;
    }
    case kBallGoalieMessage: {
      _this->_internal_mutable_ball_goalie_message()->::protos::BallGoalieMessage::MergeFrom(
          from._internal_ball_goalie_message());
      break;
    }
    case kOnePlayerMessage: {
      _this->_internal_mutable_one_player_message()->::protos::OnePlayerMessage::MergeFrom(
          from._internal_one_player_message());
      break;
    }
    case kTwoPlayerMessage: {
      _this->_internal_mutable_two_player_message()->::protos::TwoPlayerMessage::MergeFrom(
          from._internal_two_player_message());
      break;
    }
    case kThreePlayerMessage: {
      _this->_internal_mutable_three_player_message()->::protos::ThreePlayerMessage::MergeFrom(
          from._internal_three_player_message());
      break;
    }
    case kSelfMessage: {
      _this->_internal_mutable_self_message()->::protos::SelfMessage::MergeFrom(
          from._internal_self_message());
      break;
    }
    case kTeammateMessage: {
      _this->_internal_mutable_teammate_message()->::protos::TeammateMessage::MergeFrom(
          from._internal_teammate_message());
      break;
    }
    case kOpponentMessage: {
      _this->_internal_mutable_opponent_message()->::protos::OpponentMessage::MergeFrom(
          from._internal_opponent_message());
      break;
    }
    case kBallPlayerMessage: {
      _this->_internal_mutable_ball_player_message()->::protos::BallPlayerMessage::MergeFrom(
          from._internal_ball_player_message());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Say::CopyFrom(const Say& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Say)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Say::IsInitialized() const {
  return true;
}

void Say::InternalSwap(Say* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Say::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[42]);
}
// ===================================================================

class PointTo::_Internal {
 public:
};

PointTo::PointTo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PointTo)
}
PointTo::PointTo(const PointTo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PointTo)
}

inline void PointTo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PointTo::~PointTo() {
  // @@protoc_insertion_point(destructor:protos.PointTo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointTo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointTo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointTo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PointTo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointTo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointTo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PointTo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PointTo)
  return target;
}

::size_t PointTo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PointTo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointTo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointTo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointTo::GetClassData() const { return &_class_data_; }


void PointTo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointTo*>(&to_msg);
  auto& from = static_cast<const PointTo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PointTo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointTo::CopyFrom(const PointTo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PointTo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointTo::IsInitialized() const {
  return true;
}

void PointTo::InternalSwap(PointTo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointTo, _impl_.y_)
      + sizeof(PointTo::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(PointTo, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointTo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[43]);
}
// ===================================================================

class PointToOf::_Internal {
 public:
};

PointToOf::PointToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.PointToOf)
}
PointToOf::PointToOf(const PointToOf& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  PointToOf* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PointToOf)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointToOf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointToOf::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PointToOf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[44]);
}
// ===================================================================

class AttentionTo::_Internal {
 public:
};

AttentionTo::AttentionTo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AttentionTo)
}
AttentionTo::AttentionTo(const AttentionTo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.AttentionTo)
}

inline void AttentionTo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.side_) { 0 }

    , decltype(_impl_.unum_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AttentionTo::~AttentionTo() {
  // @@protoc_insertion_point(destructor:protos.AttentionTo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AttentionTo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AttentionTo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AttentionTo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AttentionTo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.unum_) -
      reinterpret_cast<char*>(&_impl_.side_)) + sizeof(_impl_.unum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AttentionTo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Side side = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 unum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.unum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AttentionTo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AttentionTo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_side(), target);
  }

  // int32 unum = 2;
  if (this->_internal_unum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_unum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AttentionTo)
  return target;
}

::size_t AttentionTo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AttentionTo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 unum = 2;
  if (this->_internal_unum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_unum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttentionTo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AttentionTo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttentionTo::GetClassData() const { return &_class_data_; }


void AttentionTo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AttentionTo*>(&to_msg);
  auto& from = static_cast<const AttentionTo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AttentionTo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_unum() != 0) {
    _this->_internal_set_unum(from._internal_unum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AttentionTo::CopyFrom(const AttentionTo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AttentionTo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttentionTo::IsInitialized() const {
  return true;
}

void AttentionTo::InternalSwap(AttentionTo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttentionTo, _impl_.unum_)
      + sizeof(AttentionTo::_impl_.unum_)
      - PROTOBUF_FIELD_OFFSET(AttentionTo, _impl_.side_)>(
          reinterpret_cast<char*>(&_impl_.side_),
          reinterpret_cast<char*>(&other->_impl_.side_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AttentionTo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[45]);
}
// ===================================================================

class AttentionToOf::_Internal {
 public:
};

AttentionToOf::AttentionToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.AttentionToOf)
}
AttentionToOf::AttentionToOf(const AttentionToOf& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AttentionToOf* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.AttentionToOf)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttentionToOf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttentionToOf::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AttentionToOf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[46]);
}
// ===================================================================

class AddText::_Internal {
 public:
};

AddText::AddText(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddText)
}
AddText::AddText(const AddText& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddText* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , decltype(_impl_.level_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddText)
}

inline void AddText::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , decltype(_impl_.level_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddText::~AddText() {
  // @@protoc_insertion_point(destructor:protos.AddText)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddText::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void AddText::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddText::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddText)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.level_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddText::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddText.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddText::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddText)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  // string message = 2;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddText.message");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddText)
  return target;
}

::size_t AddText::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddText)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 2;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddText::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddText::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddText::GetClassData() const { return &_class_data_; }


void AddText::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddText*>(&to_msg);
  auto& from = static_cast<const AddText&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddText)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddText::CopyFrom(const AddText& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddText)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddText::IsInitialized() const {
  return true;
}

void AddText::InternalSwap(AddText* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
  swap(_impl_.level_, other->_impl_.level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AddText::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[47]);
}
// ===================================================================

class AddPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<AddPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& point(const AddPoint* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddPoint::_Internal::point(const AddPoint* msg) {
  return *msg->_impl_.point_;
}
AddPoint::AddPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddPoint)
}
AddPoint::AddPoint(const AddPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.level_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::protos::Vector2D(*from._impl_.point_);
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddPoint)
}

inline void AddPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.level_) { 0 }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddPoint::~AddPoint() {
  // @@protoc_insertion_point(destructor:protos.AddPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.point_;
}

void AddPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.point_ != nullptr);
    _impl_.point_->Clear();
  }
  _impl_.level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddPoint.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // string color = 3;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddPoint.color");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddPoint)
  return target;
}

::size_t AddPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 3;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D point = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.point_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddPoint::GetClassData() const { return &_class_data_; }


void AddPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddPoint*>(&to_msg);
  auto& from = static_cast<const AddPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_point()->::protos::Vector2D::MergeFrom(
        from._internal_point());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddPoint::CopyFrom(const AddPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddPoint::IsInitialized() const {
  return true;
}

void AddPoint::InternalSwap(AddPoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddPoint, _impl_.level_)
      + sizeof(AddPoint::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(AddPoint, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[48]);
}
// ===================================================================

class AddLine::_Internal {
 public:
  using HasBits = decltype(std::declval<AddLine>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddLine, _impl_._has_bits_);
  static const ::protos::Vector2D& start(const AddLine* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& end(const AddLine* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
AddLine::_Internal::start(const AddLine* msg) {
  return *msg->_impl_.start_;
}
const ::protos::Vector2D&
AddLine::_Internal::end(const AddLine* msg) {
  return *msg->_impl_.end_;
}
AddLine::AddLine(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddLine)
}
AddLine::AddLine(const AddLine& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.level_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.start_ = new ::protos::Vector2D(*from._impl_.start_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.end_ = new ::protos::Vector2D(*from._impl_.end_);
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddLine)
}

inline void AddLine::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.level_) { 0 }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddLine::~AddLine() {
  // @@protoc_insertion_point(destructor:protos.AddLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddLine::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void AddLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddLine::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddLine)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  _impl_.level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddLine.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddLine::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddLine)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D start = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D end = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddLine.color");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddLine)
  return target;
}

::size_t AddLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddLine)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 4;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D start = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // .protos.Vector2D end = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

  }
  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddLine::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddLine::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddLine::GetClassData() const { return &_class_data_; }


void AddLine::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddLine*>(&to_msg);
  auto& from = static_cast<const AddLine&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddLine)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_start()->::protos::Vector2D::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_end()->::protos::Vector2D::MergeFrom(
          from._internal_end());
    }
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddLine::CopyFrom(const AddLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddLine::IsInitialized() const {
  return true;
}

void AddLine::InternalSwap(AddLine* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddLine, _impl_.level_)
      + sizeof(AddLine::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(AddLine, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddLine::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[49]);
}
// ===================================================================

class AddArc::_Internal {
 public:
  using HasBits = decltype(std::declval<AddArc>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddArc, _impl_._has_bits_);
  static const ::protos::Vector2D& center(const AddArc* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddArc::_Internal::center(const AddArc* msg) {
  return *msg->_impl_.center_;
}
AddArc::AddArc(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddArc)
}
AddArc::AddArc(const AddArc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddArc* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.radius_) {}

    , decltype(_impl_.start_angle_) {}

    , decltype(_impl_.span_angel_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.center_ = new ::protos::Vector2D(*from._impl_.center_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.span_angel_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.span_angel_));
  // @@protoc_insertion_point(copy_constructor:protos.AddArc)
}

inline void AddArc::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.radius_) { 0 }

    , decltype(_impl_.start_angle_) { 0 }

    , decltype(_impl_.span_angel_) { 0 }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddArc::~AddArc() {
  // @@protoc_insertion_point(destructor:protos.AddArc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddArc::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.center_;
}

void AddArc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddArc::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddArc)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.center_ != nullptr);
    _impl_.center_->Clear();
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.span_angel_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.span_angel_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddArc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D center = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float start_angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.start_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float span_angel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.span_angel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddArc.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddArc::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddArc)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D center = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::center(this),
        _Internal::center(this).GetCachedSize(), target, stream);
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_radius(), target);
  }

  // float start_angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_start_angle(), target);
  }

  // float span_angel = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_span_angel(), target);
  }

  // string color = 6;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddArc.color");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddArc)
  return target;
}

::size_t AddArc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddArc)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 6;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D center = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.center_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 5;
  }

  // float start_angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    total_size += 5;
  }

  // float span_angel = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddArc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddArc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddArc::GetClassData() const { return &_class_data_; }


void AddArc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddArc*>(&to_msg);
  auto& from = static_cast<const AddArc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddArc)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_center()->::protos::Vector2D::MergeFrom(
        from._internal_center());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = from._internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    _this->_internal_set_start_angle(from._internal_start_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = from._internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    _this->_internal_set_span_angel(from._internal_span_angel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddArc::CopyFrom(const AddArc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddArc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddArc::IsInitialized() const {
  return true;
}

void AddArc::InternalSwap(AddArc* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddArc, _impl_.span_angel_)
      + sizeof(AddArc::_impl_.span_angel_)
      - PROTOBUF_FIELD_OFFSET(AddArc, _impl_.center_)>(
          reinterpret_cast<char*>(&_impl_.center_),
          reinterpret_cast<char*>(&other->_impl_.center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddArc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[50]);
}
// ===================================================================

class AddCircle::_Internal {
 public:
  using HasBits = decltype(std::declval<AddCircle>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddCircle, _impl_._has_bits_);
  static const ::protos::Vector2D& center(const AddCircle* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddCircle::_Internal::center(const AddCircle* msg) {
  return *msg->_impl_.center_;
}
AddCircle::AddCircle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddCircle)
}
AddCircle::AddCircle(const AddCircle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddCircle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.radius_) {}

    , decltype(_impl_.fill_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.center_ = new ::protos::Vector2D(*from._impl_.center_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddCircle)
}

inline void AddCircle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.radius_) { 0 }

    , decltype(_impl_.fill_) { false }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddCircle::~AddCircle() {
  // @@protoc_insertion_point(destructor:protos.AddCircle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddCircle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.center_;
}

void AddCircle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddCircle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddCircle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.center_ != nullptr);
    _impl_.center_->Clear();
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddCircle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D center = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddCircle.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddCircle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddCircle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D center = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::center(this),
        _Internal::center(this).GetCachedSize(), target, stream);
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_radius(), target);
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddCircle.color");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // bool fill = 5;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddCircle)
  return target;
}

::size_t AddCircle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddCircle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 4;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D center = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.center_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 5;
  }

  // bool fill = 5;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddCircle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddCircle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddCircle::GetClassData() const { return &_class_data_; }


void AddCircle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddCircle*>(&to_msg);
  auto& from = static_cast<const AddCircle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddCircle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_center()->::protos::Vector2D::MergeFrom(
        from._internal_center());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddCircle::CopyFrom(const AddCircle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddCircle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddCircle::IsInitialized() const {
  return true;
}

void AddCircle::InternalSwap(AddCircle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddCircle, _impl_.fill_)
      + sizeof(AddCircle::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddCircle, _impl_.center_)>(
          reinterpret_cast<char*>(&_impl_.center_),
          reinterpret_cast<char*>(&other->_impl_.center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddCircle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[51]);
}
// ===================================================================

class AddTriangle::_Internal {
 public:
  using HasBits = decltype(std::declval<AddTriangle>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddTriangle, _impl_._has_bits_);
  static const ::protos::Vector2D& point1(const AddTriangle* msg);
  static void set_has_point1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& point2(const AddTriangle* msg);
  static void set_has_point2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& point3(const AddTriangle* msg);
  static void set_has_point3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
AddTriangle::_Internal::point1(const AddTriangle* msg) {
  return *msg->_impl_.point1_;
}
const ::protos::Vector2D&
AddTriangle::_Internal::point2(const AddTriangle* msg) {
  return *msg->_impl_.point2_;
}
const ::protos::Vector2D&
AddTriangle::_Internal::point3(const AddTriangle* msg) {
  return *msg->_impl_.point3_;
}
AddTriangle::AddTriangle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddTriangle)
}
AddTriangle::AddTriangle(const AddTriangle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddTriangle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point1_){nullptr}
    , decltype(_impl_.point2_){nullptr}
    , decltype(_impl_.point3_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.fill_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point1_ = new ::protos::Vector2D(*from._impl_.point1_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.point2_ = new ::protos::Vector2D(*from._impl_.point2_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.point3_ = new ::protos::Vector2D(*from._impl_.point3_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddTriangle)
}

inline void AddTriangle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point1_){nullptr}
    , decltype(_impl_.point2_){nullptr}
    , decltype(_impl_.point3_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.fill_) { false }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddTriangle::~AddTriangle() {
  // @@protoc_insertion_point(destructor:protos.AddTriangle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddTriangle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.point1_;
  if (this != internal_default_instance()) delete _impl_.point2_;
  if (this != internal_default_instance()) delete _impl_.point3_;
}

void AddTriangle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddTriangle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddTriangle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.point1_ != nullptr);
      _impl_.point1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.point2_ != nullptr);
      _impl_.point2_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.point3_ != nullptr);
      _impl_.point3_->Clear();
    }
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddTriangle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point1(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_point2(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_point3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddTriangle.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddTriangle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddTriangle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D point1 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::point1(this),
        _Internal::point1(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D point2 = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::point2(this),
        _Internal::point2(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D point3 = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::point3(this),
        _Internal::point3(this).GetCachedSize(), target, stream);
  }

  // string color = 5;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddTriangle.color");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // bool fill = 6;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddTriangle)
  return target;
}

::size_t AddTriangle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddTriangle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 5;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D point1 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point1_);
    }

    // .protos.Vector2D point2 = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point2_);
    }

    // .protos.Vector2D point3 = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point3_);
    }

  }
  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // bool fill = 6;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddTriangle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddTriangle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddTriangle::GetClassData() const { return &_class_data_; }


void AddTriangle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddTriangle*>(&to_msg);
  auto& from = static_cast<const AddTriangle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddTriangle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point1()->::protos::Vector2D::MergeFrom(
          from._internal_point1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_point2()->::protos::Vector2D::MergeFrom(
          from._internal_point2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_point3()->::protos::Vector2D::MergeFrom(
          from._internal_point3());
    }
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddTriangle::CopyFrom(const AddTriangle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddTriangle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddTriangle::IsInitialized() const {
  return true;
}

void AddTriangle::InternalSwap(AddTriangle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddTriangle, _impl_.fill_)
      + sizeof(AddTriangle::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddTriangle, _impl_.point1_)>(
          reinterpret_cast<char*>(&_impl_.point1_),
          reinterpret_cast<char*>(&other->_impl_.point1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddTriangle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[52]);
}
// ===================================================================

class AddRectangle::_Internal {
 public:
};

AddRectangle::AddRectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddRectangle)
}
AddRectangle::AddRectangle(const AddRectangle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddRectangle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_) {}

    , decltype(_impl_.level_) {}

    , decltype(_impl_.left_) {}

    , decltype(_impl_.top_) {}

    , decltype(_impl_.length_) {}

    , decltype(_impl_.width_) {}

    , decltype(_impl_.fill_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddRectangle)
}

inline void AddRectangle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.color_) {}

    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.left_) { 0 }

    , decltype(_impl_.top_) { 0 }

    , decltype(_impl_.length_) { 0 }

    , decltype(_impl_.width_) { 0 }

    , decltype(_impl_.fill_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddRectangle::~AddRectangle() {
  // @@protoc_insertion_point(destructor:protos.AddRectangle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddRectangle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
}

void AddRectangle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddRectangle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddRectangle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddRectangle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // float left = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float top = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float width = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddRectangle.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddRectangle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddRectangle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  // float left = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_left = this->_internal_left();
  ::uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_left(), target);
  }

  // float top = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_top = this->_internal_top();
  ::uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_top(), target);
  }

  // float length = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_length = this->_internal_length();
  ::uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_length(), target);
  }

  // float width = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  ::uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_width(), target);
  }

  // string color = 6;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddRectangle.color");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // bool fill = 7;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddRectangle)
  return target;
}

::size_t AddRectangle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddRectangle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 6;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float left = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_left = this->_internal_left();
  ::uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    total_size += 5;
  }

  // float top = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_top = this->_internal_top();
  ::uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    total_size += 5;
  }

  // float length = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_length = this->_internal_length();
  ::uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 5;
  }

  // float width = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  ::uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 5;
  }

  // bool fill = 7;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddRectangle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddRectangle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddRectangle::GetClassData() const { return &_class_data_; }


void AddRectangle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddRectangle*>(&to_msg);
  auto& from = static_cast<const AddRectangle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddRectangle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_left = from._internal_left();
  ::uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    _this->_internal_set_left(from._internal_left());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_top = from._internal_top();
  ::uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    _this->_internal_set_top(from._internal_top());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_length = from._internal_length();
  ::uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_width = from._internal_width();
  ::uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddRectangle::CopyFrom(const AddRectangle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddRectangle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddRectangle::IsInitialized() const {
  return true;
}

void AddRectangle::InternalSwap(AddRectangle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddRectangle, _impl_.fill_)
      + sizeof(AddRectangle::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddRectangle, _impl_.level_)>(
          reinterpret_cast<char*>(&_impl_.level_),
          reinterpret_cast<char*>(&other->_impl_.level_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddRectangle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[53]);
}
// ===================================================================

class AddSector::_Internal {
 public:
  using HasBits = decltype(std::declval<AddSector>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddSector, _impl_._has_bits_);
  static const ::protos::Vector2D& center(const AddSector* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddSector::_Internal::center(const AddSector* msg) {
  return *msg->_impl_.center_;
}
AddSector::AddSector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddSector)
}
AddSector::AddSector(const AddSector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddSector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.min_radius_) {}

    , decltype(_impl_.max_radius_) {}

    , decltype(_impl_.start_angle_) {}

    , decltype(_impl_.span_angel_) {}

    , decltype(_impl_.fill_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.center_ = new ::protos::Vector2D(*from._impl_.center_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddSector)
}

inline void AddSector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.min_radius_) { 0 }

    , decltype(_impl_.max_radius_) { 0 }

    , decltype(_impl_.start_angle_) { 0 }

    , decltype(_impl_.span_angel_) { 0 }

    , decltype(_impl_.fill_) { false }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddSector::~AddSector() {
  // @@protoc_insertion_point(destructor:protos.AddSector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddSector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.center_;
}

void AddSector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddSector::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddSector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.center_ != nullptr);
    _impl_.center_->Clear();
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddSector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D center = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.min_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.max_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float start_angle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.start_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float span_angel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.span_angel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddSector.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddSector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddSector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D center = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::center(this),
        _Internal::center(this).GetCachedSize(), target, stream);
  }

  // float min_radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_radius = this->_internal_min_radius();
  ::uint32_t raw_min_radius;
  memcpy(&raw_min_radius, &tmp_min_radius, sizeof(tmp_min_radius));
  if (raw_min_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_min_radius(), target);
  }

  // float max_radius = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_radius = this->_internal_max_radius();
  ::uint32_t raw_max_radius;
  memcpy(&raw_max_radius, &tmp_max_radius, sizeof(tmp_max_radius));
  if (raw_max_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_max_radius(), target);
  }

  // float start_angle = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_start_angle(), target);
  }

  // float span_angel = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_span_angel(), target);
  }

  // string color = 7;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddSector.color");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // bool fill = 8;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddSector)
  return target;
}

::size_t AddSector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddSector)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 7;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D center = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.center_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float min_radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_radius = this->_internal_min_radius();
  ::uint32_t raw_min_radius;
  memcpy(&raw_min_radius, &tmp_min_radius, sizeof(tmp_min_radius));
  if (raw_min_radius != 0) {
    total_size += 5;
  }

  // float max_radius = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_radius = this->_internal_max_radius();
  ::uint32_t raw_max_radius;
  memcpy(&raw_max_radius, &tmp_max_radius, sizeof(tmp_max_radius));
  if (raw_max_radius != 0) {
    total_size += 5;
  }

  // float start_angle = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    total_size += 5;
  }

  // float span_angel = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    total_size += 5;
  }

  // bool fill = 8;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddSector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddSector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddSector::GetClassData() const { return &_class_data_; }


void AddSector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddSector*>(&to_msg);
  auto& from = static_cast<const AddSector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddSector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_center()->::protos::Vector2D::MergeFrom(
        from._internal_center());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_radius = from._internal_min_radius();
  ::uint32_t raw_min_radius;
  memcpy(&raw_min_radius, &tmp_min_radius, sizeof(tmp_min_radius));
  if (raw_min_radius != 0) {
    _this->_internal_set_min_radius(from._internal_min_radius());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_radius = from._internal_max_radius();
  ::uint32_t raw_max_radius;
  memcpy(&raw_max_radius, &tmp_max_radius, sizeof(tmp_max_radius));
  if (raw_max_radius != 0) {
    _this->_internal_set_max_radius(from._internal_max_radius());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = from._internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    _this->_internal_set_start_angle(from._internal_start_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = from._internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    _this->_internal_set_span_angel(from._internal_span_angel());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddSector::CopyFrom(const AddSector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddSector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddSector::IsInitialized() const {
  return true;
}

void AddSector::InternalSwap(AddSector* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddSector, _impl_.fill_)
      + sizeof(AddSector::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddSector, _impl_.center_)>(
          reinterpret_cast<char*>(&_impl_.center_),
          reinterpret_cast<char*>(&other->_impl_.center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddSector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[54]);
}
// ===================================================================

class AddMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AddMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const AddMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddMessage::_Internal::position(const AddMessage* msg) {
  return *msg->_impl_.position_;
}
AddMessage::AddMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddMessage)
}
AddMessage::AddMessage(const AddMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_) {}

    , decltype(_impl_.color_) {}

    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.level_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddMessage)
}

inline void AddMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_) {}

    , decltype(_impl_.color_) {}

    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.level_) { 0 }

  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddMessage::~AddMessage() {
  // @@protoc_insertion_point(destructor:protos.AddMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void AddMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_.level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddMessage.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddMessage.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // string message = 3;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddMessage.message");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddMessage.color");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddMessage)
  return target;
}

::size_t AddMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 3;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddMessage::GetClassData() const { return &_class_data_; }


void AddMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddMessage*>(&to_msg);
  auto& from = static_cast<const AddMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddMessage::CopyFrom(const AddMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddMessage::IsInitialized() const {
  return true;
}

void AddMessage::InternalSwap(AddMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddMessage, _impl_.level_)
      + sizeof(AddMessage::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(AddMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[55]);
}
// ===================================================================

class Log::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::Log, _impl_._oneof_case_);
  static const ::protos::AddText& add_text(const Log* msg);
  static const ::protos::AddPoint& add_point(const Log* msg);
  static const ::protos::AddLine& add_line(const Log* msg);
  static const ::protos::AddArc& add_arc(const Log* msg);
  static const ::protos::AddCircle& add_circle(const Log* msg);
  static const ::protos::AddTriangle& add_triangle(const Log* msg);
  static const ::protos::AddRectangle& add_rectangle(const Log* msg);
  static const ::protos::AddSector& add_sector(const Log* msg);
  static const ::protos::AddMessage& add_message(const Log* msg);
};

const ::protos::AddText&
Log::_Internal::add_text(const Log* msg) {
  return *msg->_impl_.log_.add_text_;
}
const ::protos::AddPoint&
Log::_Internal::add_point(const Log* msg) {
  return *msg->_impl_.log_.add_point_;
}
const ::protos::AddLine&
Log::_Internal::add_line(const Log* msg) {
  return *msg->_impl_.log_.add_line_;
}
const ::protos::AddArc&
Log::_Internal::add_arc(const Log* msg) {
  return *msg->_impl_.log_.add_arc_;
}
const ::protos::AddCircle&
Log::_Internal::add_circle(const Log* msg) {
  return *msg->_impl_.log_.add_circle_;
}
const ::protos::AddTriangle&
Log::_Internal::add_triangle(const Log* msg) {
  return *msg->_impl_.log_.add_triangle_;
}
const ::protos::AddRectangle&
Log::_Internal::add_rectangle(const Log* msg) {
  return *msg->_impl_.log_.add_rectangle_;
}
const ::protos::AddSector&
Log::_Internal::add_sector(const Log* msg) {
  return *msg->_impl_.log_.add_sector_;
}
const ::protos::AddMessage&
Log::_Internal::add_message(const Log* msg) {
  return *msg->_impl_.log_.add_message_;
}
void Log::set_allocated_add_text(::protos::AddText* add_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_text);
    if (message_arena != submessage_arena) {
      add_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_text, submessage_arena);
    }
    set_has_add_text();
    _impl_.log_.add_text_ = add_text;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_text)
}
void Log::set_allocated_add_point(::protos::AddPoint* add_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_point);
    if (message_arena != submessage_arena) {
      add_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_point, submessage_arena);
    }
    set_has_add_point();
    _impl_.log_.add_point_ = add_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_point)
}
void Log::set_allocated_add_line(::protos::AddLine* add_line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_line);
    if (message_arena != submessage_arena) {
      add_line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_line, submessage_arena);
    }
    set_has_add_line();
    _impl_.log_.add_line_ = add_line;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_line)
}
void Log::set_allocated_add_arc(::protos::AddArc* add_arc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_arc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_arc);
    if (message_arena != submessage_arena) {
      add_arc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_arc, submessage_arena);
    }
    set_has_add_arc();
    _impl_.log_.add_arc_ = add_arc;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_arc)
}
void Log::set_allocated_add_circle(::protos::AddCircle* add_circle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_circle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_circle);
    if (message_arena != submessage_arena) {
      add_circle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_circle, submessage_arena);
    }
    set_has_add_circle();
    _impl_.log_.add_circle_ = add_circle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_circle)
}
void Log::set_allocated_add_triangle(::protos::AddTriangle* add_triangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_triangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_triangle);
    if (message_arena != submessage_arena) {
      add_triangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_triangle, submessage_arena);
    }
    set_has_add_triangle();
    _impl_.log_.add_triangle_ = add_triangle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_triangle)
}
void Log::set_allocated_add_rectangle(::protos::AddRectangle* add_rectangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_rectangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_rectangle);
    if (message_arena != submessage_arena) {
      add_rectangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_rectangle, submessage_arena);
    }
    set_has_add_rectangle();
    _impl_.log_.add_rectangle_ = add_rectangle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_rectangle)
}
void Log::set_allocated_add_sector(::protos::AddSector* add_sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_sector);
    if (message_arena != submessage_arena) {
      add_sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_sector, submessage_arena);
    }
    set_has_add_sector();
    _impl_.log_.add_sector_ = add_sector;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_sector)
}
void Log::set_allocated_add_message(::protos::AddMessage* add_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_message);
    if (message_arena != submessage_arena) {
      add_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_message, submessage_arena);
    }
    set_has_add_message();
    _impl_.log_.add_message_ = add_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_message)
}
Log::Log(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Log)
}
Log::Log(const Log& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Log* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.log_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_log();
  switch (from.log_case()) {
    case kAddText: {
      _this->_internal_mutable_add_text()->::protos::AddText::MergeFrom(
          from._internal_add_text());
      break;
    }
    case kAddPoint: {
      _this->_internal_mutable_add_point()->::protos::AddPoint::MergeFrom(
          from._internal_add_point());
      break;
    }
    case kAddLine: {
      _this->_internal_mutable_add_line()->::protos::AddLine::MergeFrom(
          from._internal_add_line());
      break;
    }
    case kAddArc: {
      _this->_internal_mutable_add_arc()->::protos::AddArc::MergeFrom(
          from._internal_add_arc());
      break;
    }
    case kAddCircle: {
      _this->_internal_mutable_add_circle()->::protos::AddCircle::MergeFrom(
          from._internal_add_circle());
      break;
    }
    case kAddTriangle: {
      _this->_internal_mutable_add_triangle()->::protos::AddTriangle::MergeFrom(
          from._internal_add_triangle());
      break;
    }
    case kAddRectangle: {
      _this->_internal_mutable_add_rectangle()->::protos::AddRectangle::MergeFrom(
          from._internal_add_rectangle());
      break;
    }
    case kAddSector: {
      _this->_internal_mutable_add_sector()->::protos::AddSector::MergeFrom(
          from._internal_add_sector());
      break;
    }
    case kAddMessage: {
      _this->_internal_mutable_add_message()->::protos::AddMessage::MergeFrom(
          from._internal_add_message());
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.Log)
}

inline void Log::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.log_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_log();
}

Log::~Log() {
  // @@protoc_insertion_point(destructor:protos.Log)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Log::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_log()) {
    clear_log();
  }
}

void Log::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Log::clear_log() {
// @@protoc_insertion_point(one_of_clear_start:protos.Log)
  switch (log_case()) {
    case kAddText: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_text_;
      }
      break;
    }
    case kAddPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_point_;
      }
      break;
    }
    case kAddLine: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_line_;
      }
      break;
    }
    case kAddArc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_arc_;
      }
      break;
    }
    case kAddCircle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_circle_;
      }
      break;
    }
    case kAddTriangle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_triangle_;
      }
      break;
    }
    case kAddRectangle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_rectangle_;
      }
      break;
    }
    case kAddSector: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_sector_;
      }
      break;
    }
    case kAddMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_message_;
      }
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LOG_NOT_SET;
}


void Log::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Log)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_log();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Log::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.AddText add_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddPoint add_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddLine add_line = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_line(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddArc add_arc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_arc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddCircle add_circle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_circle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddTriangle add_triangle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_triangle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddRectangle add_rectangle = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_rectangle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddSector add_sector = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_sector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddMessage add_message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Log::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Log)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (log_case()) {
    case kAddText: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::add_text(this),
          _Internal::add_text(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::add_point(this),
          _Internal::add_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddLine: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::add_line(this),
          _Internal::add_line(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddArc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::add_arc(this),
          _Internal::add_arc(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddCircle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::add_circle(this),
          _Internal::add_circle(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddTriangle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::add_triangle(this),
          _Internal::add_triangle(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddRectangle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::add_rectangle(this),
          _Internal::add_rectangle(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddSector: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::add_sector(this),
          _Internal::add_sector(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::add_message(this),
          _Internal::add_message(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Log)
  return target;
}

::size_t Log::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Log)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (log_case()) {
    // .protos.AddText add_text = 1;
    case kAddText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_text_);
      break;
    }
    // .protos.AddPoint add_point = 2;
    case kAddPoint: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_point_);
      break;
    }
    // .protos.AddLine add_line = 3;
    case kAddLine: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_line_);
      break;
    }
    // .protos.AddArc add_arc = 4;
    case kAddArc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_arc_);
      break;
    }
    // .protos.AddCircle add_circle = 5;
    case kAddCircle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_circle_);
      break;
    }
    // .protos.AddTriangle add_triangle = 6;
    case kAddTriangle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_triangle_);
      break;
    }
    // .protos.AddRectangle add_rectangle = 7;
    case kAddRectangle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_rectangle_);
      break;
    }
    // .protos.AddSector add_sector = 8;
    case kAddSector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_sector_);
      break;
    }
    // .protos.AddMessage add_message = 9;
    case kAddMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_message_);
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Log::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Log::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Log::GetClassData() const { return &_class_data_; }


void Log::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Log*>(&to_msg);
  auto& from = static_cast<const Log&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Log)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.log_case()) {
    case kAddText: {
      _this->_internal_mutable_add_text()->::protos::AddText::MergeFrom(
          from._internal_add_text());
      break;
    }
    case kAddPoint: {
      _this->_internal_mutable_add_point()->::protos::AddPoint::MergeFrom(
          from._internal_add_point());
      break;
    }
    case kAddLine: {
      _this->_internal_mutable_add_line()->::protos::AddLine::MergeFrom(
          from._internal_add_line());
      break;
    }
    case kAddArc: {
      _this->_internal_mutable_add_arc()->::protos::AddArc::MergeFrom(
          from._internal_add_arc());
      break;
    }
    case kAddCircle: {
      _this->_internal_mutable_add_circle()->::protos::AddCircle::MergeFrom(
          from._internal_add_circle());
      break;
    }
    case kAddTriangle: {
      _this->_internal_mutable_add_triangle()->::protos::AddTriangle::MergeFrom(
          from._internal_add_triangle());
      break;
    }
    case kAddRectangle: {
      _this->_internal_mutable_add_rectangle()->::protos::AddRectangle::MergeFrom(
          from._internal_add_rectangle());
      break;
    }
    case kAddSector: {
      _this->_internal_mutable_add_sector()->::protos::AddSector::MergeFrom(
          from._internal_add_sector());
      break;
    }
    case kAddMessage: {
      _this->_internal_mutable_add_message()->::protos::AddMessage::MergeFrom(
          from._internal_add_message());
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Log::CopyFrom(const Log& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Log)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Log::IsInitialized() const {
  return true;
}

void Log::InternalSwap(Log* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.log_, other->_impl_.log_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Log::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[56]);
}
// ===================================================================

class DebugClient::_Internal {
 public:
};

DebugClient::DebugClient(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DebugClient)
}
DebugClient::DebugClient(const DebugClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DebugClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protos.DebugClient)
}

inline void DebugClient::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DebugClient::~DebugClient() {
  // @@protoc_insertion_point(destructor:protos.DebugClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DebugClient::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void DebugClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DebugClient::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DebugClient)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DebugClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.DebugClient.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DebugClient::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DebugClient)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.DebugClient.message");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DebugClient)
  return target;
}

::size_t DebugClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DebugClient)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DebugClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DebugClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DebugClient::GetClassData() const { return &_class_data_; }


void DebugClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DebugClient*>(&to_msg);
  auto& from = static_cast<const DebugClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DebugClient)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DebugClient::CopyFrom(const DebugClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DebugClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugClient::IsInitialized() const {
  return true;
}

void DebugClient::InternalSwap(DebugClient* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata DebugClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[57]);
}
// ===================================================================

class Body_GoToPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_GoToPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_GoToPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Body_GoToPoint* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_GoToPoint::_Internal::target_point(const Body_GoToPoint* msg) {
  return *msg->_impl_.target_point_;
}
Body_GoToPoint::Body_GoToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_GoToPoint)
}
Body_GoToPoint::Body_GoToPoint(const Body_GoToPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_GoToPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.distance_threshold_) {}

    , decltype(_impl_.max_dash_power_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  ::memcpy(&_impl_.distance_threshold_, &from._impl_.distance_threshold_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.max_dash_power_) -
    reinterpret_cast<char*>(&_impl_.distance_threshold_)) + sizeof(_impl_.max_dash_power_));
  // @@protoc_insertion_point(copy_constructor:protos.Body_GoToPoint)
}

inline void Body_GoToPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.distance_threshold_) { 0 }

    , decltype(_impl_.max_dash_power_) { 0 }

  };
}

Body_GoToPoint::~Body_GoToPoint() {
  // @@protoc_insertion_point(destructor:protos.Body_GoToPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_GoToPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Body_GoToPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_GoToPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_GoToPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  ::memset(&_impl_.distance_threshold_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_dash_power_) -
      reinterpret_cast<char*>(&_impl_.distance_threshold_)) + sizeof(_impl_.max_dash_power_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_GoToPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float distance_threshold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.distance_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_dash_power = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.max_dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_GoToPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_GoToPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // float distance_threshold = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = this->_internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_distance_threshold(), target);
  }

  // float max_dash_power = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = this->_internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_max_dash_power(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_GoToPoint)
  return target;
}

::size_t Body_GoToPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_GoToPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // float distance_threshold = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = this->_internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    total_size += 5;
  }

  // float max_dash_power = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = this->_internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_GoToPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_GoToPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_GoToPoint::GetClassData() const { return &_class_data_; }


void Body_GoToPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_GoToPoint*>(&to_msg);
  auto& from = static_cast<const Body_GoToPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_GoToPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = from._internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    _this->_internal_set_distance_threshold(from._internal_distance_threshold());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = from._internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    _this->_internal_set_max_dash_power(from._internal_max_dash_power());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_GoToPoint::CopyFrom(const Body_GoToPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_GoToPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_GoToPoint::IsInitialized() const {
  return true;
}

void Body_GoToPoint::InternalSwap(Body_GoToPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_GoToPoint, _impl_.max_dash_power_)
      + sizeof(Body_GoToPoint::_impl_.max_dash_power_)
      - PROTOBUF_FIELD_OFFSET(Body_GoToPoint, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_GoToPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[58]);
}
// ===================================================================

class Body_SmartKick::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_SmartKick>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_SmartKick, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Body_SmartKick* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_SmartKick::_Internal::target_point(const Body_SmartKick* msg) {
  return *msg->_impl_.target_point_;
}
Body_SmartKick::Body_SmartKick(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_SmartKick)
}
Body_SmartKick::Body_SmartKick(const Body_SmartKick& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_SmartKick* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.first_speed_) {}

    , decltype(_impl_.first_speed_threshold_) {}

    , decltype(_impl_.max_steps_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  ::memcpy(&_impl_.first_speed_, &from._impl_.first_speed_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.max_steps_) -
    reinterpret_cast<char*>(&_impl_.first_speed_)) + sizeof(_impl_.max_steps_));
  // @@protoc_insertion_point(copy_constructor:protos.Body_SmartKick)
}

inline void Body_SmartKick::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.first_speed_) { 0 }

    , decltype(_impl_.first_speed_threshold_) { 0 }

    , decltype(_impl_.max_steps_) { 0 }

  };
}

Body_SmartKick::~Body_SmartKick() {
  // @@protoc_insertion_point(destructor:protos.Body_SmartKick)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_SmartKick::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Body_SmartKick::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_SmartKick::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_SmartKick)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  ::memset(&_impl_.first_speed_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_steps_) -
      reinterpret_cast<char*>(&_impl_.first_speed_)) + sizeof(_impl_.max_steps_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_SmartKick::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float first_speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.first_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float first_speed_threshold = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.first_speed_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 max_steps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.max_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_SmartKick::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_SmartKick)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // float first_speed = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed = this->_internal_first_speed();
  ::uint32_t raw_first_speed;
  memcpy(&raw_first_speed, &tmp_first_speed, sizeof(tmp_first_speed));
  if (raw_first_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_first_speed(), target);
  }

  // float first_speed_threshold = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed_threshold = this->_internal_first_speed_threshold();
  ::uint32_t raw_first_speed_threshold;
  memcpy(&raw_first_speed_threshold, &tmp_first_speed_threshold, sizeof(tmp_first_speed_threshold));
  if (raw_first_speed_threshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_first_speed_threshold(), target);
  }

  // int32 max_steps = 4;
  if (this->_internal_max_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_max_steps(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_SmartKick)
  return target;
}

::size_t Body_SmartKick::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_SmartKick)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // float first_speed = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed = this->_internal_first_speed();
  ::uint32_t raw_first_speed;
  memcpy(&raw_first_speed, &tmp_first_speed, sizeof(tmp_first_speed));
  if (raw_first_speed != 0) {
    total_size += 5;
  }

  // float first_speed_threshold = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed_threshold = this->_internal_first_speed_threshold();
  ::uint32_t raw_first_speed_threshold;
  memcpy(&raw_first_speed_threshold, &tmp_first_speed_threshold, sizeof(tmp_first_speed_threshold));
  if (raw_first_speed_threshold != 0) {
    total_size += 5;
  }

  // int32 max_steps = 4;
  if (this->_internal_max_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_max_steps());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_SmartKick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_SmartKick::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_SmartKick::GetClassData() const { return &_class_data_; }


void Body_SmartKick::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_SmartKick*>(&to_msg);
  auto& from = static_cast<const Body_SmartKick&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_SmartKick)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed = from._internal_first_speed();
  ::uint32_t raw_first_speed;
  memcpy(&raw_first_speed, &tmp_first_speed, sizeof(tmp_first_speed));
  if (raw_first_speed != 0) {
    _this->_internal_set_first_speed(from._internal_first_speed());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed_threshold = from._internal_first_speed_threshold();
  ::uint32_t raw_first_speed_threshold;
  memcpy(&raw_first_speed_threshold, &tmp_first_speed_threshold, sizeof(tmp_first_speed_threshold));
  if (raw_first_speed_threshold != 0) {
    _this->_internal_set_first_speed_threshold(from._internal_first_speed_threshold());
  }
  if (from._internal_max_steps() != 0) {
    _this->_internal_set_max_steps(from._internal_max_steps());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_SmartKick::CopyFrom(const Body_SmartKick& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_SmartKick)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_SmartKick::IsInitialized() const {
  return true;
}

void Body_SmartKick::InternalSwap(Body_SmartKick* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_SmartKick, _impl_.max_steps_)
      + sizeof(Body_SmartKick::_impl_.max_steps_)
      - PROTOBUF_FIELD_OFFSET(Body_SmartKick, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_SmartKick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[59]);
}
// ===================================================================

class Bhv_BeforeKickOff::_Internal {
 public:
  using HasBits = decltype(std::declval<Bhv_BeforeKickOff>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Bhv_BeforeKickOff, _impl_._has_bits_);
  static const ::protos::Vector2D& point(const Bhv_BeforeKickOff* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Bhv_BeforeKickOff::_Internal::point(const Bhv_BeforeKickOff* msg) {
  return *msg->_impl_.point_;
}
Bhv_BeforeKickOff::Bhv_BeforeKickOff(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_BeforeKickOff)
}
Bhv_BeforeKickOff::Bhv_BeforeKickOff(const Bhv_BeforeKickOff& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Bhv_BeforeKickOff* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::protos::Vector2D(*from._impl_.point_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_BeforeKickOff)
}

inline void Bhv_BeforeKickOff::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
  };
}

Bhv_BeforeKickOff::~Bhv_BeforeKickOff() {
  // @@protoc_insertion_point(destructor:protos.Bhv_BeforeKickOff)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Bhv_BeforeKickOff::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
}

void Bhv_BeforeKickOff::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Bhv_BeforeKickOff::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Bhv_BeforeKickOff)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.point_ != nullptr);
    _impl_.point_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bhv_BeforeKickOff::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Bhv_BeforeKickOff::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Bhv_BeforeKickOff)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Bhv_BeforeKickOff)
  return target;
}

::size_t Bhv_BeforeKickOff::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Bhv_BeforeKickOff)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.point_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_BeforeKickOff::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Bhv_BeforeKickOff::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_BeforeKickOff::GetClassData() const { return &_class_data_; }


void Bhv_BeforeKickOff::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Bhv_BeforeKickOff*>(&to_msg);
  auto& from = static_cast<const Bhv_BeforeKickOff&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Bhv_BeforeKickOff)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_point()->::protos::Vector2D::MergeFrom(
        from._internal_point());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bhv_BeforeKickOff::CopyFrom(const Bhv_BeforeKickOff& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Bhv_BeforeKickOff)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bhv_BeforeKickOff::IsInitialized() const {
  return true;
}

void Bhv_BeforeKickOff::InternalSwap(Bhv_BeforeKickOff* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.point_, other->_impl_.point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Bhv_BeforeKickOff::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[60]);
}
// ===================================================================

class Bhv_BodyNeckToBall::_Internal {
 public:
};

Bhv_BodyNeckToBall::Bhv_BodyNeckToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_BodyNeckToBall)
}
Bhv_BodyNeckToBall::Bhv_BodyNeckToBall(const Bhv_BodyNeckToBall& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Bhv_BodyNeckToBall* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_BodyNeckToBall)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_BodyNeckToBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_BodyNeckToBall::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Bhv_BodyNeckToBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[61]);
}
// ===================================================================

class Bhv_BodyNeckToPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Bhv_BodyNeckToPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Bhv_BodyNeckToPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& point(const Bhv_BodyNeckToPoint* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Bhv_BodyNeckToPoint::_Internal::point(const Bhv_BodyNeckToPoint* msg) {
  return *msg->_impl_.point_;
}
Bhv_BodyNeckToPoint::Bhv_BodyNeckToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_BodyNeckToPoint)
}
Bhv_BodyNeckToPoint::Bhv_BodyNeckToPoint(const Bhv_BodyNeckToPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Bhv_BodyNeckToPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::protos::Vector2D(*from._impl_.point_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_BodyNeckToPoint)
}

inline void Bhv_BodyNeckToPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
  };
}

Bhv_BodyNeckToPoint::~Bhv_BodyNeckToPoint() {
  // @@protoc_insertion_point(destructor:protos.Bhv_BodyNeckToPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Bhv_BodyNeckToPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
}

void Bhv_BodyNeckToPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Bhv_BodyNeckToPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Bhv_BodyNeckToPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.point_ != nullptr);
    _impl_.point_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bhv_BodyNeckToPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Bhv_BodyNeckToPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Bhv_BodyNeckToPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Bhv_BodyNeckToPoint)
  return target;
}

::size_t Bhv_BodyNeckToPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Bhv_BodyNeckToPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.point_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_BodyNeckToPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Bhv_BodyNeckToPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_BodyNeckToPoint::GetClassData() const { return &_class_data_; }


void Bhv_BodyNeckToPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Bhv_BodyNeckToPoint*>(&to_msg);
  auto& from = static_cast<const Bhv_BodyNeckToPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Bhv_BodyNeckToPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_point()->::protos::Vector2D::MergeFrom(
        from._internal_point());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bhv_BodyNeckToPoint::CopyFrom(const Bhv_BodyNeckToPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Bhv_BodyNeckToPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bhv_BodyNeckToPoint::IsInitialized() const {
  return true;
}

void Bhv_BodyNeckToPoint::InternalSwap(Bhv_BodyNeckToPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.point_, other->_impl_.point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Bhv_BodyNeckToPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[62]);
}
// ===================================================================

class Bhv_Emergency::_Internal {
 public:
};

Bhv_Emergency::Bhv_Emergency(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_Emergency)
}
Bhv_Emergency::Bhv_Emergency(const Bhv_Emergency& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Bhv_Emergency* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_Emergency)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_Emergency::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_Emergency::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Bhv_Emergency::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[63]);
}
// ===================================================================

class Bhv_GoToPointLookBall::_Internal {
 public:
  using HasBits = decltype(std::declval<Bhv_GoToPointLookBall>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Bhv_GoToPointLookBall, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Bhv_GoToPointLookBall* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Bhv_GoToPointLookBall::_Internal::target_point(const Bhv_GoToPointLookBall* msg) {
  return *msg->_impl_.target_point_;
}
Bhv_GoToPointLookBall::Bhv_GoToPointLookBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_GoToPointLookBall)
}
Bhv_GoToPointLookBall::Bhv_GoToPointLookBall(const Bhv_GoToPointLookBall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Bhv_GoToPointLookBall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.distance_threshold_) {}

    , decltype(_impl_.max_dash_power_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  ::memcpy(&_impl_.distance_threshold_, &from._impl_.distance_threshold_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.max_dash_power_) -
    reinterpret_cast<char*>(&_impl_.distance_threshold_)) + sizeof(_impl_.max_dash_power_));
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_GoToPointLookBall)
}

inline void Bhv_GoToPointLookBall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.distance_threshold_) { 0 }

    , decltype(_impl_.max_dash_power_) { 0 }

  };
}

Bhv_GoToPointLookBall::~Bhv_GoToPointLookBall() {
  // @@protoc_insertion_point(destructor:protos.Bhv_GoToPointLookBall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Bhv_GoToPointLookBall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Bhv_GoToPointLookBall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Bhv_GoToPointLookBall::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Bhv_GoToPointLookBall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  ::memset(&_impl_.distance_threshold_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_dash_power_) -
      reinterpret_cast<char*>(&_impl_.distance_threshold_)) + sizeof(_impl_.max_dash_power_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bhv_GoToPointLookBall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float distance_threshold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.distance_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_dash_power = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.max_dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Bhv_GoToPointLookBall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Bhv_GoToPointLookBall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // float distance_threshold = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = this->_internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_distance_threshold(), target);
  }

  // float max_dash_power = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = this->_internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_max_dash_power(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Bhv_GoToPointLookBall)
  return target;
}

::size_t Bhv_GoToPointLookBall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Bhv_GoToPointLookBall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // float distance_threshold = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = this->_internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    total_size += 5;
  }

  // float max_dash_power = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = this->_internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_GoToPointLookBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Bhv_GoToPointLookBall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_GoToPointLookBall::GetClassData() const { return &_class_data_; }


void Bhv_GoToPointLookBall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Bhv_GoToPointLookBall*>(&to_msg);
  auto& from = static_cast<const Bhv_GoToPointLookBall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Bhv_GoToPointLookBall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = from._internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    _this->_internal_set_distance_threshold(from._internal_distance_threshold());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = from._internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    _this->_internal_set_max_dash_power(from._internal_max_dash_power());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bhv_GoToPointLookBall::CopyFrom(const Bhv_GoToPointLookBall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Bhv_GoToPointLookBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bhv_GoToPointLookBall::IsInitialized() const {
  return true;
}

void Bhv_GoToPointLookBall::InternalSwap(Bhv_GoToPointLookBall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Bhv_GoToPointLookBall, _impl_.max_dash_power_)
      + sizeof(Bhv_GoToPointLookBall::_impl_.max_dash_power_)
      - PROTOBUF_FIELD_OFFSET(Bhv_GoToPointLookBall, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Bhv_GoToPointLookBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[64]);
}
// ===================================================================

class Bhv_NeckBodyToBall::_Internal {
 public:
};

Bhv_NeckBodyToBall::Bhv_NeckBodyToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_NeckBodyToBall)
}
Bhv_NeckBodyToBall::Bhv_NeckBodyToBall(const Bhv_NeckBodyToBall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_NeckBodyToBall)
}

inline void Bhv_NeckBodyToBall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.angle_buf_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Bhv_NeckBodyToBall::~Bhv_NeckBodyToBall() {
  // @@protoc_insertion_point(destructor:protos.Bhv_NeckBodyToBall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Bhv_NeckBodyToBall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Bhv_NeckBodyToBall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Bhv_NeckBodyToBall::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Bhv_NeckBodyToBall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.angle_buf_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bhv_NeckBodyToBall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float angle_buf = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.angle_buf_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Bhv_NeckBodyToBall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Bhv_NeckBodyToBall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float angle_buf = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_buf = this->_internal_angle_buf();
  ::uint32_t raw_angle_buf;
  memcpy(&raw_angle_buf, &tmp_angle_buf, sizeof(tmp_angle_buf));
  if (raw_angle_buf != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_angle_buf(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Bhv_NeckBodyToBall)
  return target;
}

::size_t Bhv_NeckBodyToBall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Bhv_NeckBodyToBall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float angle_buf = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_buf = this->_internal_angle_buf();
  ::uint32_t raw_angle_buf;
  memcpy(&raw_angle_buf, &tmp_angle_buf, sizeof(tmp_angle_buf));
  if (raw_angle_buf != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_NeckBodyToBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Bhv_NeckBodyToBall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_NeckBodyToBall::GetClassData() const { return &_class_data_; }


void Bhv_NeckBodyToBall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Bhv_NeckBodyToBall*>(&to_msg);
  auto& from = static_cast<const Bhv_NeckBodyToBall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Bhv_NeckBodyToBall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_buf = from._internal_angle_buf();
  ::uint32_t raw_angle_buf;
  memcpy(&raw_angle_buf, &tmp_angle_buf, sizeof(tmp_angle_buf));
  if (raw_angle_buf != 0) {
    _this->_internal_set_angle_buf(from._internal_angle_buf());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bhv_NeckBodyToBall::CopyFrom(const Bhv_NeckBodyToBall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Bhv_NeckBodyToBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bhv_NeckBodyToBall::IsInitialized() const {
  return true;
}

void Bhv_NeckBodyToBall::InternalSwap(Bhv_NeckBodyToBall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.angle_buf_, other->_impl_.angle_buf_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Bhv_NeckBodyToBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[65]);
}
// ===================================================================

class Bhv_NeckBodyToPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Bhv_NeckBodyToPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Bhv_NeckBodyToPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& point(const Bhv_NeckBodyToPoint* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Bhv_NeckBodyToPoint::_Internal::point(const Bhv_NeckBodyToPoint* msg) {
  return *msg->_impl_.point_;
}
Bhv_NeckBodyToPoint::Bhv_NeckBodyToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_NeckBodyToPoint)
}
Bhv_NeckBodyToPoint::Bhv_NeckBodyToPoint(const Bhv_NeckBodyToPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Bhv_NeckBodyToPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.angle_buf_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::protos::Vector2D(*from._impl_.point_);
  }
  _this->_impl_.angle_buf_ = from._impl_.angle_buf_;
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_NeckBodyToPoint)
}

inline void Bhv_NeckBodyToPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.angle_buf_) { 0 }

  };
}

Bhv_NeckBodyToPoint::~Bhv_NeckBodyToPoint() {
  // @@protoc_insertion_point(destructor:protos.Bhv_NeckBodyToPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Bhv_NeckBodyToPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
}

void Bhv_NeckBodyToPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Bhv_NeckBodyToPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Bhv_NeckBodyToPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.point_ != nullptr);
    _impl_.point_->Clear();
  }
  _impl_.angle_buf_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bhv_NeckBodyToPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_buf = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.angle_buf_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Bhv_NeckBodyToPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Bhv_NeckBodyToPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // float angle_buf = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_buf = this->_internal_angle_buf();
  ::uint32_t raw_angle_buf;
  memcpy(&raw_angle_buf, &tmp_angle_buf, sizeof(tmp_angle_buf));
  if (raw_angle_buf != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_angle_buf(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Bhv_NeckBodyToPoint)
  return target;
}

::size_t Bhv_NeckBodyToPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Bhv_NeckBodyToPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.point_);
  }

  // float angle_buf = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_buf = this->_internal_angle_buf();
  ::uint32_t raw_angle_buf;
  memcpy(&raw_angle_buf, &tmp_angle_buf, sizeof(tmp_angle_buf));
  if (raw_angle_buf != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_NeckBodyToPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Bhv_NeckBodyToPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_NeckBodyToPoint::GetClassData() const { return &_class_data_; }


void Bhv_NeckBodyToPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Bhv_NeckBodyToPoint*>(&to_msg);
  auto& from = static_cast<const Bhv_NeckBodyToPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Bhv_NeckBodyToPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_point()->::protos::Vector2D::MergeFrom(
        from._internal_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_buf = from._internal_angle_buf();
  ::uint32_t raw_angle_buf;
  memcpy(&raw_angle_buf, &tmp_angle_buf, sizeof(tmp_angle_buf));
  if (raw_angle_buf != 0) {
    _this->_internal_set_angle_buf(from._internal_angle_buf());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bhv_NeckBodyToPoint::CopyFrom(const Bhv_NeckBodyToPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Bhv_NeckBodyToPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bhv_NeckBodyToPoint::IsInitialized() const {
  return true;
}

void Bhv_NeckBodyToPoint::InternalSwap(Bhv_NeckBodyToPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Bhv_NeckBodyToPoint, _impl_.angle_buf_)
      + sizeof(Bhv_NeckBodyToPoint::_impl_.angle_buf_)
      - PROTOBUF_FIELD_OFFSET(Bhv_NeckBodyToPoint, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Bhv_NeckBodyToPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[66]);
}
// ===================================================================

class Bhv_ScanField::_Internal {
 public:
};

Bhv_ScanField::Bhv_ScanField(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Bhv_ScanField)
}
Bhv_ScanField::Bhv_ScanField(const Bhv_ScanField& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Bhv_ScanField* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Bhv_ScanField)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bhv_ScanField::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bhv_ScanField::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Bhv_ScanField::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[67]);
}
// ===================================================================

class Body_AdvanceBall::_Internal {
 public:
};

Body_AdvanceBall::Body_AdvanceBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Body_AdvanceBall)
}
Body_AdvanceBall::Body_AdvanceBall(const Body_AdvanceBall& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Body_AdvanceBall* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Body_AdvanceBall)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_AdvanceBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_AdvanceBall::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Body_AdvanceBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[68]);
}
// ===================================================================

class Body_ClearBall::_Internal {
 public:
};

Body_ClearBall::Body_ClearBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Body_ClearBall)
}
Body_ClearBall::Body_ClearBall(const Body_ClearBall& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Body_ClearBall* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Body_ClearBall)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_ClearBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_ClearBall::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Body_ClearBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[69]);
}
// ===================================================================

class Body_Dribble::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_Dribble>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_Dribble, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Body_Dribble* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_Dribble::_Internal::target_point(const Body_Dribble* msg) {
  return *msg->_impl_.target_point_;
}
Body_Dribble::Body_Dribble(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_Dribble)
}
Body_Dribble::Body_Dribble(const Body_Dribble& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_Dribble* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.distance_threshold_) {}

    , decltype(_impl_.dash_power_) {}

    , decltype(_impl_.dash_count_) {}

    , decltype(_impl_.dodge_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  ::memcpy(&_impl_.distance_threshold_, &from._impl_.distance_threshold_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.dodge_) -
    reinterpret_cast<char*>(&_impl_.distance_threshold_)) + sizeof(_impl_.dodge_));
  // @@protoc_insertion_point(copy_constructor:protos.Body_Dribble)
}

inline void Body_Dribble::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.distance_threshold_) { 0 }

    , decltype(_impl_.dash_power_) { 0 }

    , decltype(_impl_.dash_count_) { 0 }

    , decltype(_impl_.dodge_) { false }

  };
}

Body_Dribble::~Body_Dribble() {
  // @@protoc_insertion_point(destructor:protos.Body_Dribble)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_Dribble::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Body_Dribble::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_Dribble::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_Dribble)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  ::memset(&_impl_.distance_threshold_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.dodge_) -
      reinterpret_cast<char*>(&_impl_.distance_threshold_)) + sizeof(_impl_.dodge_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_Dribble::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float distance_threshold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.distance_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 dash_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.dash_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool dodge = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.dodge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_Dribble::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_Dribble)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // float distance_threshold = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = this->_internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_distance_threshold(), target);
  }

  // float dash_power = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_dash_power(), target);
  }

  // int32 dash_count = 4;
  if (this->_internal_dash_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_dash_count(), target);
  }

  // bool dodge = 5;
  if (this->_internal_dodge() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_dodge(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_Dribble)
  return target;
}

::size_t Body_Dribble::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_Dribble)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // float distance_threshold = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = this->_internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    total_size += 5;
  }

  // float dash_power = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    total_size += 5;
  }

  // int32 dash_count = 4;
  if (this->_internal_dash_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_dash_count());
  }

  // bool dodge = 5;
  if (this->_internal_dodge() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_Dribble::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_Dribble::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_Dribble::GetClassData() const { return &_class_data_; }


void Body_Dribble::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_Dribble*>(&to_msg);
  auto& from = static_cast<const Body_Dribble&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_Dribble)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_distance_threshold = from._internal_distance_threshold();
  ::uint32_t raw_distance_threshold;
  memcpy(&raw_distance_threshold, &tmp_distance_threshold, sizeof(tmp_distance_threshold));
  if (raw_distance_threshold != 0) {
    _this->_internal_set_distance_threshold(from._internal_distance_threshold());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = from._internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    _this->_internal_set_dash_power(from._internal_dash_power());
  }
  if (from._internal_dash_count() != 0) {
    _this->_internal_set_dash_count(from._internal_dash_count());
  }
  if (from._internal_dodge() != 0) {
    _this->_internal_set_dodge(from._internal_dodge());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_Dribble::CopyFrom(const Body_Dribble& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_Dribble)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_Dribble::IsInitialized() const {
  return true;
}

void Body_Dribble::InternalSwap(Body_Dribble* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_Dribble, _impl_.dodge_)
      + sizeof(Body_Dribble::_impl_.dodge_)
      - PROTOBUF_FIELD_OFFSET(Body_Dribble, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_Dribble::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[70]);
}
// ===================================================================

class Body_GoToPointDodge::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_GoToPointDodge>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_GoToPointDodge, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Body_GoToPointDodge* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_GoToPointDodge::_Internal::target_point(const Body_GoToPointDodge* msg) {
  return *msg->_impl_.target_point_;
}
Body_GoToPointDodge::Body_GoToPointDodge(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_GoToPointDodge)
}
Body_GoToPointDodge::Body_GoToPointDodge(const Body_GoToPointDodge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_GoToPointDodge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.dash_power_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  _this->_impl_.dash_power_ = from._impl_.dash_power_;
  // @@protoc_insertion_point(copy_constructor:protos.Body_GoToPointDodge)
}

inline void Body_GoToPointDodge::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.dash_power_) { 0 }

  };
}

Body_GoToPointDodge::~Body_GoToPointDodge() {
  // @@protoc_insertion_point(destructor:protos.Body_GoToPointDodge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_GoToPointDodge::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Body_GoToPointDodge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_GoToPointDodge::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_GoToPointDodge)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_.dash_power_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_GoToPointDodge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_GoToPointDodge::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_GoToPointDodge)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // float dash_power = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_dash_power(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_GoToPointDodge)
  return target;
}

::size_t Body_GoToPointDodge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_GoToPointDodge)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // float dash_power = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_GoToPointDodge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_GoToPointDodge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_GoToPointDodge::GetClassData() const { return &_class_data_; }


void Body_GoToPointDodge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_GoToPointDodge*>(&to_msg);
  auto& from = static_cast<const Body_GoToPointDodge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_GoToPointDodge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = from._internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    _this->_internal_set_dash_power(from._internal_dash_power());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_GoToPointDodge::CopyFrom(const Body_GoToPointDodge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_GoToPointDodge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_GoToPointDodge::IsInitialized() const {
  return true;
}

void Body_GoToPointDodge::InternalSwap(Body_GoToPointDodge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_GoToPointDodge, _impl_.dash_power_)
      + sizeof(Body_GoToPointDodge::_impl_.dash_power_)
      - PROTOBUF_FIELD_OFFSET(Body_GoToPointDodge, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_GoToPointDodge::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[71]);
}
// ===================================================================

class Body_HoldBall::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_HoldBall>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_HoldBall, _impl_._has_bits_);
  static const ::protos::Vector2D& turn_target_point(const Body_HoldBall* msg);
  static void set_has_turn_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& kick_target_point(const Body_HoldBall* msg);
  static void set_has_kick_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
Body_HoldBall::_Internal::turn_target_point(const Body_HoldBall* msg) {
  return *msg->_impl_.turn_target_point_;
}
const ::protos::Vector2D&
Body_HoldBall::_Internal::kick_target_point(const Body_HoldBall* msg) {
  return *msg->_impl_.kick_target_point_;
}
Body_HoldBall::Body_HoldBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_HoldBall)
}
Body_HoldBall::Body_HoldBall(const Body_HoldBall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_HoldBall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.turn_target_point_){nullptr}
    , decltype(_impl_.kick_target_point_){nullptr}
    , decltype(_impl_.do_turn_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.turn_target_point_ = new ::protos::Vector2D(*from._impl_.turn_target_point_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.kick_target_point_ = new ::protos::Vector2D(*from._impl_.kick_target_point_);
  }
  _this->_impl_.do_turn_ = from._impl_.do_turn_;
  // @@protoc_insertion_point(copy_constructor:protos.Body_HoldBall)
}

inline void Body_HoldBall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.turn_target_point_){nullptr}
    , decltype(_impl_.kick_target_point_){nullptr}
    , decltype(_impl_.do_turn_) { false }

  };
}

Body_HoldBall::~Body_HoldBall() {
  // @@protoc_insertion_point(destructor:protos.Body_HoldBall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_HoldBall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.turn_target_point_;
  if (this != internal_default_instance()) delete _impl_.kick_target_point_;
}

void Body_HoldBall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_HoldBall::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_HoldBall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.turn_target_point_ != nullptr);
      _impl_.turn_target_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.kick_target_point_ != nullptr);
      _impl_.kick_target_point_->Clear();
    }
  }
  _impl_.do_turn_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_HoldBall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool do_turn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.do_turn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D turn_target_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D kick_target_point = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_kick_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_HoldBall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_HoldBall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool do_turn = 1;
  if (this->_internal_do_turn() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_do_turn(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D turn_target_point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::turn_target_point(this),
        _Internal::turn_target_point(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D kick_target_point = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::kick_target_point(this),
        _Internal::kick_target_point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_HoldBall)
  return target;
}

::size_t Body_HoldBall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_HoldBall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D turn_target_point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.turn_target_point_);
    }

    // .protos.Vector2D kick_target_point = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kick_target_point_);
    }

  }
  // bool do_turn = 1;
  if (this->_internal_do_turn() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_HoldBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_HoldBall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_HoldBall::GetClassData() const { return &_class_data_; }


void Body_HoldBall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_HoldBall*>(&to_msg);
  auto& from = static_cast<const Body_HoldBall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_HoldBall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_turn_target_point()->::protos::Vector2D::MergeFrom(
          from._internal_turn_target_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_kick_target_point()->::protos::Vector2D::MergeFrom(
          from._internal_kick_target_point());
    }
  }
  if (from._internal_do_turn() != 0) {
    _this->_internal_set_do_turn(from._internal_do_turn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_HoldBall::CopyFrom(const Body_HoldBall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_HoldBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_HoldBall::IsInitialized() const {
  return true;
}

void Body_HoldBall::InternalSwap(Body_HoldBall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_HoldBall, _impl_.do_turn_)
      + sizeof(Body_HoldBall::_impl_.do_turn_)
      - PROTOBUF_FIELD_OFFSET(Body_HoldBall, _impl_.turn_target_point_)>(
          reinterpret_cast<char*>(&_impl_.turn_target_point_),
          reinterpret_cast<char*>(&other->_impl_.turn_target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_HoldBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[72]);
}
// ===================================================================

class Body_Intercept::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_Intercept>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_Intercept, _impl_._has_bits_);
  static const ::protos::Vector2D& face_point(const Body_Intercept* msg);
  static void set_has_face_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_Intercept::_Internal::face_point(const Body_Intercept* msg) {
  return *msg->_impl_.face_point_;
}
Body_Intercept::Body_Intercept(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_Intercept)
}
Body_Intercept::Body_Intercept(const Body_Intercept& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_Intercept* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.face_point_){nullptr}
    , decltype(_impl_.save_recovery_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.face_point_ = new ::protos::Vector2D(*from._impl_.face_point_);
  }
  _this->_impl_.save_recovery_ = from._impl_.save_recovery_;
  // @@protoc_insertion_point(copy_constructor:protos.Body_Intercept)
}

inline void Body_Intercept::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.face_point_){nullptr}
    , decltype(_impl_.save_recovery_) { false }

  };
}

Body_Intercept::~Body_Intercept() {
  // @@protoc_insertion_point(destructor:protos.Body_Intercept)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_Intercept::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.face_point_;
}

void Body_Intercept::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_Intercept::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_Intercept)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.face_point_ != nullptr);
    _impl_.face_point_->Clear();
  }
  _impl_.save_recovery_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_Intercept::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool save_recovery = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.save_recovery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D face_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_face_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_Intercept::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_Intercept)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool save_recovery = 1;
  if (this->_internal_save_recovery() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_save_recovery(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D face_point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::face_point(this),
        _Internal::face_point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_Intercept)
  return target;
}

::size_t Body_Intercept::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_Intercept)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D face_point = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.face_point_);
  }

  // bool save_recovery = 1;
  if (this->_internal_save_recovery() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_Intercept::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_Intercept::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_Intercept::GetClassData() const { return &_class_data_; }


void Body_Intercept::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_Intercept*>(&to_msg);
  auto& from = static_cast<const Body_Intercept&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_Intercept)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_face_point()->::protos::Vector2D::MergeFrom(
        from._internal_face_point());
  }
  if (from._internal_save_recovery() != 0) {
    _this->_internal_set_save_recovery(from._internal_save_recovery());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_Intercept::CopyFrom(const Body_Intercept& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_Intercept)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_Intercept::IsInitialized() const {
  return true;
}

void Body_Intercept::InternalSwap(Body_Intercept* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_Intercept, _impl_.save_recovery_)
      + sizeof(Body_Intercept::_impl_.save_recovery_)
      - PROTOBUF_FIELD_OFFSET(Body_Intercept, _impl_.face_point_)>(
          reinterpret_cast<char*>(&_impl_.face_point_),
          reinterpret_cast<char*>(&other->_impl_.face_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_Intercept::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[73]);
}
// ===================================================================

class Body_KickOneStep::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_KickOneStep>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_KickOneStep, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Body_KickOneStep* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_KickOneStep::_Internal::target_point(const Body_KickOneStep* msg) {
  return *msg->_impl_.target_point_;
}
Body_KickOneStep::Body_KickOneStep(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_KickOneStep)
}
Body_KickOneStep::Body_KickOneStep(const Body_KickOneStep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_KickOneStep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.first_speed_) {}

    , decltype(_impl_.force_mode_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  ::memcpy(&_impl_.first_speed_, &from._impl_.first_speed_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.force_mode_) -
    reinterpret_cast<char*>(&_impl_.first_speed_)) + sizeof(_impl_.force_mode_));
  // @@protoc_insertion_point(copy_constructor:protos.Body_KickOneStep)
}

inline void Body_KickOneStep::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.first_speed_) { 0 }

    , decltype(_impl_.force_mode_) { false }

  };
}

Body_KickOneStep::~Body_KickOneStep() {
  // @@protoc_insertion_point(destructor:protos.Body_KickOneStep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_KickOneStep::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Body_KickOneStep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_KickOneStep::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_KickOneStep)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  ::memset(&_impl_.first_speed_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.force_mode_) -
      reinterpret_cast<char*>(&_impl_.first_speed_)) + sizeof(_impl_.force_mode_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_KickOneStep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float first_speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.first_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool force_mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.force_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_KickOneStep::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_KickOneStep)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // float first_speed = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed = this->_internal_first_speed();
  ::uint32_t raw_first_speed;
  memcpy(&raw_first_speed, &tmp_first_speed, sizeof(tmp_first_speed));
  if (raw_first_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_first_speed(), target);
  }

  // bool force_mode = 3;
  if (this->_internal_force_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_force_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_KickOneStep)
  return target;
}

::size_t Body_KickOneStep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_KickOneStep)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // float first_speed = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed = this->_internal_first_speed();
  ::uint32_t raw_first_speed;
  memcpy(&raw_first_speed, &tmp_first_speed, sizeof(tmp_first_speed));
  if (raw_first_speed != 0) {
    total_size += 5;
  }

  // bool force_mode = 3;
  if (this->_internal_force_mode() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_KickOneStep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_KickOneStep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_KickOneStep::GetClassData() const { return &_class_data_; }


void Body_KickOneStep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_KickOneStep*>(&to_msg);
  auto& from = static_cast<const Body_KickOneStep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_KickOneStep)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_first_speed = from._internal_first_speed();
  ::uint32_t raw_first_speed;
  memcpy(&raw_first_speed, &tmp_first_speed, sizeof(tmp_first_speed));
  if (raw_first_speed != 0) {
    _this->_internal_set_first_speed(from._internal_first_speed());
  }
  if (from._internal_force_mode() != 0) {
    _this->_internal_set_force_mode(from._internal_force_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_KickOneStep::CopyFrom(const Body_KickOneStep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_KickOneStep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_KickOneStep::IsInitialized() const {
  return true;
}

void Body_KickOneStep::InternalSwap(Body_KickOneStep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_KickOneStep, _impl_.force_mode_)
      + sizeof(Body_KickOneStep::_impl_.force_mode_)
      - PROTOBUF_FIELD_OFFSET(Body_KickOneStep, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_KickOneStep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[74]);
}
// ===================================================================

class Body_StopBall::_Internal {
 public:
};

Body_StopBall::Body_StopBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Body_StopBall)
}
Body_StopBall::Body_StopBall(const Body_StopBall& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Body_StopBall* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Body_StopBall)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_StopBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_StopBall::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Body_StopBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[75]);
}
// ===================================================================

class Body_StopDash::_Internal {
 public:
};

Body_StopDash::Body_StopDash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_StopDash)
}
Body_StopDash::Body_StopDash(const Body_StopDash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Body_StopDash)
}

inline void Body_StopDash::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.save_recovery_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Body_StopDash::~Body_StopDash() {
  // @@protoc_insertion_point(destructor:protos.Body_StopDash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_StopDash::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Body_StopDash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_StopDash::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_StopDash)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.save_recovery_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_StopDash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool save_recovery = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.save_recovery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_StopDash::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_StopDash)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool save_recovery = 1;
  if (this->_internal_save_recovery() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_save_recovery(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_StopDash)
  return target;
}

::size_t Body_StopDash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_StopDash)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool save_recovery = 1;
  if (this->_internal_save_recovery() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_StopDash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_StopDash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_StopDash::GetClassData() const { return &_class_data_; }


void Body_StopDash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_StopDash*>(&to_msg);
  auto& from = static_cast<const Body_StopDash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_StopDash)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_save_recovery() != 0) {
    _this->_internal_set_save_recovery(from._internal_save_recovery());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_StopDash::CopyFrom(const Body_StopDash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_StopDash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_StopDash::IsInitialized() const {
  return true;
}

void Body_StopDash::InternalSwap(Body_StopDash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.save_recovery_, other->_impl_.save_recovery_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_StopDash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[76]);
}
// ===================================================================

class Body_TackleToPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_TackleToPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_TackleToPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Body_TackleToPoint* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_TackleToPoint::_Internal::target_point(const Body_TackleToPoint* msg) {
  return *msg->_impl_.target_point_;
}
Body_TackleToPoint::Body_TackleToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_TackleToPoint)
}
Body_TackleToPoint::Body_TackleToPoint(const Body_TackleToPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_TackleToPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.min_probability_) {}

    , decltype(_impl_.min_speed_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  ::memcpy(&_impl_.min_probability_, &from._impl_.min_probability_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.min_speed_) -
    reinterpret_cast<char*>(&_impl_.min_probability_)) + sizeof(_impl_.min_speed_));
  // @@protoc_insertion_point(copy_constructor:protos.Body_TackleToPoint)
}

inline void Body_TackleToPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.min_probability_) { 0 }

    , decltype(_impl_.min_speed_) { 0 }

  };
}

Body_TackleToPoint::~Body_TackleToPoint() {
  // @@protoc_insertion_point(destructor:protos.Body_TackleToPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_TackleToPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Body_TackleToPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_TackleToPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_TackleToPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  ::memset(&_impl_.min_probability_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.min_speed_) -
      reinterpret_cast<char*>(&_impl_.min_probability_)) + sizeof(_impl_.min_speed_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_TackleToPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_probability = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.min_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.min_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_TackleToPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_TackleToPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // float min_probability = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_probability = this->_internal_min_probability();
  ::uint32_t raw_min_probability;
  memcpy(&raw_min_probability, &tmp_min_probability, sizeof(tmp_min_probability));
  if (raw_min_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_min_probability(), target);
  }

  // float min_speed = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_speed = this->_internal_min_speed();
  ::uint32_t raw_min_speed;
  memcpy(&raw_min_speed, &tmp_min_speed, sizeof(tmp_min_speed));
  if (raw_min_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_min_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_TackleToPoint)
  return target;
}

::size_t Body_TackleToPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_TackleToPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // float min_probability = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_probability = this->_internal_min_probability();
  ::uint32_t raw_min_probability;
  memcpy(&raw_min_probability, &tmp_min_probability, sizeof(tmp_min_probability));
  if (raw_min_probability != 0) {
    total_size += 5;
  }

  // float min_speed = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_speed = this->_internal_min_speed();
  ::uint32_t raw_min_speed;
  memcpy(&raw_min_speed, &tmp_min_speed, sizeof(tmp_min_speed));
  if (raw_min_speed != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_TackleToPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_TackleToPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_TackleToPoint::GetClassData() const { return &_class_data_; }


void Body_TackleToPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_TackleToPoint*>(&to_msg);
  auto& from = static_cast<const Body_TackleToPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_TackleToPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_probability = from._internal_min_probability();
  ::uint32_t raw_min_probability;
  memcpy(&raw_min_probability, &tmp_min_probability, sizeof(tmp_min_probability));
  if (raw_min_probability != 0) {
    _this->_internal_set_min_probability(from._internal_min_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_speed = from._internal_min_speed();
  ::uint32_t raw_min_speed;
  memcpy(&raw_min_speed, &tmp_min_speed, sizeof(tmp_min_speed));
  if (raw_min_speed != 0) {
    _this->_internal_set_min_speed(from._internal_min_speed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_TackleToPoint::CopyFrom(const Body_TackleToPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_TackleToPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_TackleToPoint::IsInitialized() const {
  return true;
}

void Body_TackleToPoint::InternalSwap(Body_TackleToPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_TackleToPoint, _impl_.min_speed_)
      + sizeof(Body_TackleToPoint::_impl_.min_speed_)
      - PROTOBUF_FIELD_OFFSET(Body_TackleToPoint, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_TackleToPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[77]);
}
// ===================================================================

class Body_TurnToAngle::_Internal {
 public:
};

Body_TurnToAngle::Body_TurnToAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_TurnToAngle)
}
Body_TurnToAngle::Body_TurnToAngle(const Body_TurnToAngle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Body_TurnToAngle)
}

inline void Body_TurnToAngle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.angle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Body_TurnToAngle::~Body_TurnToAngle() {
  // @@protoc_insertion_point(destructor:protos.Body_TurnToAngle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_TurnToAngle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Body_TurnToAngle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_TurnToAngle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_TurnToAngle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.angle_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_TurnToAngle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_TurnToAngle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_TurnToAngle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float angle = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_TurnToAngle)
  return target;
}

::size_t Body_TurnToAngle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_TurnToAngle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float angle = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_TurnToAngle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_TurnToAngle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_TurnToAngle::GetClassData() const { return &_class_data_; }


void Body_TurnToAngle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_TurnToAngle*>(&to_msg);
  auto& from = static_cast<const Body_TurnToAngle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_TurnToAngle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = from._internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_TurnToAngle::CopyFrom(const Body_TurnToAngle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_TurnToAngle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_TurnToAngle::IsInitialized() const {
  return true;
}

void Body_TurnToAngle::InternalSwap(Body_TurnToAngle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.angle_, other->_impl_.angle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_TurnToAngle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[78]);
}
// ===================================================================

class Body_TurnToBall::_Internal {
 public:
};

Body_TurnToBall::Body_TurnToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_TurnToBall)
}
Body_TurnToBall::Body_TurnToBall(const Body_TurnToBall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Body_TurnToBall)
}

inline void Body_TurnToBall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.cycle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Body_TurnToBall::~Body_TurnToBall() {
  // @@protoc_insertion_point(destructor:protos.Body_TurnToBall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_TurnToBall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Body_TurnToBall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_TurnToBall::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_TurnToBall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cycle_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_TurnToBall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 cycle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_TurnToBall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_TurnToBall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 cycle = 1;
  if (this->_internal_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_cycle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_TurnToBall)
  return target;
}

::size_t Body_TurnToBall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_TurnToBall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 cycle = 1;
  if (this->_internal_cycle() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_cycle());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_TurnToBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_TurnToBall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_TurnToBall::GetClassData() const { return &_class_data_; }


void Body_TurnToBall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_TurnToBall*>(&to_msg);
  auto& from = static_cast<const Body_TurnToBall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_TurnToBall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_cycle() != 0) {
    _this->_internal_set_cycle(from._internal_cycle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_TurnToBall::CopyFrom(const Body_TurnToBall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_TurnToBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_TurnToBall::IsInitialized() const {
  return true;
}

void Body_TurnToBall::InternalSwap(Body_TurnToBall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.cycle_, other->_impl_.cycle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_TurnToBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[79]);
}
// ===================================================================

class Body_TurnToPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Body_TurnToPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Body_TurnToPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Body_TurnToPoint* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Body_TurnToPoint::_Internal::target_point(const Body_TurnToPoint* msg) {
  return *msg->_impl_.target_point_;
}
Body_TurnToPoint::Body_TurnToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Body_TurnToPoint)
}
Body_TurnToPoint::Body_TurnToPoint(const Body_TurnToPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Body_TurnToPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.cycle_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  _this->_impl_.cycle_ = from._impl_.cycle_;
  // @@protoc_insertion_point(copy_constructor:protos.Body_TurnToPoint)
}

inline void Body_TurnToPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.cycle_) { 0 }

  };
}

Body_TurnToPoint::~Body_TurnToPoint() {
  // @@protoc_insertion_point(destructor:protos.Body_TurnToPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Body_TurnToPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Body_TurnToPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body_TurnToPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Body_TurnToPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_.cycle_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body_TurnToPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 cycle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Body_TurnToPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Body_TurnToPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // int32 cycle = 2;
  if (this->_internal_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_cycle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Body_TurnToPoint)
  return target;
}

::size_t Body_TurnToPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Body_TurnToPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // int32 cycle = 2;
  if (this->_internal_cycle() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_cycle());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Body_TurnToPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Body_TurnToPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Body_TurnToPoint::GetClassData() const { return &_class_data_; }


void Body_TurnToPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Body_TurnToPoint*>(&to_msg);
  auto& from = static_cast<const Body_TurnToPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Body_TurnToPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  if (from._internal_cycle() != 0) {
    _this->_internal_set_cycle(from._internal_cycle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Body_TurnToPoint::CopyFrom(const Body_TurnToPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Body_TurnToPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body_TurnToPoint::IsInitialized() const {
  return true;
}

void Body_TurnToPoint::InternalSwap(Body_TurnToPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Body_TurnToPoint, _impl_.cycle_)
      + sizeof(Body_TurnToPoint::_impl_.cycle_)
      - PROTOBUF_FIELD_OFFSET(Body_TurnToPoint, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Body_TurnToPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[80]);
}
// ===================================================================

class Focus_MoveToPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Focus_MoveToPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Focus_MoveToPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Focus_MoveToPoint* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Focus_MoveToPoint::_Internal::target_point(const Focus_MoveToPoint* msg) {
  return *msg->_impl_.target_point_;
}
Focus_MoveToPoint::Focus_MoveToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Focus_MoveToPoint)
}
Focus_MoveToPoint::Focus_MoveToPoint(const Focus_MoveToPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Focus_MoveToPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.Focus_MoveToPoint)
}

inline void Focus_MoveToPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
  };
}

Focus_MoveToPoint::~Focus_MoveToPoint() {
  // @@protoc_insertion_point(destructor:protos.Focus_MoveToPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Focus_MoveToPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Focus_MoveToPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Focus_MoveToPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Focus_MoveToPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Focus_MoveToPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Focus_MoveToPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Focus_MoveToPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Focus_MoveToPoint)
  return target;
}

::size_t Focus_MoveToPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Focus_MoveToPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Focus_MoveToPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Focus_MoveToPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Focus_MoveToPoint::GetClassData() const { return &_class_data_; }


void Focus_MoveToPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Focus_MoveToPoint*>(&to_msg);
  auto& from = static_cast<const Focus_MoveToPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Focus_MoveToPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Focus_MoveToPoint::CopyFrom(const Focus_MoveToPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Focus_MoveToPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Focus_MoveToPoint::IsInitialized() const {
  return true;
}

void Focus_MoveToPoint::InternalSwap(Focus_MoveToPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.target_point_, other->_impl_.target_point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Focus_MoveToPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[81]);
}
// ===================================================================

class Focus_Reset::_Internal {
 public:
};

Focus_Reset::Focus_Reset(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Focus_Reset)
}
Focus_Reset::Focus_Reset(const Focus_Reset& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Focus_Reset* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Focus_Reset)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Focus_Reset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Focus_Reset::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Focus_Reset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[82]);
}
// ===================================================================

class Neck_ScanField::_Internal {
 public:
};

Neck_ScanField::Neck_ScanField(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Neck_ScanField)
}
Neck_ScanField::Neck_ScanField(const Neck_ScanField& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Neck_ScanField* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_ScanField)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_ScanField::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_ScanField::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Neck_ScanField::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[83]);
}
// ===================================================================

class Neck_ScanPlayers::_Internal {
 public:
};

Neck_ScanPlayers::Neck_ScanPlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Neck_ScanPlayers)
}
Neck_ScanPlayers::Neck_ScanPlayers(const Neck_ScanPlayers& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Neck_ScanPlayers* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_ScanPlayers)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_ScanPlayers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_ScanPlayers::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Neck_ScanPlayers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[84]);
}
// ===================================================================

class Neck_TurnToBallAndPlayer::_Internal {
 public:
};

Neck_TurnToBallAndPlayer::Neck_TurnToBallAndPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToBallAndPlayer)
}
Neck_TurnToBallAndPlayer::Neck_TurnToBallAndPlayer(const Neck_TurnToBallAndPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToBallAndPlayer)
}

inline void Neck_TurnToBallAndPlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.count_threshold_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Neck_TurnToBallAndPlayer::~Neck_TurnToBallAndPlayer() {
  // @@protoc_insertion_point(destructor:protos.Neck_TurnToBallAndPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neck_TurnToBallAndPlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Neck_TurnToBallAndPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neck_TurnToBallAndPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Neck_TurnToBallAndPlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_threshold_) -
      reinterpret_cast<char*>(&_impl_.side_)) + sizeof(_impl_.count_threshold_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neck_TurnToBallAndPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Side side = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 count_threshold = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.count_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Neck_TurnToBallAndPlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Neck_TurnToBallAndPlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_side(), target);
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_uniform_number(), target);
  }

  // int32 count_threshold = 3;
  if (this->_internal_count_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_count_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Neck_TurnToBallAndPlayer)
  return target;
}

::size_t Neck_TurnToBallAndPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Neck_TurnToBallAndPlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 count_threshold = 3;
  if (this->_internal_count_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_count_threshold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToBallAndPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neck_TurnToBallAndPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToBallAndPlayer::GetClassData() const { return &_class_data_; }


void Neck_TurnToBallAndPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neck_TurnToBallAndPlayer*>(&to_msg);
  auto& from = static_cast<const Neck_TurnToBallAndPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Neck_TurnToBallAndPlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_count_threshold() != 0) {
    _this->_internal_set_count_threshold(from._internal_count_threshold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neck_TurnToBallAndPlayer::CopyFrom(const Neck_TurnToBallAndPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Neck_TurnToBallAndPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neck_TurnToBallAndPlayer::IsInitialized() const {
  return true;
}

void Neck_TurnToBallAndPlayer::InternalSwap(Neck_TurnToBallAndPlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Neck_TurnToBallAndPlayer, _impl_.count_threshold_)
      + sizeof(Neck_TurnToBallAndPlayer::_impl_.count_threshold_)
      - PROTOBUF_FIELD_OFFSET(Neck_TurnToBallAndPlayer, _impl_.side_)>(
          reinterpret_cast<char*>(&_impl_.side_),
          reinterpret_cast<char*>(&other->_impl_.side_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToBallAndPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[85]);
}
// ===================================================================

class Neck_TurnToBallOrScan::_Internal {
 public:
};

Neck_TurnToBallOrScan::Neck_TurnToBallOrScan(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToBallOrScan)
}
Neck_TurnToBallOrScan::Neck_TurnToBallOrScan(const Neck_TurnToBallOrScan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToBallOrScan)
}

inline void Neck_TurnToBallOrScan::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.count_threshold_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Neck_TurnToBallOrScan::~Neck_TurnToBallOrScan() {
  // @@protoc_insertion_point(destructor:protos.Neck_TurnToBallOrScan)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neck_TurnToBallOrScan::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Neck_TurnToBallOrScan::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neck_TurnToBallOrScan::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Neck_TurnToBallOrScan)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.count_threshold_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neck_TurnToBallOrScan::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 count_threshold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.count_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Neck_TurnToBallOrScan::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Neck_TurnToBallOrScan)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 count_threshold = 1;
  if (this->_internal_count_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_count_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Neck_TurnToBallOrScan)
  return target;
}

::size_t Neck_TurnToBallOrScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Neck_TurnToBallOrScan)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 count_threshold = 1;
  if (this->_internal_count_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_count_threshold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToBallOrScan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neck_TurnToBallOrScan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToBallOrScan::GetClassData() const { return &_class_data_; }


void Neck_TurnToBallOrScan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neck_TurnToBallOrScan*>(&to_msg);
  auto& from = static_cast<const Neck_TurnToBallOrScan&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Neck_TurnToBallOrScan)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_count_threshold() != 0) {
    _this->_internal_set_count_threshold(from._internal_count_threshold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neck_TurnToBallOrScan::CopyFrom(const Neck_TurnToBallOrScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Neck_TurnToBallOrScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neck_TurnToBallOrScan::IsInitialized() const {
  return true;
}

void Neck_TurnToBallOrScan::InternalSwap(Neck_TurnToBallOrScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.count_threshold_, other->_impl_.count_threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToBallOrScan::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[86]);
}
// ===================================================================

class Neck_TurnToBall::_Internal {
 public:
};

Neck_TurnToBall::Neck_TurnToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToBall)
}
Neck_TurnToBall::Neck_TurnToBall(const Neck_TurnToBall& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Neck_TurnToBall* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToBall)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToBall::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[87]);
}
// ===================================================================

class Neck_TurnToGoalieOrScan::_Internal {
 public:
};

Neck_TurnToGoalieOrScan::Neck_TurnToGoalieOrScan(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToGoalieOrScan)
}
Neck_TurnToGoalieOrScan::Neck_TurnToGoalieOrScan(const Neck_TurnToGoalieOrScan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToGoalieOrScan)
}

inline void Neck_TurnToGoalieOrScan::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.count_threshold_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Neck_TurnToGoalieOrScan::~Neck_TurnToGoalieOrScan() {
  // @@protoc_insertion_point(destructor:protos.Neck_TurnToGoalieOrScan)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neck_TurnToGoalieOrScan::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Neck_TurnToGoalieOrScan::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neck_TurnToGoalieOrScan::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Neck_TurnToGoalieOrScan)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.count_threshold_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neck_TurnToGoalieOrScan::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 count_threshold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.count_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Neck_TurnToGoalieOrScan::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Neck_TurnToGoalieOrScan)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 count_threshold = 1;
  if (this->_internal_count_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_count_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Neck_TurnToGoalieOrScan)
  return target;
}

::size_t Neck_TurnToGoalieOrScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Neck_TurnToGoalieOrScan)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 count_threshold = 1;
  if (this->_internal_count_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_count_threshold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToGoalieOrScan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neck_TurnToGoalieOrScan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToGoalieOrScan::GetClassData() const { return &_class_data_; }


void Neck_TurnToGoalieOrScan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neck_TurnToGoalieOrScan*>(&to_msg);
  auto& from = static_cast<const Neck_TurnToGoalieOrScan&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Neck_TurnToGoalieOrScan)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_count_threshold() != 0) {
    _this->_internal_set_count_threshold(from._internal_count_threshold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neck_TurnToGoalieOrScan::CopyFrom(const Neck_TurnToGoalieOrScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Neck_TurnToGoalieOrScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neck_TurnToGoalieOrScan::IsInitialized() const {
  return true;
}

void Neck_TurnToGoalieOrScan::InternalSwap(Neck_TurnToGoalieOrScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.count_threshold_, other->_impl_.count_threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToGoalieOrScan::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[88]);
}
// ===================================================================

class Neck_TurnToLowConfTeammate::_Internal {
 public:
};

Neck_TurnToLowConfTeammate::Neck_TurnToLowConfTeammate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToLowConfTeammate)
}
Neck_TurnToLowConfTeammate::Neck_TurnToLowConfTeammate(const Neck_TurnToLowConfTeammate& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Neck_TurnToLowConfTeammate* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToLowConfTeammate)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToLowConfTeammate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToLowConfTeammate::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToLowConfTeammate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[89]);
}
// ===================================================================

class Neck_TurnToPlayerOrScan::_Internal {
 public:
};

Neck_TurnToPlayerOrScan::Neck_TurnToPlayerOrScan(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToPlayerOrScan)
}
Neck_TurnToPlayerOrScan::Neck_TurnToPlayerOrScan(const Neck_TurnToPlayerOrScan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToPlayerOrScan)
}

inline void Neck_TurnToPlayerOrScan::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.count_threshold_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Neck_TurnToPlayerOrScan::~Neck_TurnToPlayerOrScan() {
  // @@protoc_insertion_point(destructor:protos.Neck_TurnToPlayerOrScan)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neck_TurnToPlayerOrScan::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Neck_TurnToPlayerOrScan::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neck_TurnToPlayerOrScan::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Neck_TurnToPlayerOrScan)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_threshold_) -
      reinterpret_cast<char*>(&_impl_.side_)) + sizeof(_impl_.count_threshold_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neck_TurnToPlayerOrScan::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Side side = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 count_threshold = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.count_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Neck_TurnToPlayerOrScan::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Neck_TurnToPlayerOrScan)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_side(), target);
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_uniform_number(), target);
  }

  // int32 count_threshold = 3;
  if (this->_internal_count_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_count_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Neck_TurnToPlayerOrScan)
  return target;
}

::size_t Neck_TurnToPlayerOrScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Neck_TurnToPlayerOrScan)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 count_threshold = 3;
  if (this->_internal_count_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_count_threshold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToPlayerOrScan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neck_TurnToPlayerOrScan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToPlayerOrScan::GetClassData() const { return &_class_data_; }


void Neck_TurnToPlayerOrScan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neck_TurnToPlayerOrScan*>(&to_msg);
  auto& from = static_cast<const Neck_TurnToPlayerOrScan&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Neck_TurnToPlayerOrScan)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_count_threshold() != 0) {
    _this->_internal_set_count_threshold(from._internal_count_threshold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neck_TurnToPlayerOrScan::CopyFrom(const Neck_TurnToPlayerOrScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Neck_TurnToPlayerOrScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neck_TurnToPlayerOrScan::IsInitialized() const {
  return true;
}

void Neck_TurnToPlayerOrScan::InternalSwap(Neck_TurnToPlayerOrScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Neck_TurnToPlayerOrScan, _impl_.count_threshold_)
      + sizeof(Neck_TurnToPlayerOrScan::_impl_.count_threshold_)
      - PROTOBUF_FIELD_OFFSET(Neck_TurnToPlayerOrScan, _impl_.side_)>(
          reinterpret_cast<char*>(&_impl_.side_),
          reinterpret_cast<char*>(&other->_impl_.side_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToPlayerOrScan::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[90]);
}
// ===================================================================

class Neck_TurnToPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Neck_TurnToPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Neck_TurnToPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const Neck_TurnToPoint* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
Neck_TurnToPoint::_Internal::target_point(const Neck_TurnToPoint* msg) {
  return *msg->_impl_.target_point_;
}
Neck_TurnToPoint::Neck_TurnToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToPoint)
}
Neck_TurnToPoint::Neck_TurnToPoint(const Neck_TurnToPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Neck_TurnToPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToPoint)
}

inline void Neck_TurnToPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
  };
}

Neck_TurnToPoint::~Neck_TurnToPoint() {
  // @@protoc_insertion_point(destructor:protos.Neck_TurnToPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neck_TurnToPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void Neck_TurnToPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neck_TurnToPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Neck_TurnToPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neck_TurnToPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Neck_TurnToPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Neck_TurnToPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Neck_TurnToPoint)
  return target;
}

::size_t Neck_TurnToPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Neck_TurnToPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neck_TurnToPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToPoint::GetClassData() const { return &_class_data_; }


void Neck_TurnToPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neck_TurnToPoint*>(&to_msg);
  auto& from = static_cast<const Neck_TurnToPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Neck_TurnToPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neck_TurnToPoint::CopyFrom(const Neck_TurnToPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Neck_TurnToPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neck_TurnToPoint::IsInitialized() const {
  return true;
}

void Neck_TurnToPoint::InternalSwap(Neck_TurnToPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.target_point_, other->_impl_.target_point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[91]);
}
// ===================================================================

class Neck_TurnToRelative::_Internal {
 public:
};

Neck_TurnToRelative::Neck_TurnToRelative(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Neck_TurnToRelative)
}
Neck_TurnToRelative::Neck_TurnToRelative(const Neck_TurnToRelative& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Neck_TurnToRelative)
}

inline void Neck_TurnToRelative::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.angle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Neck_TurnToRelative::~Neck_TurnToRelative() {
  // @@protoc_insertion_point(destructor:protos.Neck_TurnToRelative)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neck_TurnToRelative::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Neck_TurnToRelative::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neck_TurnToRelative::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Neck_TurnToRelative)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.angle_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neck_TurnToRelative::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Neck_TurnToRelative::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Neck_TurnToRelative)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float angle = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Neck_TurnToRelative)
  return target;
}

::size_t Neck_TurnToRelative::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Neck_TurnToRelative)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float angle = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neck_TurnToRelative::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neck_TurnToRelative::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neck_TurnToRelative::GetClassData() const { return &_class_data_; }


void Neck_TurnToRelative::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neck_TurnToRelative*>(&to_msg);
  auto& from = static_cast<const Neck_TurnToRelative&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Neck_TurnToRelative)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = from._internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neck_TurnToRelative::CopyFrom(const Neck_TurnToRelative& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Neck_TurnToRelative)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neck_TurnToRelative::IsInitialized() const {
  return true;
}

void Neck_TurnToRelative::InternalSwap(Neck_TurnToRelative* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.angle_, other->_impl_.angle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Neck_TurnToRelative::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[92]);
}
// ===================================================================

class View_ChangeWidth::_Internal {
 public:
};

View_ChangeWidth::View_ChangeWidth(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.View_ChangeWidth)
}
View_ChangeWidth::View_ChangeWidth(const View_ChangeWidth& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.View_ChangeWidth)
}

inline void View_ChangeWidth::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.view_width_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

View_ChangeWidth::~View_ChangeWidth() {
  // @@protoc_insertion_point(destructor:protos.View_ChangeWidth)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void View_ChangeWidth::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void View_ChangeWidth::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void View_ChangeWidth::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.View_ChangeWidth)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.view_width_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* View_ChangeWidth::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.ViewWidth view_width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_view_width(static_cast<::protos::ViewWidth>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* View_ChangeWidth::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.View_ChangeWidth)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_view_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.View_ChangeWidth)
  return target;
}

::size_t View_ChangeWidth::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.View_ChangeWidth)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_view_width());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData View_ChangeWidth::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    View_ChangeWidth::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*View_ChangeWidth::GetClassData() const { return &_class_data_; }


void View_ChangeWidth::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<View_ChangeWidth*>(&to_msg);
  auto& from = static_cast<const View_ChangeWidth&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.View_ChangeWidth)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_view_width() != 0) {
    _this->_internal_set_view_width(from._internal_view_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void View_ChangeWidth::CopyFrom(const View_ChangeWidth& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.View_ChangeWidth)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool View_ChangeWidth::IsInitialized() const {
  return true;
}

void View_ChangeWidth::InternalSwap(View_ChangeWidth* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.view_width_, other->_impl_.view_width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata View_ChangeWidth::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[93]);
}
// ===================================================================

class View_Normal::_Internal {
 public:
};

View_Normal::View_Normal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.View_Normal)
}
View_Normal::View_Normal(const View_Normal& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  View_Normal* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.View_Normal)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData View_Normal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*View_Normal::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata View_Normal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[94]);
}
// ===================================================================

class View_Synch::_Internal {
 public:
};

View_Synch::View_Synch(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.View_Synch)
}
View_Synch::View_Synch(const View_Synch& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  View_Synch* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.View_Synch)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData View_Synch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*View_Synch::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata View_Synch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[95]);
}
// ===================================================================

class View_Wide::_Internal {
 public:
};

View_Wide::View_Wide(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.View_Wide)
}
View_Wide::View_Wide(const View_Wide& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  View_Wide* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.View_Wide)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData View_Wide::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*View_Wide::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata View_Wide::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[96]);
}
// ===================================================================

class HeliosGoalie::_Internal {
 public:
};

HeliosGoalie::HeliosGoalie(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosGoalie)
}
HeliosGoalie::HeliosGoalie(const HeliosGoalie& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosGoalie* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosGoalie)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosGoalie::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosGoalie::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosGoalie::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[97]);
}
// ===================================================================

class HeliosGoalieMove::_Internal {
 public:
};

HeliosGoalieMove::HeliosGoalieMove(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosGoalieMove)
}
HeliosGoalieMove::HeliosGoalieMove(const HeliosGoalieMove& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosGoalieMove* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosGoalieMove)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosGoalieMove::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosGoalieMove::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosGoalieMove::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[98]);
}
// ===================================================================

class HeliosGoalieKick::_Internal {
 public:
};

HeliosGoalieKick::HeliosGoalieKick(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosGoalieKick)
}
HeliosGoalieKick::HeliosGoalieKick(const HeliosGoalieKick& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosGoalieKick* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosGoalieKick)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosGoalieKick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosGoalieKick::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosGoalieKick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[99]);
}
// ===================================================================

class HeliosShoot::_Internal {
 public:
};

HeliosShoot::HeliosShoot(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosShoot)
}
HeliosShoot::HeliosShoot(const HeliosShoot& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosShoot* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosShoot)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosShoot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosShoot::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosShoot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[100]);
}
// ===================================================================

class HeliosChainAction::_Internal {
 public:
};

HeliosChainAction::HeliosChainAction(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.HeliosChainAction)
}
HeliosChainAction::HeliosChainAction(const HeliosChainAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosChainAction)
}

inline void HeliosChainAction::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.direct_pass_) { false }

    , decltype(_impl_.lead_pass_) { false }

    , decltype(_impl_.through_pass_) { false }

    , decltype(_impl_.short_dribble_) { false }

    , decltype(_impl_.long_dribble_) { false }

    , decltype(_impl_.cross_) { false }

    , decltype(_impl_.simple_pass_) { false }

    , decltype(_impl_.simple_dribble_) { false }

    , decltype(_impl_.simple_shoot_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HeliosChainAction::~HeliosChainAction() {
  // @@protoc_insertion_point(destructor:protos.HeliosChainAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeliosChainAction::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void HeliosChainAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeliosChainAction::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.HeliosChainAction)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.direct_pass_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.simple_shoot_) -
      reinterpret_cast<char*>(&_impl_.direct_pass_)) + sizeof(_impl_.simple_shoot_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeliosChainAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool direct_pass = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.direct_pass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool lead_pass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.lead_pass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool through_pass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.through_pass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool short_dribble = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.short_dribble_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool long_dribble = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.long_dribble_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool cross = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.cross_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool simple_pass = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.simple_pass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool simple_dribble = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.simple_dribble_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool simple_shoot = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.simple_shoot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HeliosChainAction::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.HeliosChainAction)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool direct_pass = 1;
  if (this->_internal_direct_pass() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_direct_pass(), target);
  }

  // bool lead_pass = 2;
  if (this->_internal_lead_pass() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_lead_pass(), target);
  }

  // bool through_pass = 3;
  if (this->_internal_through_pass() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_through_pass(), target);
  }

  // bool short_dribble = 4;
  if (this->_internal_short_dribble() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_short_dribble(), target);
  }

  // bool long_dribble = 5;
  if (this->_internal_long_dribble() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_long_dribble(), target);
  }

  // bool cross = 6;
  if (this->_internal_cross() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_cross(), target);
  }

  // bool simple_pass = 7;
  if (this->_internal_simple_pass() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_simple_pass(), target);
  }

  // bool simple_dribble = 8;
  if (this->_internal_simple_dribble() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_simple_dribble(), target);
  }

  // bool simple_shoot = 9;
  if (this->_internal_simple_shoot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_simple_shoot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.HeliosChainAction)
  return target;
}

::size_t HeliosChainAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.HeliosChainAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool direct_pass = 1;
  if (this->_internal_direct_pass() != 0) {
    total_size += 2;
  }

  // bool lead_pass = 2;
  if (this->_internal_lead_pass() != 0) {
    total_size += 2;
  }

  // bool through_pass = 3;
  if (this->_internal_through_pass() != 0) {
    total_size += 2;
  }

  // bool short_dribble = 4;
  if (this->_internal_short_dribble() != 0) {
    total_size += 2;
  }

  // bool long_dribble = 5;
  if (this->_internal_long_dribble() != 0) {
    total_size += 2;
  }

  // bool cross = 6;
  if (this->_internal_cross() != 0) {
    total_size += 2;
  }

  // bool simple_pass = 7;
  if (this->_internal_simple_pass() != 0) {
    total_size += 2;
  }

  // bool simple_dribble = 8;
  if (this->_internal_simple_dribble() != 0) {
    total_size += 2;
  }

  // bool simple_shoot = 9;
  if (this->_internal_simple_shoot() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosChainAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeliosChainAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosChainAction::GetClassData() const { return &_class_data_; }


void HeliosChainAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeliosChainAction*>(&to_msg);
  auto& from = static_cast<const HeliosChainAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.HeliosChainAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_direct_pass() != 0) {
    _this->_internal_set_direct_pass(from._internal_direct_pass());
  }
  if (from._internal_lead_pass() != 0) {
    _this->_internal_set_lead_pass(from._internal_lead_pass());
  }
  if (from._internal_through_pass() != 0) {
    _this->_internal_set_through_pass(from._internal_through_pass());
  }
  if (from._internal_short_dribble() != 0) {
    _this->_internal_set_short_dribble(from._internal_short_dribble());
  }
  if (from._internal_long_dribble() != 0) {
    _this->_internal_set_long_dribble(from._internal_long_dribble());
  }
  if (from._internal_cross() != 0) {
    _this->_internal_set_cross(from._internal_cross());
  }
  if (from._internal_simple_pass() != 0) {
    _this->_internal_set_simple_pass(from._internal_simple_pass());
  }
  if (from._internal_simple_dribble() != 0) {
    _this->_internal_set_simple_dribble(from._internal_simple_dribble());
  }
  if (from._internal_simple_shoot() != 0) {
    _this->_internal_set_simple_shoot(from._internal_simple_shoot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeliosChainAction::CopyFrom(const HeliosChainAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.HeliosChainAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeliosChainAction::IsInitialized() const {
  return true;
}

void HeliosChainAction::InternalSwap(HeliosChainAction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeliosChainAction, _impl_.simple_shoot_)
      + sizeof(HeliosChainAction::_impl_.simple_shoot_)
      - PROTOBUF_FIELD_OFFSET(HeliosChainAction, _impl_.direct_pass_)>(
          reinterpret_cast<char*>(&_impl_.direct_pass_),
          reinterpret_cast<char*>(&other->_impl_.direct_pass_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HeliosChainAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[101]);
}
// ===================================================================

class HeliosBasicOffensive::_Internal {
 public:
};

HeliosBasicOffensive::HeliosBasicOffensive(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosBasicOffensive)
}
HeliosBasicOffensive::HeliosBasicOffensive(const HeliosBasicOffensive& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosBasicOffensive* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosBasicOffensive)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosBasicOffensive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosBasicOffensive::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosBasicOffensive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[102]);
}
// ===================================================================

class HeliosBasicMove::_Internal {
 public:
};

HeliosBasicMove::HeliosBasicMove(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosBasicMove)
}
HeliosBasicMove::HeliosBasicMove(const HeliosBasicMove& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosBasicMove* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosBasicMove)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosBasicMove::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosBasicMove::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosBasicMove::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[103]);
}
// ===================================================================

class HeliosSetPlay::_Internal {
 public:
};

HeliosSetPlay::HeliosSetPlay(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosSetPlay)
}
HeliosSetPlay::HeliosSetPlay(const HeliosSetPlay& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosSetPlay* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosSetPlay)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosSetPlay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosSetPlay::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosSetPlay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[104]);
}
// ===================================================================

class HeliosPenalty::_Internal {
 public:
};

HeliosPenalty::HeliosPenalty(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosPenalty)
}
HeliosPenalty::HeliosPenalty(const HeliosPenalty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosPenalty* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosPenalty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosPenalty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosPenalty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosPenalty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[105]);
}
// ===================================================================

class HeliosCommunicaion::_Internal {
 public:
};

HeliosCommunicaion::HeliosCommunicaion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.HeliosCommunicaion)
}
HeliosCommunicaion::HeliosCommunicaion(const HeliosCommunicaion& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeliosCommunicaion* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.HeliosCommunicaion)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeliosCommunicaion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeliosCommunicaion::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeliosCommunicaion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[106]);
}
// ===================================================================

class PlayerAction::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::PlayerAction, _impl_._oneof_case_);
  static const ::protos::Dash& dash(const PlayerAction* msg);
  static const ::protos::Turn& turn(const PlayerAction* msg);
  static const ::protos::Kick& kick(const PlayerAction* msg);
  static const ::protos::Tackle& tackle(const PlayerAction* msg);
  static const ::protos::Catch& catch_(const PlayerAction* msg);
  static const ::protos::Move& move(const PlayerAction* msg);
  static const ::protos::TurnNeck& turn_neck(const PlayerAction* msg);
  static const ::protos::ChangeView& change_view(const PlayerAction* msg);
  static const ::protos::Say& say(const PlayerAction* msg);
  static const ::protos::PointTo& point_to(const PlayerAction* msg);
  static const ::protos::PointToOf& point_to_of(const PlayerAction* msg);
  static const ::protos::AttentionTo& attention_to(const PlayerAction* msg);
  static const ::protos::AttentionToOf& attention_to_of(const PlayerAction* msg);
  static const ::protos::Log& log(const PlayerAction* msg);
  static const ::protos::DebugClient& debug_client(const PlayerAction* msg);
  static const ::protos::Body_GoToPoint& body_go_to_point(const PlayerAction* msg);
  static const ::protos::Body_SmartKick& body_smart_kick(const PlayerAction* msg);
  static const ::protos::Bhv_BeforeKickOff& bhv_before_kick_off(const PlayerAction* msg);
  static const ::protos::Bhv_BodyNeckToBall& bhv_body_neck_to_ball(const PlayerAction* msg);
  static const ::protos::Bhv_BodyNeckToPoint& bhv_body_neck_to_point(const PlayerAction* msg);
  static const ::protos::Bhv_Emergency& bhv_emergency(const PlayerAction* msg);
  static const ::protos::Bhv_GoToPointLookBall& bhv_go_to_point_look_ball(const PlayerAction* msg);
  static const ::protos::Bhv_NeckBodyToBall& bhv_neck_body_to_ball(const PlayerAction* msg);
  static const ::protos::Bhv_NeckBodyToPoint& bhv_neck_body_to_point(const PlayerAction* msg);
  static const ::protos::Bhv_ScanField& bhv_scan_field(const PlayerAction* msg);
  static const ::protos::Body_AdvanceBall& body_advance_ball(const PlayerAction* msg);
  static const ::protos::Body_ClearBall& body_clear_ball(const PlayerAction* msg);
  static const ::protos::Body_Dribble& body_dribble(const PlayerAction* msg);
  static const ::protos::Body_GoToPointDodge& body_go_to_point_dodge(const PlayerAction* msg);
  static const ::protos::Body_HoldBall& body_hold_ball(const PlayerAction* msg);
  static const ::protos::Body_Intercept& body_intercept(const PlayerAction* msg);
  static const ::protos::Body_KickOneStep& body_kick_one_step(const PlayerAction* msg);
  static const ::protos::Body_StopBall& body_stop_ball(const PlayerAction* msg);
  static const ::protos::Body_StopDash& body_stop_dash(const PlayerAction* msg);
  static const ::protos::Body_TackleToPoint& body_tackle_to_point(const PlayerAction* msg);
  static const ::protos::Body_TurnToAngle& body_turn_to_angle(const PlayerAction* msg);
  static const ::protos::Body_TurnToBall& body_turn_to_ball(const PlayerAction* msg);
  static const ::protos::Body_TurnToPoint& body_turn_to_point(const PlayerAction* msg);
  static const ::protos::Focus_MoveToPoint& focus_move_to_point(const PlayerAction* msg);
  static const ::protos::Focus_Reset& focus_reset(const PlayerAction* msg);
  static const ::protos::Neck_ScanField& neck_scan_field(const PlayerAction* msg);
  static const ::protos::Neck_ScanPlayers& neck_scan_players(const PlayerAction* msg);
  static const ::protos::Neck_TurnToBallAndPlayer& neck_turn_to_ball_and_player(const PlayerAction* msg);
  static const ::protos::Neck_TurnToBallOrScan& neck_turn_to_ball_or_scan(const PlayerAction* msg);
  static const ::protos::Neck_TurnToBall& neck_turn_to_ball(const PlayerAction* msg);
  static const ::protos::Neck_TurnToGoalieOrScan& neck_turn_to_goalie_or_scan(const PlayerAction* msg);
  static const ::protos::Neck_TurnToLowConfTeammate& neck_turn_to_low_conf_teammate(const PlayerAction* msg);
  static const ::protos::Neck_TurnToPlayerOrScan& neck_turn_to_player_or_scan(const PlayerAction* msg);
  static const ::protos::Neck_TurnToPoint& neck_turn_to_point(const PlayerAction* msg);
  static const ::protos::Neck_TurnToRelative& neck_turn_to_relative(const PlayerAction* msg);
  static const ::protos::View_ChangeWidth& view_change_width(const PlayerAction* msg);
  static const ::protos::View_Normal& view_normal(const PlayerAction* msg);
  static const ::protos::View_Synch& view_synch(const PlayerAction* msg);
  static const ::protos::View_Wide& view_wide(const PlayerAction* msg);
  static const ::protos::HeliosGoalie& helios_goalie(const PlayerAction* msg);
  static const ::protos::HeliosGoalieMove& helios_goalie_move(const PlayerAction* msg);
  static const ::protos::HeliosGoalieKick& helios_goalie_kick(const PlayerAction* msg);
  static const ::protos::HeliosShoot& helios_shoot(const PlayerAction* msg);
  static const ::protos::HeliosChainAction& helios_chain_action(const PlayerAction* msg);
  static const ::protos::HeliosBasicOffensive& helios_basic_offensive(const PlayerAction* msg);
  static const ::protos::HeliosBasicMove& helios_basic_move(const PlayerAction* msg);
  static const ::protos::HeliosSetPlay& helios_set_play(const PlayerAction* msg);
  static const ::protos::HeliosPenalty& helios_penalty(const PlayerAction* msg);
  static const ::protos::HeliosCommunicaion& helios_communication(const PlayerAction* msg);
};

const ::protos::Dash&
PlayerAction::_Internal::dash(const PlayerAction* msg) {
  return *msg->_impl_.action_.dash_;
}
const ::protos::Turn&
PlayerAction::_Internal::turn(const PlayerAction* msg) {
  return *msg->_impl_.action_.turn_;
}
const ::protos::Kick&
PlayerAction::_Internal::kick(const PlayerAction* msg) {
  return *msg->_impl_.action_.kick_;
}
const ::protos::Tackle&
PlayerAction::_Internal::tackle(const PlayerAction* msg) {
  return *msg->_impl_.action_.tackle_;
}
const ::protos::Catch&
PlayerAction::_Internal::catch_(const PlayerAction* msg) {
  return *msg->_impl_.action_.catch__;
}
const ::protos::Move&
PlayerAction::_Internal::move(const PlayerAction* msg) {
  return *msg->_impl_.action_.move_;
}
const ::protos::TurnNeck&
PlayerAction::_Internal::turn_neck(const PlayerAction* msg) {
  return *msg->_impl_.action_.turn_neck_;
}
const ::protos::ChangeView&
PlayerAction::_Internal::change_view(const PlayerAction* msg) {
  return *msg->_impl_.action_.change_view_;
}
const ::protos::Say&
PlayerAction::_Internal::say(const PlayerAction* msg) {
  return *msg->_impl_.action_.say_;
}
const ::protos::PointTo&
PlayerAction::_Internal::point_to(const PlayerAction* msg) {
  return *msg->_impl_.action_.point_to_;
}
const ::protos::PointToOf&
PlayerAction::_Internal::point_to_of(const PlayerAction* msg) {
  return *msg->_impl_.action_.point_to_of_;
}
const ::protos::AttentionTo&
PlayerAction::_Internal::attention_to(const PlayerAction* msg) {
  return *msg->_impl_.action_.attention_to_;
}
const ::protos::AttentionToOf&
PlayerAction::_Internal::attention_to_of(const PlayerAction* msg) {
  return *msg->_impl_.action_.attention_to_of_;
}
const ::protos::Log&
PlayerAction::_Internal::log(const PlayerAction* msg) {
  return *msg->_impl_.action_.log_;
}
const ::protos::DebugClient&
PlayerAction::_Internal::debug_client(const PlayerAction* msg) {
  return *msg->_impl_.action_.debug_client_;
}
const ::protos::Body_GoToPoint&
PlayerAction::_Internal::body_go_to_point(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_go_to_point_;
}
const ::protos::Body_SmartKick&
PlayerAction::_Internal::body_smart_kick(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_smart_kick_;
}
const ::protos::Bhv_BeforeKickOff&
PlayerAction::_Internal::bhv_before_kick_off(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_before_kick_off_;
}
const ::protos::Bhv_BodyNeckToBall&
PlayerAction::_Internal::bhv_body_neck_to_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_body_neck_to_ball_;
}
const ::protos::Bhv_BodyNeckToPoint&
PlayerAction::_Internal::bhv_body_neck_to_point(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_body_neck_to_point_;
}
const ::protos::Bhv_Emergency&
PlayerAction::_Internal::bhv_emergency(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_emergency_;
}
const ::protos::Bhv_GoToPointLookBall&
PlayerAction::_Internal::bhv_go_to_point_look_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_go_to_point_look_ball_;
}
const ::protos::Bhv_NeckBodyToBall&
PlayerAction::_Internal::bhv_neck_body_to_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_neck_body_to_ball_;
}
const ::protos::Bhv_NeckBodyToPoint&
PlayerAction::_Internal::bhv_neck_body_to_point(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_neck_body_to_point_;
}
const ::protos::Bhv_ScanField&
PlayerAction::_Internal::bhv_scan_field(const PlayerAction* msg) {
  return *msg->_impl_.action_.bhv_scan_field_;
}
const ::protos::Body_AdvanceBall&
PlayerAction::_Internal::body_advance_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_advance_ball_;
}
const ::protos::Body_ClearBall&
PlayerAction::_Internal::body_clear_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_clear_ball_;
}
const ::protos::Body_Dribble&
PlayerAction::_Internal::body_dribble(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_dribble_;
}
const ::protos::Body_GoToPointDodge&
PlayerAction::_Internal::body_go_to_point_dodge(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_go_to_point_dodge_;
}
const ::protos::Body_HoldBall&
PlayerAction::_Internal::body_hold_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_hold_ball_;
}
const ::protos::Body_Intercept&
PlayerAction::_Internal::body_intercept(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_intercept_;
}
const ::protos::Body_KickOneStep&
PlayerAction::_Internal::body_kick_one_step(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_kick_one_step_;
}
const ::protos::Body_StopBall&
PlayerAction::_Internal::body_stop_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_stop_ball_;
}
const ::protos::Body_StopDash&
PlayerAction::_Internal::body_stop_dash(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_stop_dash_;
}
const ::protos::Body_TackleToPoint&
PlayerAction::_Internal::body_tackle_to_point(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_tackle_to_point_;
}
const ::protos::Body_TurnToAngle&
PlayerAction::_Internal::body_turn_to_angle(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_turn_to_angle_;
}
const ::protos::Body_TurnToBall&
PlayerAction::_Internal::body_turn_to_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_turn_to_ball_;
}
const ::protos::Body_TurnToPoint&
PlayerAction::_Internal::body_turn_to_point(const PlayerAction* msg) {
  return *msg->_impl_.action_.body_turn_to_point_;
}
const ::protos::Focus_MoveToPoint&
PlayerAction::_Internal::focus_move_to_point(const PlayerAction* msg) {
  return *msg->_impl_.action_.focus_move_to_point_;
}
const ::protos::Focus_Reset&
PlayerAction::_Internal::focus_reset(const PlayerAction* msg) {
  return *msg->_impl_.action_.focus_reset_;
}
const ::protos::Neck_ScanField&
PlayerAction::_Internal::neck_scan_field(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_scan_field_;
}
const ::protos::Neck_ScanPlayers&
PlayerAction::_Internal::neck_scan_players(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_scan_players_;
}
const ::protos::Neck_TurnToBallAndPlayer&
PlayerAction::_Internal::neck_turn_to_ball_and_player(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_ball_and_player_;
}
const ::protos::Neck_TurnToBallOrScan&
PlayerAction::_Internal::neck_turn_to_ball_or_scan(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_ball_or_scan_;
}
const ::protos::Neck_TurnToBall&
PlayerAction::_Internal::neck_turn_to_ball(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_ball_;
}
const ::protos::Neck_TurnToGoalieOrScan&
PlayerAction::_Internal::neck_turn_to_goalie_or_scan(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_goalie_or_scan_;
}
const ::protos::Neck_TurnToLowConfTeammate&
PlayerAction::_Internal::neck_turn_to_low_conf_teammate(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_low_conf_teammate_;
}
const ::protos::Neck_TurnToPlayerOrScan&
PlayerAction::_Internal::neck_turn_to_player_or_scan(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_player_or_scan_;
}
const ::protos::Neck_TurnToPoint&
PlayerAction::_Internal::neck_turn_to_point(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_point_;
}
const ::protos::Neck_TurnToRelative&
PlayerAction::_Internal::neck_turn_to_relative(const PlayerAction* msg) {
  return *msg->_impl_.action_.neck_turn_to_relative_;
}
const ::protos::View_ChangeWidth&
PlayerAction::_Internal::view_change_width(const PlayerAction* msg) {
  return *msg->_impl_.action_.view_change_width_;
}
const ::protos::View_Normal&
PlayerAction::_Internal::view_normal(const PlayerAction* msg) {
  return *msg->_impl_.action_.view_normal_;
}
const ::protos::View_Synch&
PlayerAction::_Internal::view_synch(const PlayerAction* msg) {
  return *msg->_impl_.action_.view_synch_;
}
const ::protos::View_Wide&
PlayerAction::_Internal::view_wide(const PlayerAction* msg) {
  return *msg->_impl_.action_.view_wide_;
}
const ::protos::HeliosGoalie&
PlayerAction::_Internal::helios_goalie(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_goalie_;
}
const ::protos::HeliosGoalieMove&
PlayerAction::_Internal::helios_goalie_move(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_goalie_move_;
}
const ::protos::HeliosGoalieKick&
PlayerAction::_Internal::helios_goalie_kick(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_goalie_kick_;
}
const ::protos::HeliosShoot&
PlayerAction::_Internal::helios_shoot(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_shoot_;
}
const ::protos::HeliosChainAction&
PlayerAction::_Internal::helios_chain_action(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_chain_action_;
}
const ::protos::HeliosBasicOffensive&
PlayerAction::_Internal::helios_basic_offensive(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_basic_offensive_;
}
const ::protos::HeliosBasicMove&
PlayerAction::_Internal::helios_basic_move(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_basic_move_;
}
const ::protos::HeliosSetPlay&
PlayerAction::_Internal::helios_set_play(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_set_play_;
}
const ::protos::HeliosPenalty&
PlayerAction::_Internal::helios_penalty(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_penalty_;
}
const ::protos::HeliosCommunicaion&
PlayerAction::_Internal::helios_communication(const PlayerAction* msg) {
  return *msg->_impl_.action_.helios_communication_;
}
void PlayerAction::set_allocated_dash(::protos::Dash* dash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (dash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dash);
    if (message_arena != submessage_arena) {
      dash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dash, submessage_arena);
    }
    set_has_dash();
    _impl_.action_.dash_ = dash;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.dash)
}
void PlayerAction::set_allocated_turn(::protos::Turn* turn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (turn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(turn);
    if (message_arena != submessage_arena) {
      turn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn, submessage_arena);
    }
    set_has_turn();
    _impl_.action_.turn_ = turn;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.turn)
}
void PlayerAction::set_allocated_kick(::protos::Kick* kick) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (kick) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kick);
    if (message_arena != submessage_arena) {
      kick = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kick, submessage_arena);
    }
    set_has_kick();
    _impl_.action_.kick_ = kick;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.kick)
}
void PlayerAction::set_allocated_tackle(::protos::Tackle* tackle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (tackle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tackle);
    if (message_arena != submessage_arena) {
      tackle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tackle, submessage_arena);
    }
    set_has_tackle();
    _impl_.action_.tackle_ = tackle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.tackle)
}
void PlayerAction::set_allocated_catch_(::protos::Catch* catch_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (catch_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catch_);
    if (message_arena != submessage_arena) {
      catch_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catch_, submessage_arena);
    }
    set_has_catch_();
    _impl_.action_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.catch)
}
void PlayerAction::set_allocated_move(::protos::Move* move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(move);
    if (message_arena != submessage_arena) {
      move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move, submessage_arena);
    }
    set_has_move();
    _impl_.action_.move_ = move;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.move)
}
void PlayerAction::set_allocated_turn_neck(::protos::TurnNeck* turn_neck) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (turn_neck) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(turn_neck);
    if (message_arena != submessage_arena) {
      turn_neck = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_neck, submessage_arena);
    }
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = turn_neck;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.turn_neck)
}
void PlayerAction::set_allocated_change_view(::protos::ChangeView* change_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (change_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_view);
    if (message_arena != submessage_arena) {
      change_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_view, submessage_arena);
    }
    set_has_change_view();
    _impl_.action_.change_view_ = change_view;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.change_view)
}
void PlayerAction::set_allocated_say(::protos::Say* say) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (say) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(say);
    if (message_arena != submessage_arena) {
      say = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, say, submessage_arena);
    }
    set_has_say();
    _impl_.action_.say_ = say;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.say)
}
void PlayerAction::set_allocated_point_to(::protos::PointTo* point_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (point_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_to);
    if (message_arena != submessage_arena) {
      point_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_to, submessage_arena);
    }
    set_has_point_to();
    _impl_.action_.point_to_ = point_to;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.point_to)
}
void PlayerAction::set_allocated_point_to_of(::protos::PointToOf* point_to_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (point_to_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_to_of);
    if (message_arena != submessage_arena) {
      point_to_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_to_of, submessage_arena);
    }
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = point_to_of;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.point_to_of)
}
void PlayerAction::set_allocated_attention_to(::protos::AttentionTo* attention_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (attention_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attention_to);
    if (message_arena != submessage_arena) {
      attention_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attention_to, submessage_arena);
    }
    set_has_attention_to();
    _impl_.action_.attention_to_ = attention_to;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.attention_to)
}
void PlayerAction::set_allocated_attention_to_of(::protos::AttentionToOf* attention_to_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (attention_to_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attention_to_of);
    if (message_arena != submessage_arena) {
      attention_to_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attention_to_of, submessage_arena);
    }
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = attention_to_of;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.attention_to_of)
}
void PlayerAction::set_allocated_log(::protos::Log* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    set_has_log();
    _impl_.action_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.log)
}
void PlayerAction::set_allocated_debug_client(::protos::DebugClient* debug_client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (debug_client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(debug_client);
    if (message_arena != submessage_arena) {
      debug_client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug_client, submessage_arena);
    }
    set_has_debug_client();
    _impl_.action_.debug_client_ = debug_client;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.debug_client)
}
void PlayerAction::set_allocated_body_go_to_point(::protos::Body_GoToPoint* body_go_to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_go_to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_go_to_point);
    if (message_arena != submessage_arena) {
      body_go_to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_go_to_point, submessage_arena);
    }
    set_has_body_go_to_point();
    _impl_.action_.body_go_to_point_ = body_go_to_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_go_to_point)
}
void PlayerAction::set_allocated_body_smart_kick(::protos::Body_SmartKick* body_smart_kick) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_smart_kick) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_smart_kick);
    if (message_arena != submessage_arena) {
      body_smart_kick = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_smart_kick, submessage_arena);
    }
    set_has_body_smart_kick();
    _impl_.action_.body_smart_kick_ = body_smart_kick;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_smart_kick)
}
void PlayerAction::set_allocated_bhv_before_kick_off(::protos::Bhv_BeforeKickOff* bhv_before_kick_off) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_before_kick_off) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_before_kick_off);
    if (message_arena != submessage_arena) {
      bhv_before_kick_off = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_before_kick_off, submessage_arena);
    }
    set_has_bhv_before_kick_off();
    _impl_.action_.bhv_before_kick_off_ = bhv_before_kick_off;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_before_kick_off)
}
void PlayerAction::set_allocated_bhv_body_neck_to_ball(::protos::Bhv_BodyNeckToBall* bhv_body_neck_to_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_body_neck_to_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_body_neck_to_ball);
    if (message_arena != submessage_arena) {
      bhv_body_neck_to_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_body_neck_to_ball, submessage_arena);
    }
    set_has_bhv_body_neck_to_ball();
    _impl_.action_.bhv_body_neck_to_ball_ = bhv_body_neck_to_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_body_neck_to_ball)
}
void PlayerAction::set_allocated_bhv_body_neck_to_point(::protos::Bhv_BodyNeckToPoint* bhv_body_neck_to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_body_neck_to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_body_neck_to_point);
    if (message_arena != submessage_arena) {
      bhv_body_neck_to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_body_neck_to_point, submessage_arena);
    }
    set_has_bhv_body_neck_to_point();
    _impl_.action_.bhv_body_neck_to_point_ = bhv_body_neck_to_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_body_neck_to_point)
}
void PlayerAction::set_allocated_bhv_emergency(::protos::Bhv_Emergency* bhv_emergency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_emergency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_emergency);
    if (message_arena != submessage_arena) {
      bhv_emergency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_emergency, submessage_arena);
    }
    set_has_bhv_emergency();
    _impl_.action_.bhv_emergency_ = bhv_emergency;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_emergency)
}
void PlayerAction::set_allocated_bhv_go_to_point_look_ball(::protos::Bhv_GoToPointLookBall* bhv_go_to_point_look_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_go_to_point_look_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_go_to_point_look_ball);
    if (message_arena != submessage_arena) {
      bhv_go_to_point_look_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_go_to_point_look_ball, submessage_arena);
    }
    set_has_bhv_go_to_point_look_ball();
    _impl_.action_.bhv_go_to_point_look_ball_ = bhv_go_to_point_look_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_go_to_point_look_ball)
}
void PlayerAction::set_allocated_bhv_neck_body_to_ball(::protos::Bhv_NeckBodyToBall* bhv_neck_body_to_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_neck_body_to_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_neck_body_to_ball);
    if (message_arena != submessage_arena) {
      bhv_neck_body_to_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_neck_body_to_ball, submessage_arena);
    }
    set_has_bhv_neck_body_to_ball();
    _impl_.action_.bhv_neck_body_to_ball_ = bhv_neck_body_to_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_neck_body_to_ball)
}
void PlayerAction::set_allocated_bhv_neck_body_to_point(::protos::Bhv_NeckBodyToPoint* bhv_neck_body_to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_neck_body_to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_neck_body_to_point);
    if (message_arena != submessage_arena) {
      bhv_neck_body_to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_neck_body_to_point, submessage_arena);
    }
    set_has_bhv_neck_body_to_point();
    _impl_.action_.bhv_neck_body_to_point_ = bhv_neck_body_to_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_neck_body_to_point)
}
void PlayerAction::set_allocated_bhv_scan_field(::protos::Bhv_ScanField* bhv_scan_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (bhv_scan_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bhv_scan_field);
    if (message_arena != submessage_arena) {
      bhv_scan_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhv_scan_field, submessage_arena);
    }
    set_has_bhv_scan_field();
    _impl_.action_.bhv_scan_field_ = bhv_scan_field;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.bhv_scan_field)
}
void PlayerAction::set_allocated_body_advance_ball(::protos::Body_AdvanceBall* body_advance_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_advance_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_advance_ball);
    if (message_arena != submessage_arena) {
      body_advance_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_advance_ball, submessage_arena);
    }
    set_has_body_advance_ball();
    _impl_.action_.body_advance_ball_ = body_advance_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_advance_ball)
}
void PlayerAction::set_allocated_body_clear_ball(::protos::Body_ClearBall* body_clear_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_clear_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_clear_ball);
    if (message_arena != submessage_arena) {
      body_clear_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_clear_ball, submessage_arena);
    }
    set_has_body_clear_ball();
    _impl_.action_.body_clear_ball_ = body_clear_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_clear_ball)
}
void PlayerAction::set_allocated_body_dribble(::protos::Body_Dribble* body_dribble) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_dribble) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_dribble);
    if (message_arena != submessage_arena) {
      body_dribble = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_dribble, submessage_arena);
    }
    set_has_body_dribble();
    _impl_.action_.body_dribble_ = body_dribble;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_dribble)
}
void PlayerAction::set_allocated_body_go_to_point_dodge(::protos::Body_GoToPointDodge* body_go_to_point_dodge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_go_to_point_dodge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_go_to_point_dodge);
    if (message_arena != submessage_arena) {
      body_go_to_point_dodge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_go_to_point_dodge, submessage_arena);
    }
    set_has_body_go_to_point_dodge();
    _impl_.action_.body_go_to_point_dodge_ = body_go_to_point_dodge;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_go_to_point_dodge)
}
void PlayerAction::set_allocated_body_hold_ball(::protos::Body_HoldBall* body_hold_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_hold_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_hold_ball);
    if (message_arena != submessage_arena) {
      body_hold_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_hold_ball, submessage_arena);
    }
    set_has_body_hold_ball();
    _impl_.action_.body_hold_ball_ = body_hold_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_hold_ball)
}
void PlayerAction::set_allocated_body_intercept(::protos::Body_Intercept* body_intercept) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_intercept) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_intercept);
    if (message_arena != submessage_arena) {
      body_intercept = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_intercept, submessage_arena);
    }
    set_has_body_intercept();
    _impl_.action_.body_intercept_ = body_intercept;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_intercept)
}
void PlayerAction::set_allocated_body_kick_one_step(::protos::Body_KickOneStep* body_kick_one_step) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_kick_one_step) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_kick_one_step);
    if (message_arena != submessage_arena) {
      body_kick_one_step = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_kick_one_step, submessage_arena);
    }
    set_has_body_kick_one_step();
    _impl_.action_.body_kick_one_step_ = body_kick_one_step;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_kick_one_step)
}
void PlayerAction::set_allocated_body_stop_ball(::protos::Body_StopBall* body_stop_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_stop_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_stop_ball);
    if (message_arena != submessage_arena) {
      body_stop_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_stop_ball, submessage_arena);
    }
    set_has_body_stop_ball();
    _impl_.action_.body_stop_ball_ = body_stop_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_stop_ball)
}
void PlayerAction::set_allocated_body_stop_dash(::protos::Body_StopDash* body_stop_dash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_stop_dash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_stop_dash);
    if (message_arena != submessage_arena) {
      body_stop_dash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_stop_dash, submessage_arena);
    }
    set_has_body_stop_dash();
    _impl_.action_.body_stop_dash_ = body_stop_dash;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_stop_dash)
}
void PlayerAction::set_allocated_body_tackle_to_point(::protos::Body_TackleToPoint* body_tackle_to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_tackle_to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_tackle_to_point);
    if (message_arena != submessage_arena) {
      body_tackle_to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_tackle_to_point, submessage_arena);
    }
    set_has_body_tackle_to_point();
    _impl_.action_.body_tackle_to_point_ = body_tackle_to_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_tackle_to_point)
}
void PlayerAction::set_allocated_body_turn_to_angle(::protos::Body_TurnToAngle* body_turn_to_angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_turn_to_angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_turn_to_angle);
    if (message_arena != submessage_arena) {
      body_turn_to_angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_turn_to_angle, submessage_arena);
    }
    set_has_body_turn_to_angle();
    _impl_.action_.body_turn_to_angle_ = body_turn_to_angle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_turn_to_angle)
}
void PlayerAction::set_allocated_body_turn_to_ball(::protos::Body_TurnToBall* body_turn_to_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_turn_to_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_turn_to_ball);
    if (message_arena != submessage_arena) {
      body_turn_to_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_turn_to_ball, submessage_arena);
    }
    set_has_body_turn_to_ball();
    _impl_.action_.body_turn_to_ball_ = body_turn_to_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_turn_to_ball)
}
void PlayerAction::set_allocated_body_turn_to_point(::protos::Body_TurnToPoint* body_turn_to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (body_turn_to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_turn_to_point);
    if (message_arena != submessage_arena) {
      body_turn_to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_turn_to_point, submessage_arena);
    }
    set_has_body_turn_to_point();
    _impl_.action_.body_turn_to_point_ = body_turn_to_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.body_turn_to_point)
}
void PlayerAction::set_allocated_focus_move_to_point(::protos::Focus_MoveToPoint* focus_move_to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (focus_move_to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(focus_move_to_point);
    if (message_arena != submessage_arena) {
      focus_move_to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, focus_move_to_point, submessage_arena);
    }
    set_has_focus_move_to_point();
    _impl_.action_.focus_move_to_point_ = focus_move_to_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.focus_move_to_point)
}
void PlayerAction::set_allocated_focus_reset(::protos::Focus_Reset* focus_reset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (focus_reset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(focus_reset);
    if (message_arena != submessage_arena) {
      focus_reset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, focus_reset, submessage_arena);
    }
    set_has_focus_reset();
    _impl_.action_.focus_reset_ = focus_reset;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.focus_reset)
}
void PlayerAction::set_allocated_neck_scan_field(::protos::Neck_ScanField* neck_scan_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_scan_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_scan_field);
    if (message_arena != submessage_arena) {
      neck_scan_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_scan_field, submessage_arena);
    }
    set_has_neck_scan_field();
    _impl_.action_.neck_scan_field_ = neck_scan_field;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_scan_field)
}
void PlayerAction::set_allocated_neck_scan_players(::protos::Neck_ScanPlayers* neck_scan_players) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_scan_players) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_scan_players);
    if (message_arena != submessage_arena) {
      neck_scan_players = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_scan_players, submessage_arena);
    }
    set_has_neck_scan_players();
    _impl_.action_.neck_scan_players_ = neck_scan_players;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_scan_players)
}
void PlayerAction::set_allocated_neck_turn_to_ball_and_player(::protos::Neck_TurnToBallAndPlayer* neck_turn_to_ball_and_player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_ball_and_player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_ball_and_player);
    if (message_arena != submessage_arena) {
      neck_turn_to_ball_and_player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_ball_and_player, submessage_arena);
    }
    set_has_neck_turn_to_ball_and_player();
    _impl_.action_.neck_turn_to_ball_and_player_ = neck_turn_to_ball_and_player;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_ball_and_player)
}
void PlayerAction::set_allocated_neck_turn_to_ball_or_scan(::protos::Neck_TurnToBallOrScan* neck_turn_to_ball_or_scan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_ball_or_scan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_ball_or_scan);
    if (message_arena != submessage_arena) {
      neck_turn_to_ball_or_scan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_ball_or_scan, submessage_arena);
    }
    set_has_neck_turn_to_ball_or_scan();
    _impl_.action_.neck_turn_to_ball_or_scan_ = neck_turn_to_ball_or_scan;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_ball_or_scan)
}
void PlayerAction::set_allocated_neck_turn_to_ball(::protos::Neck_TurnToBall* neck_turn_to_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_ball);
    if (message_arena != submessage_arena) {
      neck_turn_to_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_ball, submessage_arena);
    }
    set_has_neck_turn_to_ball();
    _impl_.action_.neck_turn_to_ball_ = neck_turn_to_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_ball)
}
void PlayerAction::set_allocated_neck_turn_to_goalie_or_scan(::protos::Neck_TurnToGoalieOrScan* neck_turn_to_goalie_or_scan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_goalie_or_scan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_goalie_or_scan);
    if (message_arena != submessage_arena) {
      neck_turn_to_goalie_or_scan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_goalie_or_scan, submessage_arena);
    }
    set_has_neck_turn_to_goalie_or_scan();
    _impl_.action_.neck_turn_to_goalie_or_scan_ = neck_turn_to_goalie_or_scan;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_goalie_or_scan)
}
void PlayerAction::set_allocated_neck_turn_to_low_conf_teammate(::protos::Neck_TurnToLowConfTeammate* neck_turn_to_low_conf_teammate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_low_conf_teammate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_low_conf_teammate);
    if (message_arena != submessage_arena) {
      neck_turn_to_low_conf_teammate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_low_conf_teammate, submessage_arena);
    }
    set_has_neck_turn_to_low_conf_teammate();
    _impl_.action_.neck_turn_to_low_conf_teammate_ = neck_turn_to_low_conf_teammate;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_low_conf_teammate)
}
void PlayerAction::set_allocated_neck_turn_to_player_or_scan(::protos::Neck_TurnToPlayerOrScan* neck_turn_to_player_or_scan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_player_or_scan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_player_or_scan);
    if (message_arena != submessage_arena) {
      neck_turn_to_player_or_scan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_player_or_scan, submessage_arena);
    }
    set_has_neck_turn_to_player_or_scan();
    _impl_.action_.neck_turn_to_player_or_scan_ = neck_turn_to_player_or_scan;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_player_or_scan)
}
void PlayerAction::set_allocated_neck_turn_to_point(::protos::Neck_TurnToPoint* neck_turn_to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_point);
    if (message_arena != submessage_arena) {
      neck_turn_to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_point, submessage_arena);
    }
    set_has_neck_turn_to_point();
    _impl_.action_.neck_turn_to_point_ = neck_turn_to_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_point)
}
void PlayerAction::set_allocated_neck_turn_to_relative(::protos::Neck_TurnToRelative* neck_turn_to_relative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (neck_turn_to_relative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neck_turn_to_relative);
    if (message_arena != submessage_arena) {
      neck_turn_to_relative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neck_turn_to_relative, submessage_arena);
    }
    set_has_neck_turn_to_relative();
    _impl_.action_.neck_turn_to_relative_ = neck_turn_to_relative;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.neck_turn_to_relative)
}
void PlayerAction::set_allocated_view_change_width(::protos::View_ChangeWidth* view_change_width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (view_change_width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view_change_width);
    if (message_arena != submessage_arena) {
      view_change_width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_change_width, submessage_arena);
    }
    set_has_view_change_width();
    _impl_.action_.view_change_width_ = view_change_width;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.view_change_width)
}
void PlayerAction::set_allocated_view_normal(::protos::View_Normal* view_normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (view_normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view_normal);
    if (message_arena != submessage_arena) {
      view_normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_normal, submessage_arena);
    }
    set_has_view_normal();
    _impl_.action_.view_normal_ = view_normal;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.view_normal)
}
void PlayerAction::set_allocated_view_synch(::protos::View_Synch* view_synch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (view_synch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view_synch);
    if (message_arena != submessage_arena) {
      view_synch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_synch, submessage_arena);
    }
    set_has_view_synch();
    _impl_.action_.view_synch_ = view_synch;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.view_synch)
}
void PlayerAction::set_allocated_view_wide(::protos::View_Wide* view_wide) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (view_wide) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view_wide);
    if (message_arena != submessage_arena) {
      view_wide = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_wide, submessage_arena);
    }
    set_has_view_wide();
    _impl_.action_.view_wide_ = view_wide;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.view_wide)
}
void PlayerAction::set_allocated_helios_goalie(::protos::HeliosGoalie* helios_goalie) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_goalie) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_goalie);
    if (message_arena != submessage_arena) {
      helios_goalie = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_goalie, submessage_arena);
    }
    set_has_helios_goalie();
    _impl_.action_.helios_goalie_ = helios_goalie;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_goalie)
}
void PlayerAction::set_allocated_helios_goalie_move(::protos::HeliosGoalieMove* helios_goalie_move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_goalie_move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_goalie_move);
    if (message_arena != submessage_arena) {
      helios_goalie_move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_goalie_move, submessage_arena);
    }
    set_has_helios_goalie_move();
    _impl_.action_.helios_goalie_move_ = helios_goalie_move;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_goalie_move)
}
void PlayerAction::set_allocated_helios_goalie_kick(::protos::HeliosGoalieKick* helios_goalie_kick) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_goalie_kick) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_goalie_kick);
    if (message_arena != submessage_arena) {
      helios_goalie_kick = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_goalie_kick, submessage_arena);
    }
    set_has_helios_goalie_kick();
    _impl_.action_.helios_goalie_kick_ = helios_goalie_kick;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_goalie_kick)
}
void PlayerAction::set_allocated_helios_shoot(::protos::HeliosShoot* helios_shoot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_shoot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_shoot);
    if (message_arena != submessage_arena) {
      helios_shoot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_shoot, submessage_arena);
    }
    set_has_helios_shoot();
    _impl_.action_.helios_shoot_ = helios_shoot;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_shoot)
}
void PlayerAction::set_allocated_helios_chain_action(::protos::HeliosChainAction* helios_chain_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_chain_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_chain_action);
    if (message_arena != submessage_arena) {
      helios_chain_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_chain_action, submessage_arena);
    }
    set_has_helios_chain_action();
    _impl_.action_.helios_chain_action_ = helios_chain_action;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_chain_action)
}
void PlayerAction::set_allocated_helios_basic_offensive(::protos::HeliosBasicOffensive* helios_basic_offensive) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_basic_offensive) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_basic_offensive);
    if (message_arena != submessage_arena) {
      helios_basic_offensive = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_basic_offensive, submessage_arena);
    }
    set_has_helios_basic_offensive();
    _impl_.action_.helios_basic_offensive_ = helios_basic_offensive;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_basic_offensive)
}
void PlayerAction::set_allocated_helios_basic_move(::protos::HeliosBasicMove* helios_basic_move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_basic_move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_basic_move);
    if (message_arena != submessage_arena) {
      helios_basic_move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_basic_move, submessage_arena);
    }
    set_has_helios_basic_move();
    _impl_.action_.helios_basic_move_ = helios_basic_move;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_basic_move)
}
void PlayerAction::set_allocated_helios_set_play(::protos::HeliosSetPlay* helios_set_play) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_set_play) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_set_play);
    if (message_arena != submessage_arena) {
      helios_set_play = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_set_play, submessage_arena);
    }
    set_has_helios_set_play();
    _impl_.action_.helios_set_play_ = helios_set_play;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_set_play)
}
void PlayerAction::set_allocated_helios_penalty(::protos::HeliosPenalty* helios_penalty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_penalty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_penalty);
    if (message_arena != submessage_arena) {
      helios_penalty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_penalty, submessage_arena);
    }
    set_has_helios_penalty();
    _impl_.action_.helios_penalty_ = helios_penalty;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_penalty)
}
void PlayerAction::set_allocated_helios_communication(::protos::HeliosCommunicaion* helios_communication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (helios_communication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helios_communication);
    if (message_arena != submessage_arena) {
      helios_communication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helios_communication, submessage_arena);
    }
    set_has_helios_communication();
    _impl_.action_.helios_communication_ = helios_communication;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.PlayerAction.helios_communication)
}
PlayerAction::PlayerAction(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PlayerAction)
}
PlayerAction::PlayerAction(const PlayerAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kDash: {
      _this->_internal_mutable_dash()->::protos::Dash::MergeFrom(
          from._internal_dash());
      break;
    }
    case kTurn: {
      _this->_internal_mutable_turn()->::protos::Turn::MergeFrom(
          from._internal_turn());
      break;
    }
    case kKick: {
      _this->_internal_mutable_kick()->::protos::Kick::MergeFrom(
          from._internal_kick());
      break;
    }
    case kTackle: {
      _this->_internal_mutable_tackle()->::protos::Tackle::MergeFrom(
          from._internal_tackle());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::protos::Catch::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kMove: {
      _this->_internal_mutable_move()->::protos::Move::MergeFrom(
          from._internal_move());
      break;
    }
    case kTurnNeck: {
      _this->_internal_mutable_turn_neck()->::protos::TurnNeck::MergeFrom(
          from._internal_turn_neck());
      break;
    }
    case kChangeView: {
      _this->_internal_mutable_change_view()->::protos::ChangeView::MergeFrom(
          from._internal_change_view());
      break;
    }
    case kSay: {
      _this->_internal_mutable_say()->::protos::Say::MergeFrom(
          from._internal_say());
      break;
    }
    case kPointTo: {
      _this->_internal_mutable_point_to()->::protos::PointTo::MergeFrom(
          from._internal_point_to());
      break;
    }
    case kPointToOf: {
      _this->_internal_mutable_point_to_of()->::protos::PointToOf::MergeFrom(
          from._internal_point_to_of());
      break;
    }
    case kAttentionTo: {
      _this->_internal_mutable_attention_to()->::protos::AttentionTo::MergeFrom(
          from._internal_attention_to());
      break;
    }
    case kAttentionToOf: {
      _this->_internal_mutable_attention_to_of()->::protos::AttentionToOf::MergeFrom(
          from._internal_attention_to_of());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::protos::Log::MergeFrom(
          from._internal_log());
      break;
    }
    case kDebugClient: {
      _this->_internal_mutable_debug_client()->::protos::DebugClient::MergeFrom(
          from._internal_debug_client());
      break;
    }
    case kBodyGoToPoint: {
      _this->_internal_mutable_body_go_to_point()->::protos::Body_GoToPoint::MergeFrom(
          from._internal_body_go_to_point());
      break;
    }
    case kBodySmartKick: {
      _this->_internal_mutable_body_smart_kick()->::protos::Body_SmartKick::MergeFrom(
          from._internal_body_smart_kick());
      break;
    }
    case kBhvBeforeKickOff: {
      _this->_internal_mutable_bhv_before_kick_off()->::protos::Bhv_BeforeKickOff::MergeFrom(
          from._internal_bhv_before_kick_off());
      break;
    }
    case kBhvBodyNeckToBall: {
      _this->_internal_mutable_bhv_body_neck_to_ball()->::protos::Bhv_BodyNeckToBall::MergeFrom(
          from._internal_bhv_body_neck_to_ball());
      break;
    }
    case kBhvBodyNeckToPoint: {
      _this->_internal_mutable_bhv_body_neck_to_point()->::protos::Bhv_BodyNeckToPoint::MergeFrom(
          from._internal_bhv_body_neck_to_point());
      break;
    }
    case kBhvEmergency: {
      _this->_internal_mutable_bhv_emergency()->::protos::Bhv_Emergency::MergeFrom(
          from._internal_bhv_emergency());
      break;
    }
    case kBhvGoToPointLookBall: {
      _this->_internal_mutable_bhv_go_to_point_look_ball()->::protos::Bhv_GoToPointLookBall::MergeFrom(
          from._internal_bhv_go_to_point_look_ball());
      break;
    }
    case kBhvNeckBodyToBall: {
      _this->_internal_mutable_bhv_neck_body_to_ball()->::protos::Bhv_NeckBodyToBall::MergeFrom(
          from._internal_bhv_neck_body_to_ball());
      break;
    }
    case kBhvNeckBodyToPoint: {
      _this->_internal_mutable_bhv_neck_body_to_point()->::protos::Bhv_NeckBodyToPoint::MergeFrom(
          from._internal_bhv_neck_body_to_point());
      break;
    }
    case kBhvScanField: {
      _this->_internal_mutable_bhv_scan_field()->::protos::Bhv_ScanField::MergeFrom(
          from._internal_bhv_scan_field());
      break;
    }
    case kBodyAdvanceBall: {
      _this->_internal_mutable_body_advance_ball()->::protos::Body_AdvanceBall::MergeFrom(
          from._internal_body_advance_ball());
      break;
    }
    case kBodyClearBall: {
      _this->_internal_mutable_body_clear_ball()->::protos::Body_ClearBall::MergeFrom(
          from._internal_body_clear_ball());
      break;
    }
    case kBodyDribble: {
      _this->_internal_mutable_body_dribble()->::protos::Body_Dribble::MergeFrom(
          from._internal_body_dribble());
      break;
    }
    case kBodyGoToPointDodge: {
      _this->_internal_mutable_body_go_to_point_dodge()->::protos::Body_GoToPointDodge::MergeFrom(
          from._internal_body_go_to_point_dodge());
      break;
    }
    case kBodyHoldBall: {
      _this->_internal_mutable_body_hold_ball()->::protos::Body_HoldBall::MergeFrom(
          from._internal_body_hold_ball());
      break;
    }
    case kBodyIntercept: {
      _this->_internal_mutable_body_intercept()->::protos::Body_Intercept::MergeFrom(
          from._internal_body_intercept());
      break;
    }
    case kBodyKickOneStep: {
      _this->_internal_mutable_body_kick_one_step()->::protos::Body_KickOneStep::MergeFrom(
          from._internal_body_kick_one_step());
      break;
    }
    case kBodyStopBall: {
      _this->_internal_mutable_body_stop_ball()->::protos::Body_StopBall::MergeFrom(
          from._internal_body_stop_ball());
      break;
    }
    case kBodyStopDash: {
      _this->_internal_mutable_body_stop_dash()->::protos::Body_StopDash::MergeFrom(
          from._internal_body_stop_dash());
      break;
    }
    case kBodyTackleToPoint: {
      _this->_internal_mutable_body_tackle_to_point()->::protos::Body_TackleToPoint::MergeFrom(
          from._internal_body_tackle_to_point());
      break;
    }
    case kBodyTurnToAngle: {
      _this->_internal_mutable_body_turn_to_angle()->::protos::Body_TurnToAngle::MergeFrom(
          from._internal_body_turn_to_angle());
      break;
    }
    case kBodyTurnToBall: {
      _this->_internal_mutable_body_turn_to_ball()->::protos::Body_TurnToBall::MergeFrom(
          from._internal_body_turn_to_ball());
      break;
    }
    case kBodyTurnToPoint: {
      _this->_internal_mutable_body_turn_to_point()->::protos::Body_TurnToPoint::MergeFrom(
          from._internal_body_turn_to_point());
      break;
    }
    case kFocusMoveToPoint: {
      _this->_internal_mutable_focus_move_to_point()->::protos::Focus_MoveToPoint::MergeFrom(
          from._internal_focus_move_to_point());
      break;
    }
    case kFocusReset: {
      _this->_internal_mutable_focus_reset()->::protos::Focus_Reset::MergeFrom(
          from._internal_focus_reset());
      break;
    }
    case kNeckScanField: {
      _this->_internal_mutable_neck_scan_field()->::protos::Neck_ScanField::MergeFrom(
          from._internal_neck_scan_field());
      break;
    }
    case kNeckScanPlayers: {
      _this->_internal_mutable_neck_scan_players()->::protos::Neck_ScanPlayers::MergeFrom(
          from._internal_neck_scan_players());
      break;
    }
    case kNeckTurnToBallAndPlayer: {
      _this->_internal_mutable_neck_turn_to_ball_and_player()->::protos::Neck_TurnToBallAndPlayer::MergeFrom(
          from._internal_neck_turn_to_ball_and_player());
      break;
    }
    case kNeckTurnToBallOrScan: {
      _this->_internal_mutable_neck_turn_to_ball_or_scan()->::protos::Neck_TurnToBallOrScan::MergeFrom(
          from._internal_neck_turn_to_ball_or_scan());
      break;
    }
    case kNeckTurnToBall: {
      _this->_internal_mutable_neck_turn_to_ball()->::protos::Neck_TurnToBall::MergeFrom(
          from._internal_neck_turn_to_ball());
      break;
    }
    case kNeckTurnToGoalieOrScan: {
      _this->_internal_mutable_neck_turn_to_goalie_or_scan()->::protos::Neck_TurnToGoalieOrScan::MergeFrom(
          from._internal_neck_turn_to_goalie_or_scan());
      break;
    }
    case kNeckTurnToLowConfTeammate: {
      _this->_internal_mutable_neck_turn_to_low_conf_teammate()->::protos::Neck_TurnToLowConfTeammate::MergeFrom(
          from._internal_neck_turn_to_low_conf_teammate());
      break;
    }
    case kNeckTurnToPlayerOrScan: {
      _this->_internal_mutable_neck_turn_to_player_or_scan()->::protos::Neck_TurnToPlayerOrScan::MergeFrom(
          from._internal_neck_turn_to_player_or_scan());
      break;
    }
    case kNeckTurnToPoint: {
      _this->_internal_mutable_neck_turn_to_point()->::protos::Neck_TurnToPoint::MergeFrom(
          from._internal_neck_turn_to_point());
      break;
    }
    case kNeckTurnToRelative: {
      _this->_internal_mutable_neck_turn_to_relative()->::protos::Neck_TurnToRelative::MergeFrom(
          from._internal_neck_turn_to_relative());
      break;
    }
    case kViewChangeWidth: {
      _this->_internal_mutable_view_change_width()->::protos::View_ChangeWidth::MergeFrom(
          from._internal_view_change_width());
      break;
    }
    case kViewNormal: {
      _this->_internal_mutable_view_normal()->::protos::View_Normal::MergeFrom(
          from._internal_view_normal());
      break;
    }
    case kViewSynch: {
      _this->_internal_mutable_view_synch()->::protos::View_Synch::MergeFrom(
          from._internal_view_synch());
      break;
    }
    case kViewWide: {
      _this->_internal_mutable_view_wide()->::protos::View_Wide::MergeFrom(
          from._internal_view_wide());
      break;
    }
    case kHeliosGoalie: {
      _this->_internal_mutable_helios_goalie()->::protos::HeliosGoalie::MergeFrom(
          from._internal_helios_goalie());
      break;
    }
    case kHeliosGoalieMove: {
      _this->_internal_mutable_helios_goalie_move()->::protos::HeliosGoalieMove::MergeFrom(
          from._internal_helios_goalie_move());
      break;
    }
    case kHeliosGoalieKick: {
      _this->_internal_mutable_helios_goalie_kick()->::protos::HeliosGoalieKick::MergeFrom(
          from._internal_helios_goalie_kick());
      break;
    }
    case kHeliosShoot: {
      _this->_internal_mutable_helios_shoot()->::protos::HeliosShoot::MergeFrom(
          from._internal_helios_shoot());
      break;
    }
    case kHeliosChainAction: {
      _this->_internal_mutable_helios_chain_action()->::protos::HeliosChainAction::MergeFrom(
          from._internal_helios_chain_action());
      break;
    }
    case kHeliosBasicOffensive: {
      _this->_internal_mutable_helios_basic_offensive()->::protos::HeliosBasicOffensive::MergeFrom(
          from._internal_helios_basic_offensive());
      break;
    }
    case kHeliosBasicMove: {
      _this->_internal_mutable_helios_basic_move()->::protos::HeliosBasicMove::MergeFrom(
          from._internal_helios_basic_move());
      break;
    }
    case kHeliosSetPlay: {
      _this->_internal_mutable_helios_set_play()->::protos::HeliosSetPlay::MergeFrom(
          from._internal_helios_set_play());
      break;
    }
    case kHeliosPenalty: {
      _this->_internal_mutable_helios_penalty()->::protos::HeliosPenalty::MergeFrom(
          from._internal_helios_penalty());
      break;
    }
    case kHeliosCommunication: {
      _this->_internal_mutable_helios_communication()->::protos::HeliosCommunicaion::MergeFrom(
          from._internal_helios_communication());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.PlayerAction)
}

inline void PlayerAction::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_action();
}

PlayerAction::~PlayerAction() {
  // @@protoc_insertion_point(destructor:protos.PlayerAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerAction::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_action()) {
    clear_action();
  }
}

void PlayerAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerAction::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:protos.PlayerAction)
  switch (action_case()) {
    case kDash: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.dash_;
      }
      break;
    }
    case kTurn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.turn_;
      }
      break;
    }
    case kKick: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.kick_;
      }
      break;
    }
    case kTackle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.tackle_;
      }
      break;
    }
    case kCatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.catch__;
      }
      break;
    }
    case kMove: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.move_;
      }
      break;
    }
    case kTurnNeck: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.turn_neck_;
      }
      break;
    }
    case kChangeView: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.change_view_;
      }
      break;
    }
    case kSay: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.say_;
      }
      break;
    }
    case kPointTo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.point_to_;
      }
      break;
    }
    case kPointToOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.point_to_of_;
      }
      break;
    }
    case kAttentionTo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.attention_to_;
      }
      break;
    }
    case kAttentionToOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.attention_to_of_;
      }
      break;
    }
    case kLog: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.log_;
      }
      break;
    }
    case kDebugClient: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.debug_client_;
      }
      break;
    }
    case kBodyGoToPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_go_to_point_;
      }
      break;
    }
    case kBodySmartKick: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_smart_kick_;
      }
      break;
    }
    case kBhvBeforeKickOff: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_before_kick_off_;
      }
      break;
    }
    case kBhvBodyNeckToBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_body_neck_to_ball_;
      }
      break;
    }
    case kBhvBodyNeckToPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_body_neck_to_point_;
      }
      break;
    }
    case kBhvEmergency: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_emergency_;
      }
      break;
    }
    case kBhvGoToPointLookBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_go_to_point_look_ball_;
      }
      break;
    }
    case kBhvNeckBodyToBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_neck_body_to_ball_;
      }
      break;
    }
    case kBhvNeckBodyToPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_neck_body_to_point_;
      }
      break;
    }
    case kBhvScanField: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.bhv_scan_field_;
      }
      break;
    }
    case kBodyAdvanceBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_advance_ball_;
      }
      break;
    }
    case kBodyClearBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_clear_ball_;
      }
      break;
    }
    case kBodyDribble: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_dribble_;
      }
      break;
    }
    case kBodyGoToPointDodge: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_go_to_point_dodge_;
      }
      break;
    }
    case kBodyHoldBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_hold_ball_;
      }
      break;
    }
    case kBodyIntercept: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_intercept_;
      }
      break;
    }
    case kBodyKickOneStep: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_kick_one_step_;
      }
      break;
    }
    case kBodyStopBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_stop_ball_;
      }
      break;
    }
    case kBodyStopDash: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_stop_dash_;
      }
      break;
    }
    case kBodyTackleToPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_tackle_to_point_;
      }
      break;
    }
    case kBodyTurnToAngle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_turn_to_angle_;
      }
      break;
    }
    case kBodyTurnToBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_turn_to_ball_;
      }
      break;
    }
    case kBodyTurnToPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.body_turn_to_point_;
      }
      break;
    }
    case kFocusMoveToPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.focus_move_to_point_;
      }
      break;
    }
    case kFocusReset: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.focus_reset_;
      }
      break;
    }
    case kNeckScanField: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_scan_field_;
      }
      break;
    }
    case kNeckScanPlayers: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_scan_players_;
      }
      break;
    }
    case kNeckTurnToBallAndPlayer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_ball_and_player_;
      }
      break;
    }
    case kNeckTurnToBallOrScan: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_ball_or_scan_;
      }
      break;
    }
    case kNeckTurnToBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_ball_;
      }
      break;
    }
    case kNeckTurnToGoalieOrScan: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_goalie_or_scan_;
      }
      break;
    }
    case kNeckTurnToLowConfTeammate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_low_conf_teammate_;
      }
      break;
    }
    case kNeckTurnToPlayerOrScan: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_player_or_scan_;
      }
      break;
    }
    case kNeckTurnToPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_point_;
      }
      break;
    }
    case kNeckTurnToRelative: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.neck_turn_to_relative_;
      }
      break;
    }
    case kViewChangeWidth: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.view_change_width_;
      }
      break;
    }
    case kViewNormal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.view_normal_;
      }
      break;
    }
    case kViewSynch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.view_synch_;
      }
      break;
    }
    case kViewWide: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.view_wide_;
      }
      break;
    }
    case kHeliosGoalie: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_goalie_;
      }
      break;
    }
    case kHeliosGoalieMove: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_goalie_move_;
      }
      break;
    }
    case kHeliosGoalieKick: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_goalie_kick_;
      }
      break;
    }
    case kHeliosShoot: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_shoot_;
      }
      break;
    }
    case kHeliosChainAction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_chain_action_;
      }
      break;
    }
    case kHeliosBasicOffensive: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_basic_offensive_;
      }
      break;
    }
    case kHeliosBasicMove: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_basic_move_;
      }
      break;
    }
    case kHeliosSetPlay: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_set_play_;
      }
      break;
    }
    case kHeliosPenalty: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_penalty_;
      }
      break;
    }
    case kHeliosCommunication: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.helios_communication_;
      }
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}


void PlayerAction::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PlayerAction)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Dash dash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dash(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Turn turn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Kick kick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_kick(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Tackle tackle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_tackle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Catch catch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_catch_(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Move move = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_move(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.TurnNeck turn_neck = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn_neck(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ChangeView change_view = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_view(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Say say = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_say(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PointTo point_to = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_to(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PointToOf point_to_of = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_to_of(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AttentionTo attention_to = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_attention_to(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AttentionToOf attention_to_of = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_attention_to_of(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Log log = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_log(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DebugClient debug_client = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_debug_client(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_GoToPoint body_go_to_point = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_go_to_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_SmartKick body_smart_kick = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_smart_kick(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_BeforeKickOff bhv_before_kick_off = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_before_kick_off(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_BodyNeckToBall bhv_body_neck_to_ball = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_body_neck_to_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_BodyNeckToPoint bhv_body_neck_to_point = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_body_neck_to_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_Emergency bhv_emergency = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_emergency(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_GoToPointLookBall bhv_go_to_point_look_ball = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_go_to_point_look_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_NeckBodyToBall bhv_neck_body_to_ball = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_neck_body_to_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_NeckBodyToPoint bhv_neck_body_to_point = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_neck_body_to_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Bhv_ScanField bhv_scan_field = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_bhv_scan_field(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_AdvanceBall body_advance_ball = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_advance_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_ClearBall body_clear_ball = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_clear_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_Dribble body_dribble = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_dribble(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_GoToPointDodge body_go_to_point_dodge = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_go_to_point_dodge(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_HoldBall body_hold_ball = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_hold_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_Intercept body_intercept = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_intercept(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_KickOneStep body_kick_one_step = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_kick_one_step(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_StopBall body_stop_ball = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_stop_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_StopDash body_stop_dash = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_stop_dash(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_TackleToPoint body_tackle_to_point = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_tackle_to_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_TurnToAngle body_turn_to_angle = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_turn_to_angle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_TurnToBall body_turn_to_ball = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_turn_to_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Body_TurnToPoint body_turn_to_point = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_turn_to_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Focus_MoveToPoint focus_move_to_point = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_focus_move_to_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Focus_Reset focus_reset = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_focus_reset(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_ScanField neck_scan_field = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_scan_field(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_ScanPlayers neck_scan_players = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_scan_players(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_ball_and_player(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToBallOrScan neck_turn_to_ball_or_scan = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_ball_or_scan(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToBall neck_turn_to_ball = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_goalie_or_scan(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_low_conf_teammate(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_player_or_scan(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToPoint neck_turn_to_point = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Neck_TurnToRelative neck_turn_to_relative = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_neck_turn_to_relative(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.View_ChangeWidth view_change_width = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_change_width(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.View_Normal view_normal = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_normal(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.View_Synch view_synch = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_synch(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.View_Wide view_wide = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_wide(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosGoalie helios_goalie = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_goalie(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosGoalieMove helios_goalie_move = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_goalie_move(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosGoalieKick helios_goalie_kick = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_goalie_kick(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosShoot helios_shoot = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_shoot(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosChainAction helios_chain_action = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_chain_action(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosBasicOffensive helios_basic_offensive = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_basic_offensive(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosBasicMove helios_basic_move = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_basic_move(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosSetPlay helios_set_play = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_set_play(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosPenalty helios_penalty = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_penalty(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.HeliosCommunicaion helios_communication = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_helios_communication(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PlayerAction::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PlayerAction)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (action_case()) {
    case kDash: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::dash(this),
          _Internal::dash(this).GetCachedSize(), target, stream);
      break;
    }
    case kTurn: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::turn(this),
          _Internal::turn(this).GetCachedSize(), target, stream);
      break;
    }
    case kKick: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::kick(this),
          _Internal::kick(this).GetCachedSize(), target, stream);
      break;
    }
    case kTackle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::tackle(this),
          _Internal::tackle(this).GetCachedSize(), target, stream);
      break;
    }
    case kCatch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::catch_(this),
          _Internal::catch_(this).GetCachedSize(), target, stream);
      break;
    }
    case kMove: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::move(this),
          _Internal::move(this).GetCachedSize(), target, stream);
      break;
    }
    case kTurnNeck: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::turn_neck(this),
          _Internal::turn_neck(this).GetCachedSize(), target, stream);
      break;
    }
    case kChangeView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::change_view(this),
          _Internal::change_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kSay: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::say(this),
          _Internal::say(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointTo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::point_to(this),
          _Internal::point_to(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointToOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::point_to_of(this),
          _Internal::point_to_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kAttentionTo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::attention_to(this),
          _Internal::attention_to(this).GetCachedSize(), target, stream);
      break;
    }
    case kAttentionToOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::attention_to_of(this),
          _Internal::attention_to_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kLog: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::log(this),
          _Internal::log(this).GetCachedSize(), target, stream);
      break;
    }
    case kDebugClient: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::debug_client(this),
          _Internal::debug_client(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyGoToPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::body_go_to_point(this),
          _Internal::body_go_to_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodySmartKick: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, _Internal::body_smart_kick(this),
          _Internal::body_smart_kick(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvBeforeKickOff: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, _Internal::bhv_before_kick_off(this),
          _Internal::bhv_before_kick_off(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvBodyNeckToBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, _Internal::bhv_body_neck_to_ball(this),
          _Internal::bhv_body_neck_to_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvBodyNeckToPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, _Internal::bhv_body_neck_to_point(this),
          _Internal::bhv_body_neck_to_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvEmergency: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, _Internal::bhv_emergency(this),
          _Internal::bhv_emergency(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvGoToPointLookBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, _Internal::bhv_go_to_point_look_ball(this),
          _Internal::bhv_go_to_point_look_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvNeckBodyToBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, _Internal::bhv_neck_body_to_ball(this),
          _Internal::bhv_neck_body_to_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvNeckBodyToPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, _Internal::bhv_neck_body_to_point(this),
          _Internal::bhv_neck_body_to_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kBhvScanField: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(25, _Internal::bhv_scan_field(this),
          _Internal::bhv_scan_field(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyAdvanceBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(26, _Internal::body_advance_ball(this),
          _Internal::body_advance_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyClearBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(27, _Internal::body_clear_ball(this),
          _Internal::body_clear_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyDribble: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, _Internal::body_dribble(this),
          _Internal::body_dribble(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyGoToPointDodge: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(29, _Internal::body_go_to_point_dodge(this),
          _Internal::body_go_to_point_dodge(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyHoldBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, _Internal::body_hold_ball(this),
          _Internal::body_hold_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyIntercept: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(31, _Internal::body_intercept(this),
          _Internal::body_intercept(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyKickOneStep: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(32, _Internal::body_kick_one_step(this),
          _Internal::body_kick_one_step(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyStopBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(33, _Internal::body_stop_ball(this),
          _Internal::body_stop_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyStopDash: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(34, _Internal::body_stop_dash(this),
          _Internal::body_stop_dash(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyTackleToPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(35, _Internal::body_tackle_to_point(this),
          _Internal::body_tackle_to_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyTurnToAngle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(36, _Internal::body_turn_to_angle(this),
          _Internal::body_turn_to_angle(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyTurnToBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(37, _Internal::body_turn_to_ball(this),
          _Internal::body_turn_to_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kBodyTurnToPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(38, _Internal::body_turn_to_point(this),
          _Internal::body_turn_to_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kFocusMoveToPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(39, _Internal::focus_move_to_point(this),
          _Internal::focus_move_to_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kFocusReset: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(40, _Internal::focus_reset(this),
          _Internal::focus_reset(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckScanField: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(41, _Internal::neck_scan_field(this),
          _Internal::neck_scan_field(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckScanPlayers: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(42, _Internal::neck_scan_players(this),
          _Internal::neck_scan_players(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToBallAndPlayer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(43, _Internal::neck_turn_to_ball_and_player(this),
          _Internal::neck_turn_to_ball_and_player(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToBallOrScan: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(44, _Internal::neck_turn_to_ball_or_scan(this),
          _Internal::neck_turn_to_ball_or_scan(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(45, _Internal::neck_turn_to_ball(this),
          _Internal::neck_turn_to_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToGoalieOrScan: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(46, _Internal::neck_turn_to_goalie_or_scan(this),
          _Internal::neck_turn_to_goalie_or_scan(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToLowConfTeammate: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(47, _Internal::neck_turn_to_low_conf_teammate(this),
          _Internal::neck_turn_to_low_conf_teammate(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToPlayerOrScan: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(48, _Internal::neck_turn_to_player_or_scan(this),
          _Internal::neck_turn_to_player_or_scan(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(49, _Internal::neck_turn_to_point(this),
          _Internal::neck_turn_to_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kNeckTurnToRelative: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(50, _Internal::neck_turn_to_relative(this),
          _Internal::neck_turn_to_relative(this).GetCachedSize(), target, stream);
      break;
    }
    case kViewChangeWidth: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(51, _Internal::view_change_width(this),
          _Internal::view_change_width(this).GetCachedSize(), target, stream);
      break;
    }
    case kViewNormal: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(52, _Internal::view_normal(this),
          _Internal::view_normal(this).GetCachedSize(), target, stream);
      break;
    }
    case kViewSynch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(53, _Internal::view_synch(this),
          _Internal::view_synch(this).GetCachedSize(), target, stream);
      break;
    }
    case kViewWide: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(54, _Internal::view_wide(this),
          _Internal::view_wide(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosGoalie: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(55, _Internal::helios_goalie(this),
          _Internal::helios_goalie(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosGoalieMove: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(56, _Internal::helios_goalie_move(this),
          _Internal::helios_goalie_move(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosGoalieKick: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(57, _Internal::helios_goalie_kick(this),
          _Internal::helios_goalie_kick(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosShoot: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(58, _Internal::helios_shoot(this),
          _Internal::helios_shoot(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosChainAction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(59, _Internal::helios_chain_action(this),
          _Internal::helios_chain_action(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosBasicOffensive: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(60, _Internal::helios_basic_offensive(this),
          _Internal::helios_basic_offensive(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosBasicMove: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(61, _Internal::helios_basic_move(this),
          _Internal::helios_basic_move(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosSetPlay: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(62, _Internal::helios_set_play(this),
          _Internal::helios_set_play(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosPenalty: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(63, _Internal::helios_penalty(this),
          _Internal::helios_penalty(this).GetCachedSize(), target, stream);
      break;
    }
    case kHeliosCommunication: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(64, _Internal::helios_communication(this),
          _Internal::helios_communication(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PlayerAction)
  return target;
}

::size_t PlayerAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PlayerAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // .protos.Dash dash = 1;
    case kDash: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.dash_);
      break;
    }
    // .protos.Turn turn = 2;
    case kTurn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.turn_);
      break;
    }
    // .protos.Kick kick = 3;
    case kKick: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.kick_);
      break;
    }
    // .protos.Tackle tackle = 4;
    case kTackle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.tackle_);
      break;
    }
    // .protos.Catch catch = 5;
    case kCatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.catch__);
      break;
    }
    // .protos.Move move = 6;
    case kMove: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.move_);
      break;
    }
    // .protos.TurnNeck turn_neck = 7;
    case kTurnNeck: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.turn_neck_);
      break;
    }
    // .protos.ChangeView change_view = 8;
    case kChangeView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.change_view_);
      break;
    }
    // .protos.Say say = 9;
    case kSay: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.say_);
      break;
    }
    // .protos.PointTo point_to = 10;
    case kPointTo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.point_to_);
      break;
    }
    // .protos.PointToOf point_to_of = 11;
    case kPointToOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.point_to_of_);
      break;
    }
    // .protos.AttentionTo attention_to = 12;
    case kAttentionTo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.attention_to_);
      break;
    }
    // .protos.AttentionToOf attention_to_of = 13;
    case kAttentionToOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.attention_to_of_);
      break;
    }
    // .protos.Log log = 14;
    case kLog: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.log_);
      break;
    }
    // .protos.DebugClient debug_client = 15;
    case kDebugClient: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.debug_client_);
      break;
    }
    // .protos.Body_GoToPoint body_go_to_point = 16;
    case kBodyGoToPoint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_go_to_point_);
      break;
    }
    // .protos.Body_SmartKick body_smart_kick = 17;
    case kBodySmartKick: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_smart_kick_);
      break;
    }
    // .protos.Bhv_BeforeKickOff bhv_before_kick_off = 18;
    case kBhvBeforeKickOff: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_before_kick_off_);
      break;
    }
    // .protos.Bhv_BodyNeckToBall bhv_body_neck_to_ball = 19;
    case kBhvBodyNeckToBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_body_neck_to_ball_);
      break;
    }
    // .protos.Bhv_BodyNeckToPoint bhv_body_neck_to_point = 20;
    case kBhvBodyNeckToPoint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_body_neck_to_point_);
      break;
    }
    // .protos.Bhv_Emergency bhv_emergency = 21;
    case kBhvEmergency: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_emergency_);
      break;
    }
    // .protos.Bhv_GoToPointLookBall bhv_go_to_point_look_ball = 22;
    case kBhvGoToPointLookBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_go_to_point_look_ball_);
      break;
    }
    // .protos.Bhv_NeckBodyToBall bhv_neck_body_to_ball = 23;
    case kBhvNeckBodyToBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_neck_body_to_ball_);
      break;
    }
    // .protos.Bhv_NeckBodyToPoint bhv_neck_body_to_point = 24;
    case kBhvNeckBodyToPoint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_neck_body_to_point_);
      break;
    }
    // .protos.Bhv_ScanField bhv_scan_field = 25;
    case kBhvScanField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.bhv_scan_field_);
      break;
    }
    // .protos.Body_AdvanceBall body_advance_ball = 26;
    case kBodyAdvanceBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_advance_ball_);
      break;
    }
    // .protos.Body_ClearBall body_clear_ball = 27;
    case kBodyClearBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_clear_ball_);
      break;
    }
    // .protos.Body_Dribble body_dribble = 28;
    case kBodyDribble: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_dribble_);
      break;
    }
    // .protos.Body_GoToPointDodge body_go_to_point_dodge = 29;
    case kBodyGoToPointDodge: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_go_to_point_dodge_);
      break;
    }
    // .protos.Body_HoldBall body_hold_ball = 30;
    case kBodyHoldBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_hold_ball_);
      break;
    }
    // .protos.Body_Intercept body_intercept = 31;
    case kBodyIntercept: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_intercept_);
      break;
    }
    // .protos.Body_KickOneStep body_kick_one_step = 32;
    case kBodyKickOneStep: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_kick_one_step_);
      break;
    }
    // .protos.Body_StopBall body_stop_ball = 33;
    case kBodyStopBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_stop_ball_);
      break;
    }
    // .protos.Body_StopDash body_stop_dash = 34;
    case kBodyStopDash: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_stop_dash_);
      break;
    }
    // .protos.Body_TackleToPoint body_tackle_to_point = 35;
    case kBodyTackleToPoint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_tackle_to_point_);
      break;
    }
    // .protos.Body_TurnToAngle body_turn_to_angle = 36;
    case kBodyTurnToAngle: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_turn_to_angle_);
      break;
    }
    // .protos.Body_TurnToBall body_turn_to_ball = 37;
    case kBodyTurnToBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_turn_to_ball_);
      break;
    }
    // .protos.Body_TurnToPoint body_turn_to_point = 38;
    case kBodyTurnToPoint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.body_turn_to_point_);
      break;
    }
    // .protos.Focus_MoveToPoint focus_move_to_point = 39;
    case kFocusMoveToPoint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.focus_move_to_point_);
      break;
    }
    // .protos.Focus_Reset focus_reset = 40;
    case kFocusReset: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.focus_reset_);
      break;
    }
    // .protos.Neck_ScanField neck_scan_field = 41;
    case kNeckScanField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_scan_field_);
      break;
    }
    // .protos.Neck_ScanPlayers neck_scan_players = 42;
    case kNeckScanPlayers: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_scan_players_);
      break;
    }
    // .protos.Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player = 43;
    case kNeckTurnToBallAndPlayer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_ball_and_player_);
      break;
    }
    // .protos.Neck_TurnToBallOrScan neck_turn_to_ball_or_scan = 44;
    case kNeckTurnToBallOrScan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_ball_or_scan_);
      break;
    }
    // .protos.Neck_TurnToBall neck_turn_to_ball = 45;
    case kNeckTurnToBall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_ball_);
      break;
    }
    // .protos.Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan = 46;
    case kNeckTurnToGoalieOrScan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_goalie_or_scan_);
      break;
    }
    // .protos.Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate = 47;
    case kNeckTurnToLowConfTeammate: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_low_conf_teammate_);
      break;
    }
    // .protos.Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan = 48;
    case kNeckTurnToPlayerOrScan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_player_or_scan_);
      break;
    }
    // .protos.Neck_TurnToPoint neck_turn_to_point = 49;
    case kNeckTurnToPoint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_point_);
      break;
    }
    // .protos.Neck_TurnToRelative neck_turn_to_relative = 50;
    case kNeckTurnToRelative: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.neck_turn_to_relative_);
      break;
    }
    // .protos.View_ChangeWidth view_change_width = 51;
    case kViewChangeWidth: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.view_change_width_);
      break;
    }
    // .protos.View_Normal view_normal = 52;
    case kViewNormal: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.view_normal_);
      break;
    }
    // .protos.View_Synch view_synch = 53;
    case kViewSynch: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.view_synch_);
      break;
    }
    // .protos.View_Wide view_wide = 54;
    case kViewWide: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.view_wide_);
      break;
    }
    // .protos.HeliosGoalie helios_goalie = 55;
    case kHeliosGoalie: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_goalie_);
      break;
    }
    // .protos.HeliosGoalieMove helios_goalie_move = 56;
    case kHeliosGoalieMove: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_goalie_move_);
      break;
    }
    // .protos.HeliosGoalieKick helios_goalie_kick = 57;
    case kHeliosGoalieKick: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_goalie_kick_);
      break;
    }
    // .protos.HeliosShoot helios_shoot = 58;
    case kHeliosShoot: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_shoot_);
      break;
    }
    // .protos.HeliosChainAction helios_chain_action = 59;
    case kHeliosChainAction: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_chain_action_);
      break;
    }
    // .protos.HeliosBasicOffensive helios_basic_offensive = 60;
    case kHeliosBasicOffensive: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_basic_offensive_);
      break;
    }
    // .protos.HeliosBasicMove helios_basic_move = 61;
    case kHeliosBasicMove: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_basic_move_);
      break;
    }
    // .protos.HeliosSetPlay helios_set_play = 62;
    case kHeliosSetPlay: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_set_play_);
      break;
    }
    // .protos.HeliosPenalty helios_penalty = 63;
    case kHeliosPenalty: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_penalty_);
      break;
    }
    // .protos.HeliosCommunicaion helios_communication = 64;
    case kHeliosCommunication: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.helios_communication_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerAction::GetClassData() const { return &_class_data_; }


void PlayerAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerAction*>(&to_msg);
  auto& from = static_cast<const PlayerAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PlayerAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kDash: {
      _this->_internal_mutable_dash()->::protos::Dash::MergeFrom(
          from._internal_dash());
      break;
    }
    case kTurn: {
      _this->_internal_mutable_turn()->::protos::Turn::MergeFrom(
          from._internal_turn());
      break;
    }
    case kKick: {
      _this->_internal_mutable_kick()->::protos::Kick::MergeFrom(
          from._internal_kick());
      break;
    }
    case kTackle: {
      _this->_internal_mutable_tackle()->::protos::Tackle::MergeFrom(
          from._internal_tackle());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::protos::Catch::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kMove: {
      _this->_internal_mutable_move()->::protos::Move::MergeFrom(
          from._internal_move());
      break;
    }
    case kTurnNeck: {
      _this->_internal_mutable_turn_neck()->::protos::TurnNeck::MergeFrom(
          from._internal_turn_neck());
      break;
    }
    case kChangeView: {
      _this->_internal_mutable_change_view()->::protos::ChangeView::MergeFrom(
          from._internal_change_view());
      break;
    }
    case kSay: {
      _this->_internal_mutable_say()->::protos::Say::MergeFrom(
          from._internal_say());
      break;
    }
    case kPointTo: {
      _this->_internal_mutable_point_to()->::protos::PointTo::MergeFrom(
          from._internal_point_to());
      break;
    }
    case kPointToOf: {
      _this->_internal_mutable_point_to_of()->::protos::PointToOf::MergeFrom(
          from._internal_point_to_of());
      break;
    }
    case kAttentionTo: {
      _this->_internal_mutable_attention_to()->::protos::AttentionTo::MergeFrom(
          from._internal_attention_to());
      break;
    }
    case kAttentionToOf: {
      _this->_internal_mutable_attention_to_of()->::protos::AttentionToOf::MergeFrom(
          from._internal_attention_to_of());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::protos::Log::MergeFrom(
          from._internal_log());
      break;
    }
    case kDebugClient: {
      _this->_internal_mutable_debug_client()->::protos::DebugClient::MergeFrom(
          from._internal_debug_client());
      break;
    }
    case kBodyGoToPoint: {
      _this->_internal_mutable_body_go_to_point()->::protos::Body_GoToPoint::MergeFrom(
          from._internal_body_go_to_point());
      break;
    }
    case kBodySmartKick: {
      _this->_internal_mutable_body_smart_kick()->::protos::Body_SmartKick::MergeFrom(
          from._internal_body_smart_kick());
      break;
    }
    case kBhvBeforeKickOff: {
      _this->_internal_mutable_bhv_before_kick_off()->::protos::Bhv_BeforeKickOff::MergeFrom(
          from._internal_bhv_before_kick_off());
      break;
    }
    case kBhvBodyNeckToBall: {
      _this->_internal_mutable_bhv_body_neck_to_ball()->::protos::Bhv_BodyNeckToBall::MergeFrom(
          from._internal_bhv_body_neck_to_ball());
      break;
    }
    case kBhvBodyNeckToPoint: {
      _this->_internal_mutable_bhv_body_neck_to_point()->::protos::Bhv_BodyNeckToPoint::MergeFrom(
          from._internal_bhv_body_neck_to_point());
      break;
    }
    case kBhvEmergency: {
      _this->_internal_mutable_bhv_emergency()->::protos::Bhv_Emergency::MergeFrom(
          from._internal_bhv_emergency());
      break;
    }
    case kBhvGoToPointLookBall: {
      _this->_internal_mutable_bhv_go_to_point_look_ball()->::protos::Bhv_GoToPointLookBall::MergeFrom(
          from._internal_bhv_go_to_point_look_ball());
      break;
    }
    case kBhvNeckBodyToBall: {
      _this->_internal_mutable_bhv_neck_body_to_ball()->::protos::Bhv_NeckBodyToBall::MergeFrom(
          from._internal_bhv_neck_body_to_ball());
      break;
    }
    case kBhvNeckBodyToPoint: {
      _this->_internal_mutable_bhv_neck_body_to_point()->::protos::Bhv_NeckBodyToPoint::MergeFrom(
          from._internal_bhv_neck_body_to_point());
      break;
    }
    case kBhvScanField: {
      _this->_internal_mutable_bhv_scan_field()->::protos::Bhv_ScanField::MergeFrom(
          from._internal_bhv_scan_field());
      break;
    }
    case kBodyAdvanceBall: {
      _this->_internal_mutable_body_advance_ball()->::protos::Body_AdvanceBall::MergeFrom(
          from._internal_body_advance_ball());
      break;
    }
    case kBodyClearBall: {
      _this->_internal_mutable_body_clear_ball()->::protos::Body_ClearBall::MergeFrom(
          from._internal_body_clear_ball());
      break;
    }
    case kBodyDribble: {
      _this->_internal_mutable_body_dribble()->::protos::Body_Dribble::MergeFrom(
          from._internal_body_dribble());
      break;
    }
    case kBodyGoToPointDodge: {
      _this->_internal_mutable_body_go_to_point_dodge()->::protos::Body_GoToPointDodge::MergeFrom(
          from._internal_body_go_to_point_dodge());
      break;
    }
    case kBodyHoldBall: {
      _this->_internal_mutable_body_hold_ball()->::protos::Body_HoldBall::MergeFrom(
          from._internal_body_hold_ball());
      break;
    }
    case kBodyIntercept: {
      _this->_internal_mutable_body_intercept()->::protos::Body_Intercept::MergeFrom(
          from._internal_body_intercept());
      break;
    }
    case kBodyKickOneStep: {
      _this->_internal_mutable_body_kick_one_step()->::protos::Body_KickOneStep::MergeFrom(
          from._internal_body_kick_one_step());
      break;
    }
    case kBodyStopBall: {
      _this->_internal_mutable_body_stop_ball()->::protos::Body_StopBall::MergeFrom(
          from._internal_body_stop_ball());
      break;
    }
    case kBodyStopDash: {
      _this->_internal_mutable_body_stop_dash()->::protos::Body_StopDash::MergeFrom(
          from._internal_body_stop_dash());
      break;
    }
    case kBodyTackleToPoint: {
      _this->_internal_mutable_body_tackle_to_point()->::protos::Body_TackleToPoint::MergeFrom(
          from._internal_body_tackle_to_point());
      break;
    }
    case kBodyTurnToAngle: {
      _this->_internal_mutable_body_turn_to_angle()->::protos::Body_TurnToAngle::MergeFrom(
          from._internal_body_turn_to_angle());
      break;
    }
    case kBodyTurnToBall: {
      _this->_internal_mutable_body_turn_to_ball()->::protos::Body_TurnToBall::MergeFrom(
          from._internal_body_turn_to_ball());
      break;
    }
    case kBodyTurnToPoint: {
      _this->_internal_mutable_body_turn_to_point()->::protos::Body_TurnToPoint::MergeFrom(
          from._internal_body_turn_to_point());
      break;
    }
    case kFocusMoveToPoint: {
      _this->_internal_mutable_focus_move_to_point()->::protos::Focus_MoveToPoint::MergeFrom(
          from._internal_focus_move_to_point());
      break;
    }
    case kFocusReset: {
      _this->_internal_mutable_focus_reset()->::protos::Focus_Reset::MergeFrom(
          from._internal_focus_reset());
      break;
    }
    case kNeckScanField: {
      _this->_internal_mutable_neck_scan_field()->::protos::Neck_ScanField::MergeFrom(
          from._internal_neck_scan_field());
      break;
    }
    case kNeckScanPlayers: {
      _this->_internal_mutable_neck_scan_players()->::protos::Neck_ScanPlayers::MergeFrom(
          from._internal_neck_scan_players());
      break;
    }
    case kNeckTurnToBallAndPlayer: {
      _this->_internal_mutable_neck_turn_to_ball_and_player()->::protos::Neck_TurnToBallAndPlayer::MergeFrom(
          from._internal_neck_turn_to_ball_and_player());
      break;
    }
    case kNeckTurnToBallOrScan: {
      _this->_internal_mutable_neck_turn_to_ball_or_scan()->::protos::Neck_TurnToBallOrScan::MergeFrom(
          from._internal_neck_turn_to_ball_or_scan());
      break;
    }
    case kNeckTurnToBall: {
      _this->_internal_mutable_neck_turn_to_ball()->::protos::Neck_TurnToBall::MergeFrom(
          from._internal_neck_turn_to_ball());
      break;
    }
    case kNeckTurnToGoalieOrScan: {
      _this->_internal_mutable_neck_turn_to_goalie_or_scan()->::protos::Neck_TurnToGoalieOrScan::MergeFrom(
          from._internal_neck_turn_to_goalie_or_scan());
      break;
    }
    case kNeckTurnToLowConfTeammate: {
      _this->_internal_mutable_neck_turn_to_low_conf_teammate()->::protos::Neck_TurnToLowConfTeammate::MergeFrom(
          from._internal_neck_turn_to_low_conf_teammate());
      break;
    }
    case kNeckTurnToPlayerOrScan: {
      _this->_internal_mutable_neck_turn_to_player_or_scan()->::protos::Neck_TurnToPlayerOrScan::MergeFrom(
          from._internal_neck_turn_to_player_or_scan());
      break;
    }
    case kNeckTurnToPoint: {
      _this->_internal_mutable_neck_turn_to_point()->::protos::Neck_TurnToPoint::MergeFrom(
          from._internal_neck_turn_to_point());
      break;
    }
    case kNeckTurnToRelative: {
      _this->_internal_mutable_neck_turn_to_relative()->::protos::Neck_TurnToRelative::MergeFrom(
          from._internal_neck_turn_to_relative());
      break;
    }
    case kViewChangeWidth: {
      _this->_internal_mutable_view_change_width()->::protos::View_ChangeWidth::MergeFrom(
          from._internal_view_change_width());
      break;
    }
    case kViewNormal: {
      _this->_internal_mutable_view_normal()->::protos::View_Normal::MergeFrom(
          from._internal_view_normal());
      break;
    }
    case kViewSynch: {
      _this->_internal_mutable_view_synch()->::protos::View_Synch::MergeFrom(
          from._internal_view_synch());
      break;
    }
    case kViewWide: {
      _this->_internal_mutable_view_wide()->::protos::View_Wide::MergeFrom(
          from._internal_view_wide());
      break;
    }
    case kHeliosGoalie: {
      _this->_internal_mutable_helios_goalie()->::protos::HeliosGoalie::MergeFrom(
          from._internal_helios_goalie());
      break;
    }
    case kHeliosGoalieMove: {
      _this->_internal_mutable_helios_goalie_move()->::protos::HeliosGoalieMove::MergeFrom(
          from._internal_helios_goalie_move());
      break;
    }
    case kHeliosGoalieKick: {
      _this->_internal_mutable_helios_goalie_kick()->::protos::HeliosGoalieKick::MergeFrom(
          from._internal_helios_goalie_kick());
      break;
    }
    case kHeliosShoot: {
      _this->_internal_mutable_helios_shoot()->::protos::HeliosShoot::MergeFrom(
          from._internal_helios_shoot());
      break;
    }
    case kHeliosChainAction: {
      _this->_internal_mutable_helios_chain_action()->::protos::HeliosChainAction::MergeFrom(
          from._internal_helios_chain_action());
      break;
    }
    case kHeliosBasicOffensive: {
      _this->_internal_mutable_helios_basic_offensive()->::protos::HeliosBasicOffensive::MergeFrom(
          from._internal_helios_basic_offensive());
      break;
    }
    case kHeliosBasicMove: {
      _this->_internal_mutable_helios_basic_move()->::protos::HeliosBasicMove::MergeFrom(
          from._internal_helios_basic_move());
      break;
    }
    case kHeliosSetPlay: {
      _this->_internal_mutable_helios_set_play()->::protos::HeliosSetPlay::MergeFrom(
          from._internal_helios_set_play());
      break;
    }
    case kHeliosPenalty: {
      _this->_internal_mutable_helios_penalty()->::protos::HeliosPenalty::MergeFrom(
          from._internal_helios_penalty());
      break;
    }
    case kHeliosCommunication: {
      _this->_internal_mutable_helios_communication()->::protos::HeliosCommunicaion::MergeFrom(
          from._internal_helios_communication());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerAction::CopyFrom(const PlayerAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PlayerAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerAction::IsInitialized() const {
  return true;
}

void PlayerAction::InternalSwap(PlayerAction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[107]);
}
// ===================================================================

class PlayerActions::_Internal {
 public:
};

PlayerActions::PlayerActions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PlayerActions)
}
PlayerActions::PlayerActions(const PlayerActions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerActions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){from._impl_.actions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PlayerActions)
}

inline void PlayerActions::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerActions::~PlayerActions() {
  // @@protoc_insertion_point(destructor:protos.PlayerActions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerActions::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_actions()->~RepeatedPtrField();
}

void PlayerActions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerActions::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PlayerActions)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_actions()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerActions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protos.PlayerAction actions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PlayerActions::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PlayerActions)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protos.PlayerAction actions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PlayerActions)
  return target;
}

::size_t PlayerActions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PlayerActions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.PlayerAction actions = 1;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->_internal_actions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerActions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerActions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerActions::GetClassData() const { return &_class_data_; }


void PlayerActions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerActions*>(&to_msg);
  auto& from = static_cast<const PlayerActions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PlayerActions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_actions()->MergeFrom(from._internal_actions());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerActions::CopyFrom(const PlayerActions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PlayerActions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerActions::IsInitialized() const {
  return true;
}

void PlayerActions::InternalSwap(PlayerActions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_actions()->InternalSwap(other->_internal_mutable_actions());
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerActions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[108]);
}
// ===================================================================

class ChangePlayerType::_Internal {
 public:
};

ChangePlayerType::ChangePlayerType(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.ChangePlayerType)
}
ChangePlayerType::ChangePlayerType(const ChangePlayerType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.ChangePlayerType)
}

inline void ChangePlayerType::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.type_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ChangePlayerType::~ChangePlayerType() {
  // @@protoc_insertion_point(destructor:protos.ChangePlayerType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangePlayerType::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChangePlayerType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangePlayerType::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.ChangePlayerType)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangePlayerType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ChangePlayerType::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.ChangePlayerType)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_uniform_number(), target);
  }

  // int32 type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.ChangePlayerType)
  return target;
}

::size_t ChangePlayerType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.ChangePlayerType)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 type = 2;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangePlayerType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangePlayerType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangePlayerType::GetClassData() const { return &_class_data_; }


void ChangePlayerType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangePlayerType*>(&to_msg);
  auto& from = static_cast<const ChangePlayerType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.ChangePlayerType)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangePlayerType::CopyFrom(const ChangePlayerType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.ChangePlayerType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangePlayerType::IsInitialized() const {
  return true;
}

void ChangePlayerType::InternalSwap(ChangePlayerType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangePlayerType, _impl_.type_)
      + sizeof(ChangePlayerType::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(ChangePlayerType, _impl_.uniform_number_)>(
          reinterpret_cast<char*>(&_impl_.uniform_number_),
          reinterpret_cast<char*>(&other->_impl_.uniform_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangePlayerType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[109]);
}
// ===================================================================

class DoHeliosSubstitute::_Internal {
 public:
};

DoHeliosSubstitute::DoHeliosSubstitute(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.DoHeliosSubstitute)
}
DoHeliosSubstitute::DoHeliosSubstitute(const DoHeliosSubstitute& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DoHeliosSubstitute* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DoHeliosSubstitute)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoHeliosSubstitute::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoHeliosSubstitute::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DoHeliosSubstitute::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[110]);
}
// ===================================================================

class DoHeliosSayPlayerTypes::_Internal {
 public:
};

DoHeliosSayPlayerTypes::DoHeliosSayPlayerTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.DoHeliosSayPlayerTypes)
}
DoHeliosSayPlayerTypes::DoHeliosSayPlayerTypes(const DoHeliosSayPlayerTypes& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DoHeliosSayPlayerTypes* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DoHeliosSayPlayerTypes)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoHeliosSayPlayerTypes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoHeliosSayPlayerTypes::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DoHeliosSayPlayerTypes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[111]);
}
// ===================================================================

class CoachAction::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::CoachAction, _impl_._oneof_case_);
  static const ::protos::ChangePlayerType& change_player_types(const CoachAction* msg);
  static const ::protos::DoHeliosSubstitute& do_helios_substitute(const CoachAction* msg);
  static const ::protos::DoHeliosSayPlayerTypes& do_helios_say_player_types(const CoachAction* msg);
};

const ::protos::ChangePlayerType&
CoachAction::_Internal::change_player_types(const CoachAction* msg) {
  return *msg->_impl_.action_.change_player_types_;
}
const ::protos::DoHeliosSubstitute&
CoachAction::_Internal::do_helios_substitute(const CoachAction* msg) {
  return *msg->_impl_.action_.do_helios_substitute_;
}
const ::protos::DoHeliosSayPlayerTypes&
CoachAction::_Internal::do_helios_say_player_types(const CoachAction* msg) {
  return *msg->_impl_.action_.do_helios_say_player_types_;
}
void CoachAction::set_allocated_change_player_types(::protos::ChangePlayerType* change_player_types) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (change_player_types) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_player_types);
    if (message_arena != submessage_arena) {
      change_player_types = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_player_types, submessage_arena);
    }
    set_has_change_player_types();
    _impl_.action_.change_player_types_ = change_player_types;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.CoachAction.change_player_types)
}
void CoachAction::set_allocated_do_helios_substitute(::protos::DoHeliosSubstitute* do_helios_substitute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_helios_substitute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_helios_substitute);
    if (message_arena != submessage_arena) {
      do_helios_substitute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_helios_substitute, submessage_arena);
    }
    set_has_do_helios_substitute();
    _impl_.action_.do_helios_substitute_ = do_helios_substitute;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.CoachAction.do_helios_substitute)
}
void CoachAction::set_allocated_do_helios_say_player_types(::protos::DoHeliosSayPlayerTypes* do_helios_say_player_types) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_helios_say_player_types) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_helios_say_player_types);
    if (message_arena != submessage_arena) {
      do_helios_say_player_types = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_helios_say_player_types, submessage_arena);
    }
    set_has_do_helios_say_player_types();
    _impl_.action_.do_helios_say_player_types_ = do_helios_say_player_types;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.CoachAction.do_helios_say_player_types)
}
CoachAction::CoachAction(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.CoachAction)
}
CoachAction::CoachAction(const CoachAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CoachAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kChangePlayerTypes: {
      _this->_internal_mutable_change_player_types()->::protos::ChangePlayerType::MergeFrom(
          from._internal_change_player_types());
      break;
    }
    case kDoHeliosSubstitute: {
      _this->_internal_mutable_do_helios_substitute()->::protos::DoHeliosSubstitute::MergeFrom(
          from._internal_do_helios_substitute());
      break;
    }
    case kDoHeliosSayPlayerTypes: {
      _this->_internal_mutable_do_helios_say_player_types()->::protos::DoHeliosSayPlayerTypes::MergeFrom(
          from._internal_do_helios_say_player_types());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.CoachAction)
}

inline void CoachAction::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_action();
}

CoachAction::~CoachAction() {
  // @@protoc_insertion_point(destructor:protos.CoachAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoachAction::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_action()) {
    clear_action();
  }
}

void CoachAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CoachAction::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:protos.CoachAction)
  switch (action_case()) {
    case kChangePlayerTypes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.change_player_types_;
      }
      break;
    }
    case kDoHeliosSubstitute: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_helios_substitute_;
      }
      break;
    }
    case kDoHeliosSayPlayerTypes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_helios_say_player_types_;
      }
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}


void CoachAction::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.CoachAction)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoachAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.ChangePlayerType change_player_types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_player_types(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DoHeliosSubstitute do_helios_substitute = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_helios_substitute(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DoHeliosSayPlayerTypes do_helios_say_player_types = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_helios_say_player_types(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CoachAction::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.CoachAction)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (action_case()) {
    case kChangePlayerTypes: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::change_player_types(this),
          _Internal::change_player_types(this).GetCachedSize(), target, stream);
      break;
    }
    case kDoHeliosSubstitute: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::do_helios_substitute(this),
          _Internal::do_helios_substitute(this).GetCachedSize(), target, stream);
      break;
    }
    case kDoHeliosSayPlayerTypes: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::do_helios_say_player_types(this),
          _Internal::do_helios_say_player_types(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.CoachAction)
  return target;
}

::size_t CoachAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.CoachAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // .protos.ChangePlayerType change_player_types = 1;
    case kChangePlayerTypes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.change_player_types_);
      break;
    }
    // .protos.DoHeliosSubstitute do_helios_substitute = 2;
    case kDoHeliosSubstitute: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_helios_substitute_);
      break;
    }
    // .protos.DoHeliosSayPlayerTypes do_helios_say_player_types = 3;
    case kDoHeliosSayPlayerTypes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_helios_say_player_types_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoachAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CoachAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoachAction::GetClassData() const { return &_class_data_; }


void CoachAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CoachAction*>(&to_msg);
  auto& from = static_cast<const CoachAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.CoachAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kChangePlayerTypes: {
      _this->_internal_mutable_change_player_types()->::protos::ChangePlayerType::MergeFrom(
          from._internal_change_player_types());
      break;
    }
    case kDoHeliosSubstitute: {
      _this->_internal_mutable_do_helios_substitute()->::protos::DoHeliosSubstitute::MergeFrom(
          from._internal_do_helios_substitute());
      break;
    }
    case kDoHeliosSayPlayerTypes: {
      _this->_internal_mutable_do_helios_say_player_types()->::protos::DoHeliosSayPlayerTypes::MergeFrom(
          from._internal_do_helios_say_player_types());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoachAction::CopyFrom(const CoachAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.CoachAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoachAction::IsInitialized() const {
  return true;
}

void CoachAction::InternalSwap(CoachAction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CoachAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[112]);
}
// ===================================================================

class CoachActions::_Internal {
 public:
};

CoachActions::CoachActions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.CoachActions)
}
CoachActions::CoachActions(const CoachActions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CoachActions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){from._impl_.actions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.CoachActions)
}

inline void CoachActions::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CoachActions::~CoachActions() {
  // @@protoc_insertion_point(destructor:protos.CoachActions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoachActions::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_actions()->~RepeatedPtrField();
}

void CoachActions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CoachActions::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.CoachActions)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_actions()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoachActions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protos.CoachAction actions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CoachActions::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.CoachActions)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protos.CoachAction actions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.CoachActions)
  return target;
}

::size_t CoachActions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.CoachActions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.CoachAction actions = 1;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->_internal_actions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoachActions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CoachActions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoachActions::GetClassData() const { return &_class_data_; }


void CoachActions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CoachActions*>(&to_msg);
  auto& from = static_cast<const CoachActions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.CoachActions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_actions()->MergeFrom(from._internal_actions());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoachActions::CopyFrom(const CoachActions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.CoachActions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoachActions::IsInitialized() const {
  return true;
}

void CoachActions::InternalSwap(CoachActions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_actions()->InternalSwap(other->_internal_mutable_actions());
}

::PROTOBUF_NAMESPACE_ID::Metadata CoachActions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[113]);
}
// ===================================================================

class DoKickOff::_Internal {
 public:
};

DoKickOff::DoKickOff(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.DoKickOff)
}
DoKickOff::DoKickOff(const DoKickOff& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DoKickOff* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DoKickOff)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoKickOff::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoKickOff::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DoKickOff::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[114]);
}
// ===================================================================

class DoMoveBall::_Internal {
 public:
  using HasBits = decltype(std::declval<DoMoveBall>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DoMoveBall, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const DoMoveBall* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& velocity(const DoMoveBall* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
DoMoveBall::_Internal::position(const DoMoveBall* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
DoMoveBall::_Internal::velocity(const DoMoveBall* msg) {
  return *msg->_impl_.velocity_;
}
DoMoveBall::DoMoveBall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DoMoveBall)
}
DoMoveBall::DoMoveBall(const DoMoveBall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoMoveBall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.DoMoveBall)
}

inline void DoMoveBall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
  };
}

DoMoveBall::~DoMoveBall() {
  // @@protoc_insertion_point(destructor:protos.DoMoveBall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoMoveBall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
}

void DoMoveBall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoMoveBall::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DoMoveBall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoMoveBall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DoMoveBall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DoMoveBall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DoMoveBall)
  return target;
}

::size_t DoMoveBall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DoMoveBall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoMoveBall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoMoveBall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoMoveBall::GetClassData() const { return &_class_data_; }


void DoMoveBall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoMoveBall*>(&to_msg);
  auto& from = static_cast<const DoMoveBall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DoMoveBall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoMoveBall::CopyFrom(const DoMoveBall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DoMoveBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoMoveBall::IsInitialized() const {
  return true;
}

void DoMoveBall::InternalSwap(DoMoveBall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoMoveBall, _impl_.velocity_)
      + sizeof(DoMoveBall::_impl_.velocity_)
      - PROTOBUF_FIELD_OFFSET(DoMoveBall, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoMoveBall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[115]);
}
// ===================================================================

class DoMovePlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<DoMovePlayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DoMovePlayer, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const DoMovePlayer* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
DoMovePlayer::_Internal::position(const DoMovePlayer* msg) {
  return *msg->_impl_.position_;
}
DoMovePlayer::DoMovePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DoMovePlayer)
}
DoMovePlayer::DoMovePlayer(const DoMovePlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoMovePlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.our_side_) {}

    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  ::memcpy(&_impl_.our_side_, &from._impl_.our_side_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.body_direction_) -
    reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.DoMovePlayer)
}

inline void DoMovePlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.our_side_) { false }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

  };
}

DoMovePlayer::~DoMovePlayer() {
  // @@protoc_insertion_point(destructor:protos.DoMovePlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoMovePlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void DoMovePlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoMovePlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DoMovePlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  ::memset(&_impl_.our_side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.body_direction_) -
      reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoMovePlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool our_side = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.our_side_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DoMovePlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DoMovePlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool our_side = 1;
  if (this->_internal_our_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_our_side(), target);
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // float body_direction = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DoMovePlayer)
  return target;
}

::size_t DoMovePlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DoMovePlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D position = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // bool our_side = 1;
  if (this->_internal_our_side() != 0) {
    total_size += 2;
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // float body_direction = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoMovePlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoMovePlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoMovePlayer::GetClassData() const { return &_class_data_; }


void DoMovePlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoMovePlayer*>(&to_msg);
  auto& from = static_cast<const DoMovePlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DoMovePlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_our_side() != 0) {
    _this->_internal_set_our_side(from._internal_our_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoMovePlayer::CopyFrom(const DoMovePlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DoMovePlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoMovePlayer::IsInitialized() const {
  return true;
}

void DoMovePlayer::InternalSwap(DoMovePlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoMovePlayer, _impl_.body_direction_)
      + sizeof(DoMovePlayer::_impl_.body_direction_)
      - PROTOBUF_FIELD_OFFSET(DoMovePlayer, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoMovePlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[116]);
}
// ===================================================================

class DoRecover::_Internal {
 public:
};

DoRecover::DoRecover(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.DoRecover)
}
DoRecover::DoRecover(const DoRecover& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DoRecover* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DoRecover)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoRecover::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoRecover::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DoRecover::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[117]);
}
// ===================================================================

class DoChangeMode::_Internal {
 public:
};

DoChangeMode::DoChangeMode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DoChangeMode)
}
DoChangeMode::DoChangeMode(const DoChangeMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DoChangeMode)
}

inline void DoChangeMode::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.game_mode_type_) { 0 }

    , decltype(_impl_.side_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DoChangeMode::~DoChangeMode() {
  // @@protoc_insertion_point(destructor:protos.DoChangeMode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoChangeMode::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoChangeMode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoChangeMode::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DoChangeMode)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.game_mode_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.side_) -
      reinterpret_cast<char*>(&_impl_.game_mode_type_)) + sizeof(_impl_.side_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoChangeMode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.GameModeType game_mode_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_game_mode_type(static_cast<::protos::GameModeType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side side = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DoChangeMode::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DoChangeMode)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.GameModeType game_mode_type = 1;
  if (this->_internal_game_mode_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_game_mode_type(), target);
  }

  // .protos.Side side = 2;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DoChangeMode)
  return target;
}

::size_t DoChangeMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DoChangeMode)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.GameModeType game_mode_type = 1;
  if (this->_internal_game_mode_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode_type());
  }

  // .protos.Side side = 2;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoChangeMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoChangeMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoChangeMode::GetClassData() const { return &_class_data_; }


void DoChangeMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoChangeMode*>(&to_msg);
  auto& from = static_cast<const DoChangeMode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DoChangeMode)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_game_mode_type() != 0) {
    _this->_internal_set_game_mode_type(from._internal_game_mode_type());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoChangeMode::CopyFrom(const DoChangeMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DoChangeMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoChangeMode::IsInitialized() const {
  return true;
}

void DoChangeMode::InternalSwap(DoChangeMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoChangeMode, _impl_.side_)
      + sizeof(DoChangeMode::_impl_.side_)
      - PROTOBUF_FIELD_OFFSET(DoChangeMode, _impl_.game_mode_type_)>(
          reinterpret_cast<char*>(&_impl_.game_mode_type_),
          reinterpret_cast<char*>(&other->_impl_.game_mode_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoChangeMode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[118]);
}
// ===================================================================

class DoChangePlayerType::_Internal {
 public:
};

DoChangePlayerType::DoChangePlayerType(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DoChangePlayerType)
}
DoChangePlayerType::DoChangePlayerType(const DoChangePlayerType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DoChangePlayerType)
}

inline void DoChangePlayerType::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.our_side_) { false }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.type_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DoChangePlayerType::~DoChangePlayerType() {
  // @@protoc_insertion_point(destructor:protos.DoChangePlayerType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoChangePlayerType::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoChangePlayerType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoChangePlayerType::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DoChangePlayerType)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.our_side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoChangePlayerType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool our_side = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.our_side_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DoChangePlayerType::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DoChangePlayerType)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool our_side = 1;
  if (this->_internal_our_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_our_side(), target);
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_uniform_number(), target);
  }

  // int32 type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DoChangePlayerType)
  return target;
}

::size_t DoChangePlayerType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DoChangePlayerType)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool our_side = 1;
  if (this->_internal_our_side() != 0) {
    total_size += 2;
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 type = 3;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoChangePlayerType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoChangePlayerType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoChangePlayerType::GetClassData() const { return &_class_data_; }


void DoChangePlayerType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoChangePlayerType*>(&to_msg);
  auto& from = static_cast<const DoChangePlayerType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DoChangePlayerType)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_our_side() != 0) {
    _this->_internal_set_our_side(from._internal_our_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoChangePlayerType::CopyFrom(const DoChangePlayerType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DoChangePlayerType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoChangePlayerType::IsInitialized() const {
  return true;
}

void DoChangePlayerType::InternalSwap(DoChangePlayerType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoChangePlayerType, _impl_.type_)
      + sizeof(DoChangePlayerType::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(DoChangePlayerType, _impl_.our_side_)>(
          reinterpret_cast<char*>(&_impl_.our_side_),
          reinterpret_cast<char*>(&other->_impl_.our_side_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoChangePlayerType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[119]);
}
// ===================================================================

class TrainerAction::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::TrainerAction, _impl_._oneof_case_);
  static const ::protos::DoKickOff& do_kick_off(const TrainerAction* msg);
  static const ::protos::DoMoveBall& do_move_ball(const TrainerAction* msg);
  static const ::protos::DoMovePlayer& do_move_player(const TrainerAction* msg);
  static const ::protos::DoRecover& do_recover(const TrainerAction* msg);
  static const ::protos::DoChangeMode& do_change_mode(const TrainerAction* msg);
  static const ::protos::DoChangePlayerType& do_change_player_type(const TrainerAction* msg);
};

const ::protos::DoKickOff&
TrainerAction::_Internal::do_kick_off(const TrainerAction* msg) {
  return *msg->_impl_.action_.do_kick_off_;
}
const ::protos::DoMoveBall&
TrainerAction::_Internal::do_move_ball(const TrainerAction* msg) {
  return *msg->_impl_.action_.do_move_ball_;
}
const ::protos::DoMovePlayer&
TrainerAction::_Internal::do_move_player(const TrainerAction* msg) {
  return *msg->_impl_.action_.do_move_player_;
}
const ::protos::DoRecover&
TrainerAction::_Internal::do_recover(const TrainerAction* msg) {
  return *msg->_impl_.action_.do_recover_;
}
const ::protos::DoChangeMode&
TrainerAction::_Internal::do_change_mode(const TrainerAction* msg) {
  return *msg->_impl_.action_.do_change_mode_;
}
const ::protos::DoChangePlayerType&
TrainerAction::_Internal::do_change_player_type(const TrainerAction* msg) {
  return *msg->_impl_.action_.do_change_player_type_;
}
void TrainerAction::set_allocated_do_kick_off(::protos::DoKickOff* do_kick_off) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_kick_off) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_kick_off);
    if (message_arena != submessage_arena) {
      do_kick_off = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_kick_off, submessage_arena);
    }
    set_has_do_kick_off();
    _impl_.action_.do_kick_off_ = do_kick_off;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.TrainerAction.do_kick_off)
}
void TrainerAction::set_allocated_do_move_ball(::protos::DoMoveBall* do_move_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_move_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_move_ball);
    if (message_arena != submessage_arena) {
      do_move_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_move_ball, submessage_arena);
    }
    set_has_do_move_ball();
    _impl_.action_.do_move_ball_ = do_move_ball;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.TrainerAction.do_move_ball)
}
void TrainerAction::set_allocated_do_move_player(::protos::DoMovePlayer* do_move_player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_move_player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_move_player);
    if (message_arena != submessage_arena) {
      do_move_player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_move_player, submessage_arena);
    }
    set_has_do_move_player();
    _impl_.action_.do_move_player_ = do_move_player;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.TrainerAction.do_move_player)
}
void TrainerAction::set_allocated_do_recover(::protos::DoRecover* do_recover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_recover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_recover);
    if (message_arena != submessage_arena) {
      do_recover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_recover, submessage_arena);
    }
    set_has_do_recover();
    _impl_.action_.do_recover_ = do_recover;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.TrainerAction.do_recover)
}
void TrainerAction::set_allocated_do_change_mode(::protos::DoChangeMode* do_change_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_change_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_change_mode);
    if (message_arena != submessage_arena) {
      do_change_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_change_mode, submessage_arena);
    }
    set_has_do_change_mode();
    _impl_.action_.do_change_mode_ = do_change_mode;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.TrainerAction.do_change_mode)
}
void TrainerAction::set_allocated_do_change_player_type(::protos::DoChangePlayerType* do_change_player_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (do_change_player_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_change_player_type);
    if (message_arena != submessage_arena) {
      do_change_player_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_change_player_type, submessage_arena);
    }
    set_has_do_change_player_type();
    _impl_.action_.do_change_player_type_ = do_change_player_type;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.TrainerAction.do_change_player_type)
}
TrainerAction::TrainerAction(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TrainerAction)
}
TrainerAction::TrainerAction(const TrainerAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrainerAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kDoKickOff: {
      _this->_internal_mutable_do_kick_off()->::protos::DoKickOff::MergeFrom(
          from._internal_do_kick_off());
      break;
    }
    case kDoMoveBall: {
      _this->_internal_mutable_do_move_ball()->::protos::DoMoveBall::MergeFrom(
          from._internal_do_move_ball());
      break;
    }
    case kDoMovePlayer: {
      _this->_internal_mutable_do_move_player()->::protos::DoMovePlayer::MergeFrom(
          from._internal_do_move_player());
      break;
    }
    case kDoRecover: {
      _this->_internal_mutable_do_recover()->::protos::DoRecover::MergeFrom(
          from._internal_do_recover());
      break;
    }
    case kDoChangeMode: {
      _this->_internal_mutable_do_change_mode()->::protos::DoChangeMode::MergeFrom(
          from._internal_do_change_mode());
      break;
    }
    case kDoChangePlayerType: {
      _this->_internal_mutable_do_change_player_type()->::protos::DoChangePlayerType::MergeFrom(
          from._internal_do_change_player_type());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.TrainerAction)
}

inline void TrainerAction::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_action();
}

TrainerAction::~TrainerAction() {
  // @@protoc_insertion_point(destructor:protos.TrainerAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrainerAction::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_action()) {
    clear_action();
  }
}

void TrainerAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrainerAction::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:protos.TrainerAction)
  switch (action_case()) {
    case kDoKickOff: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_kick_off_;
      }
      break;
    }
    case kDoMoveBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_move_ball_;
      }
      break;
    }
    case kDoMovePlayer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_move_player_;
      }
      break;
    }
    case kDoRecover: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_recover_;
      }
      break;
    }
    case kDoChangeMode: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_change_mode_;
      }
      break;
    }
    case kDoChangePlayerType: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.do_change_player_type_;
      }
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}


void TrainerAction::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TrainerAction)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrainerAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.DoKickOff do_kick_off = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_kick_off(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DoMoveBall do_move_ball = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_move_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DoMovePlayer do_move_player = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_move_player(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DoRecover do_recover = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_recover(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DoChangeMode do_change_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_change_mode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DoChangePlayerType do_change_player_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_change_player_type(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TrainerAction::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TrainerAction)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (action_case()) {
    case kDoKickOff: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::do_kick_off(this),
          _Internal::do_kick_off(this).GetCachedSize(), target, stream);
      break;
    }
    case kDoMoveBall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::do_move_ball(this),
          _Internal::do_move_ball(this).GetCachedSize(), target, stream);
      break;
    }
    case kDoMovePlayer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::do_move_player(this),
          _Internal::do_move_player(this).GetCachedSize(), target, stream);
      break;
    }
    case kDoRecover: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::do_recover(this),
          _Internal::do_recover(this).GetCachedSize(), target, stream);
      break;
    }
    case kDoChangeMode: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::do_change_mode(this),
          _Internal::do_change_mode(this).GetCachedSize(), target, stream);
      break;
    }
    case kDoChangePlayerType: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::do_change_player_type(this),
          _Internal::do_change_player_type(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TrainerAction)
  return target;
}

::size_t TrainerAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TrainerAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // .protos.DoKickOff do_kick_off = 1;
    case kDoKickOff: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_kick_off_);
      break;
    }
    // .protos.DoMoveBall do_move_ball = 2;
    case kDoMoveBall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_move_ball_);
      break;
    }
    // .protos.DoMovePlayer do_move_player = 3;
    case kDoMovePlayer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_move_player_);
      break;
    }
    // .protos.DoRecover do_recover = 4;
    case kDoRecover: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_recover_);
      break;
    }
    // .protos.DoChangeMode do_change_mode = 5;
    case kDoChangeMode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_change_mode_);
      break;
    }
    // .protos.DoChangePlayerType do_change_player_type = 6;
    case kDoChangePlayerType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.do_change_player_type_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrainerAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrainerAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrainerAction::GetClassData() const { return &_class_data_; }


void TrainerAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrainerAction*>(&to_msg);
  auto& from = static_cast<const TrainerAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TrainerAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kDoKickOff: {
      _this->_internal_mutable_do_kick_off()->::protos::DoKickOff::MergeFrom(
          from._internal_do_kick_off());
      break;
    }
    case kDoMoveBall: {
      _this->_internal_mutable_do_move_ball()->::protos::DoMoveBall::MergeFrom(
          from._internal_do_move_ball());
      break;
    }
    case kDoMovePlayer: {
      _this->_internal_mutable_do_move_player()->::protos::DoMovePlayer::MergeFrom(
          from._internal_do_move_player());
      break;
    }
    case kDoRecover: {
      _this->_internal_mutable_do_recover()->::protos::DoRecover::MergeFrom(
          from._internal_do_recover());
      break;
    }
    case kDoChangeMode: {
      _this->_internal_mutable_do_change_mode()->::protos::DoChangeMode::MergeFrom(
          from._internal_do_change_mode());
      break;
    }
    case kDoChangePlayerType: {
      _this->_internal_mutable_do_change_player_type()->::protos::DoChangePlayerType::MergeFrom(
          from._internal_do_change_player_type());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrainerAction::CopyFrom(const TrainerAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TrainerAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrainerAction::IsInitialized() const {
  return true;
}

void TrainerAction::InternalSwap(TrainerAction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrainerAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[120]);
}
// ===================================================================

class TrainerActions::_Internal {
 public:
};

TrainerActions::TrainerActions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TrainerActions)
}
TrainerActions::TrainerActions(const TrainerActions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrainerActions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){from._impl_.actions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.TrainerActions)
}

inline void TrainerActions::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrainerActions::~TrainerActions() {
  // @@protoc_insertion_point(destructor:protos.TrainerActions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrainerActions::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_actions()->~RepeatedPtrField();
}

void TrainerActions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrainerActions::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TrainerActions)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_actions()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrainerActions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protos.TrainerAction actions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TrainerActions::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TrainerActions)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protos.TrainerAction actions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TrainerActions)
  return target;
}

::size_t TrainerActions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TrainerActions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.TrainerAction actions = 1;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->_internal_actions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrainerActions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrainerActions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrainerActions::GetClassData() const { return &_class_data_; }


void TrainerActions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrainerActions*>(&to_msg);
  auto& from = static_cast<const TrainerActions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TrainerActions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_actions()->MergeFrom(from._internal_actions());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrainerActions::CopyFrom(const TrainerActions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TrainerActions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrainerActions::IsInitialized() const {
  return true;
}

void TrainerActions::InternalSwap(TrainerActions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_actions()->InternalSwap(other->_internal_mutable_actions());
}

::PROTOBUF_NAMESPACE_ID::Metadata TrainerActions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[121]);
}
// ===================================================================

class ServerParam::_Internal {
 public:
};

ServerParam::ServerParam(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.ServerParam)
}
ServerParam::ServerParam(const ServerParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServerParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.replay_file_) {}

    , decltype(_impl_.landmark_file_) {}

    , decltype(_impl_.text_log_dir_) {}

    , decltype(_impl_.game_log_dir_) {}

    , decltype(_impl_.text_log_fixed_name_) {}

    , decltype(_impl_.game_log_fixed_name_) {}

    , decltype(_impl_.log_date_format_) {}

    , decltype(_impl_.team_l_start_) {}

    , decltype(_impl_.team_r_start_) {}

    , decltype(_impl_.keepaway_log_dir_) {}

    , decltype(_impl_.keepaway_log_fixed_name_) {}

    , decltype(_impl_.module_dir_) {}

    , decltype(_impl_.coach_msg_file_) {}

    , decltype(_impl_.fixed_teamname_l_) {}

    , decltype(_impl_.fixed_teamname_r_) {}

    , decltype(_impl_.agent_type_) {}

    , decltype(_impl_.inertia_moment_) {}

    , decltype(_impl_.player_size_) {}

    , decltype(_impl_.player_decay_) {}

    , decltype(_impl_.player_rand_) {}

    , decltype(_impl_.player_weight_) {}

    , decltype(_impl_.player_speed_max_) {}

    , decltype(_impl_.player_accel_max_) {}

    , decltype(_impl_.stamina_max_) {}

    , decltype(_impl_.stamina_inc_max_) {}

    , decltype(_impl_.recover_init_) {}

    , decltype(_impl_.recover_dec_thr_) {}

    , decltype(_impl_.recover_min_) {}

    , decltype(_impl_.recover_dec_) {}

    , decltype(_impl_.effort_init_) {}

    , decltype(_impl_.effort_dec_thr_) {}

    , decltype(_impl_.effort_min_) {}

    , decltype(_impl_.effort_dec_) {}

    , decltype(_impl_.effort_inc_thr_) {}

    , decltype(_impl_.effort_inc_) {}

    , decltype(_impl_.kick_rand_) {}

    , decltype(_impl_.player_rand_factor_l_) {}

    , decltype(_impl_.player_rand_factor_r_) {}

    , decltype(_impl_.kick_rand_factor_l_) {}

    , decltype(_impl_.kick_rand_factor_r_) {}

    , decltype(_impl_.ball_size_) {}

    , decltype(_impl_.ball_decay_) {}

    , decltype(_impl_.ball_rand_) {}

    , decltype(_impl_.ball_weight_) {}

    , decltype(_impl_.ball_speed_max_) {}

    , decltype(_impl_.ball_accel_max_) {}

    , decltype(_impl_.dash_power_rate_) {}

    , decltype(_impl_.kick_power_rate_) {}

    , decltype(_impl_.kickable_margin_) {}

    , decltype(_impl_.control_radius_) {}

    , decltype(_impl_.control_radius_width_) {}

    , decltype(_impl_.max_power_) {}

    , decltype(_impl_.min_power_) {}

    , decltype(_impl_.max_moment_) {}

    , decltype(_impl_.min_moment_) {}

    , decltype(_impl_.max_neck_moment_) {}

    , decltype(_impl_.min_neck_moment_) {}

    , decltype(_impl_.max_neck_angle_) {}

    , decltype(_impl_.min_neck_angle_) {}

    , decltype(_impl_.visible_angle_) {}

    , decltype(_impl_.visible_distance_) {}

    , decltype(_impl_.wind_dir_) {}

    , decltype(_impl_.wind_force_) {}

    , decltype(_impl_.wind_angle_) {}

    , decltype(_impl_.wind_rand_) {}

    , decltype(_impl_.kickable_area_) {}

    , decltype(_impl_.catch_area_l_) {}

    , decltype(_impl_.catch_area_w_) {}

    , decltype(_impl_.catch_probability_) {}

    , decltype(_impl_.team_actuator_noise_) {}

    , decltype(_impl_.wind_none_) {}

    , decltype(_impl_.use_wind_random_) {}

    , decltype(_impl_.use_offside_) {}

    , decltype(_impl_.goalie_max_moves_) {}

    , decltype(_impl_.corner_kick_margin_) {}

    , decltype(_impl_.offside_active_area_size_) {}

    , decltype(_impl_.coach_say_count_max_) {}

    , decltype(_impl_.coach_say_msg_size_) {}

    , decltype(_impl_.clang_win_size_) {}

    , decltype(_impl_.clang_define_win_) {}

    , decltype(_impl_.clang_meta_win_) {}

    , decltype(_impl_.clang_advice_win_) {}

    , decltype(_impl_.clang_info_win_) {}

    , decltype(_impl_.clang_mess_delay_) {}

    , decltype(_impl_.clang_mess_per_cycle_) {}

    , decltype(_impl_.half_time_) {}

    , decltype(_impl_.simulator_step_) {}

    , decltype(_impl_.send_step_) {}

    , decltype(_impl_.recv_step_) {}

    , decltype(_impl_.sense_body_step_) {}

    , decltype(_impl_.lcm_step_) {}

    , decltype(_impl_.player_say_msg_size_) {}

    , decltype(_impl_.player_hear_max_) {}

    , decltype(_impl_.player_hear_inc_) {}

    , decltype(_impl_.player_hear_decay_) {}

    , decltype(_impl_.catch_ban_cycle_) {}

    , decltype(_impl_.slow_down_factor_) {}

    , decltype(_impl_.offside_kick_margin_) {}

    , decltype(_impl_.audio_cut_dist_) {}

    , decltype(_impl_.dist_quantize_step_) {}

    , decltype(_impl_.landmark_dist_quantize_step_) {}

    , decltype(_impl_.dir_quantize_step_) {}

    , decltype(_impl_.dist_quantize_step_l_) {}

    , decltype(_impl_.dist_quantize_step_r_) {}

    , decltype(_impl_.landmark_dist_quantize_step_l_) {}

    , decltype(_impl_.landmark_dist_quantize_step_r_) {}

    , decltype(_impl_.kickoff_offside_) {}

    , decltype(_impl_.coach_mode_) {}

    , decltype(_impl_.coach_with_referee_mode_) {}

    , decltype(_impl_.use_old_coach_hear_) {}

    , decltype(_impl_.dir_quantize_step_l_) {}

    , decltype(_impl_.dir_quantize_step_r_) {}

    , decltype(_impl_.slowness_on_top_for_left_team_) {}

    , decltype(_impl_.slowness_on_top_for_right_team_) {}

    , decltype(_impl_.start_goal_l_) {}

    , decltype(_impl_.start_goal_r_) {}

    , decltype(_impl_.drop_ball_time_) {}

    , decltype(_impl_.fullstate_l_) {}

    , decltype(_impl_.fullstate_r_) {}

    , decltype(_impl_.synch_mode_) {}

    , decltype(_impl_.verbose_mode_) {}

    , decltype(_impl_.synch_offset_) {}

    , decltype(_impl_.synch_micro_sleep_) {}

    , decltype(_impl_.point_to_ban_) {}

    , decltype(_impl_.point_to_duration_) {}

    , decltype(_impl_.player_port_) {}

    , decltype(_impl_.trainer_port_) {}

    , decltype(_impl_.online_coach_port_) {}

    , decltype(_impl_.coach_send_vi_step_) {}

    , decltype(_impl_.send_comms_) {}

    , decltype(_impl_.text_logging_) {}

    , decltype(_impl_.game_logging_) {}

    , decltype(_impl_.use_text_log_fixed_) {}

    , decltype(_impl_.game_log_version_) {}

    , decltype(_impl_.use_game_log_fixed_) {}

    , decltype(_impl_.use_text_log_dated_) {}

    , decltype(_impl_.use_game_log_dated_) {}

    , decltype(_impl_.log_times_) {}

    , decltype(_impl_.text_log_compression_) {}

    , decltype(_impl_.game_log_compression_) {}

    , decltype(_impl_.tackle_dist_) {}

    , decltype(_impl_.tackle_back_dist_) {}

    , decltype(_impl_.tackle_width_) {}

    , decltype(_impl_.tackle_exponent_) {}

    , decltype(_impl_.record_message_) {}

    , decltype(_impl_.use_profile_) {}

    , decltype(_impl_.free_kick_faults_) {}

    , decltype(_impl_.back_passes_) {}

    , decltype(_impl_.tackle_cycles_) {}

    , decltype(_impl_.tackle_power_rate_) {}

    , decltype(_impl_.freeform_wait_period_) {}

    , decltype(_impl_.freeform_send_period_) {}

    , decltype(_impl_.stopped_ball_vel_) {}

    , decltype(_impl_.max_goal_kicks_) {}

    , decltype(_impl_.clang_del_win_) {}

    , decltype(_impl_.clang_rule_win_) {}

    , decltype(_impl_.kick_off_wait_) {}

    , decltype(_impl_.connect_wait_) {}

    , decltype(_impl_.proper_goal_kicks_) {}

    , decltype(_impl_.auto_mode_) {}

    , decltype(_impl_.keepaway_mode_) {}

    , decltype(_impl_.keepaway_logging_) {}

    , decltype(_impl_.game_over_wait_) {}

    , decltype(_impl_.keepaway_length_) {}

    , decltype(_impl_.keepaway_width_) {}

    , decltype(_impl_.keepaway_start_) {}

    , decltype(_impl_.nr_normal_halfs_) {}

    , decltype(_impl_.nr_extra_halfs_) {}

    , decltype(_impl_.keepaway_log_fixed_) {}

    , decltype(_impl_.keepaway_log_dated_) {}

    , decltype(_impl_.penalty_shoot_outs_) {}

    , decltype(_impl_.pen_random_winner_) {}

    , decltype(_impl_.pen_before_setup_wait_) {}

    , decltype(_impl_.pen_setup_wait_) {}

    , decltype(_impl_.pen_ready_wait_) {}

    , decltype(_impl_.pen_taken_wait_) {}

    , decltype(_impl_.pen_nr_kicks_) {}

    , decltype(_impl_.pen_max_extra_kicks_) {}

    , decltype(_impl_.pen_dist_x_) {}

    , decltype(_impl_.pen_max_goalie_dist_x_) {}

    , decltype(_impl_.ball_stuck_area_) {}

    , decltype(_impl_.max_tackle_power_) {}

    , decltype(_impl_.max_back_tackle_power_) {}

    , decltype(_impl_.player_speed_max_min_) {}

    , decltype(_impl_.pen_allow_mult_kicks_) {}

    , decltype(_impl_.pen_coach_moves_players_) {}

    , decltype(_impl_.golden_goal_) {}

    , decltype(_impl_.extra_stamina_) {}

    , decltype(_impl_.synch_see_offset_) {}

    , decltype(_impl_.extra_half_time_) {}

    , decltype(_impl_.stamina_capacity_) {}

    , decltype(_impl_.max_dash_angle_) {}

    , decltype(_impl_.min_dash_angle_) {}

    , decltype(_impl_.dash_angle_step_) {}

    , decltype(_impl_.side_dash_rate_) {}

    , decltype(_impl_.back_dash_rate_) {}

    , decltype(_impl_.max_dash_power_) {}

    , decltype(_impl_.min_dash_power_) {}

    , decltype(_impl_.tackle_rand_factor_) {}

    , decltype(_impl_.foul_detect_probability_) {}

    , decltype(_impl_.foul_exponent_) {}

    , decltype(_impl_.foul_cycles_) {}

    , decltype(_impl_.red_card_probability_) {}

    , decltype(_impl_.illegal_defense_duration_) {}

    , decltype(_impl_.illegal_defense_number_) {}

    , decltype(_impl_.illegal_defense_dist_x_) {}

    , decltype(_impl_.illegal_defense_width_) {}

    , decltype(_impl_.max_catch_angle_) {}

    , decltype(_impl_.min_catch_angle_) {}

    , decltype(_impl_.random_seed_) {}

    , decltype(_impl_.long_kick_power_factor_) {}

    , decltype(_impl_.long_kick_delay_) {}

    , decltype(_impl_.max_monitors_) {}

    , decltype(_impl_.catchable_area_) {}

    , decltype(_impl_.real_speed_max_) {}

    , decltype(_impl_.pitch_half_length_) {}

    , decltype(_impl_.pitch_half_width_) {}

    , decltype(_impl_.our_penalty_area_line_x_) {}

    , decltype(_impl_.their_penalty_area_line_x_) {}

    , decltype(_impl_.penalty_area_half_width_) {}

    , decltype(_impl_.penalty_area_length_) {}

    , decltype(_impl_.goal_width_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.replay_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.replay_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_replay_file().empty()) {
    _this->_impl_.replay_file_.Set(from._internal_replay_file(), _this->GetArenaForAllocation());
  }
  _impl_.landmark_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.landmark_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_landmark_file().empty()) {
    _this->_impl_.landmark_file_.Set(from._internal_landmark_file(), _this->GetArenaForAllocation());
  }
  _impl_.text_log_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_log_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text_log_dir().empty()) {
    _this->_impl_.text_log_dir_.Set(from._internal_text_log_dir(), _this->GetArenaForAllocation());
  }
  _impl_.game_log_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.game_log_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_game_log_dir().empty()) {
    _this->_impl_.game_log_dir_.Set(from._internal_game_log_dir(), _this->GetArenaForAllocation());
  }
  _impl_.text_log_fixed_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_log_fixed_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text_log_fixed_name().empty()) {
    _this->_impl_.text_log_fixed_name_.Set(from._internal_text_log_fixed_name(), _this->GetArenaForAllocation());
  }
  _impl_.game_log_fixed_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.game_log_fixed_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_game_log_fixed_name().empty()) {
    _this->_impl_.game_log_fixed_name_.Set(from._internal_game_log_fixed_name(), _this->GetArenaForAllocation());
  }
  _impl_.log_date_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.log_date_format_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_log_date_format().empty()) {
    _this->_impl_.log_date_format_.Set(from._internal_log_date_format(), _this->GetArenaForAllocation());
  }
  _impl_.team_l_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.team_l_start_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_team_l_start().empty()) {
    _this->_impl_.team_l_start_.Set(from._internal_team_l_start(), _this->GetArenaForAllocation());
  }
  _impl_.team_r_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.team_r_start_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_team_r_start().empty()) {
    _this->_impl_.team_r_start_.Set(from._internal_team_r_start(), _this->GetArenaForAllocation());
  }
  _impl_.keepaway_log_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.keepaway_log_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_keepaway_log_dir().empty()) {
    _this->_impl_.keepaway_log_dir_.Set(from._internal_keepaway_log_dir(), _this->GetArenaForAllocation());
  }
  _impl_.keepaway_log_fixed_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.keepaway_log_fixed_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_keepaway_log_fixed_name().empty()) {
    _this->_impl_.keepaway_log_fixed_name_.Set(from._internal_keepaway_log_fixed_name(), _this->GetArenaForAllocation());
  }
  _impl_.module_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.module_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_module_dir().empty()) {
    _this->_impl_.module_dir_.Set(from._internal_module_dir(), _this->GetArenaForAllocation());
  }
  _impl_.coach_msg_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.coach_msg_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_coach_msg_file().empty()) {
    _this->_impl_.coach_msg_file_.Set(from._internal_coach_msg_file(), _this->GetArenaForAllocation());
  }
  _impl_.fixed_teamname_l_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fixed_teamname_l_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fixed_teamname_l().empty()) {
    _this->_impl_.fixed_teamname_l_.Set(from._internal_fixed_teamname_l(), _this->GetArenaForAllocation());
  }
  _impl_.fixed_teamname_r_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fixed_teamname_r_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fixed_teamname_r().empty()) {
    _this->_impl_.fixed_teamname_r_.Set(from._internal_fixed_teamname_r(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.agent_type_, &from._impl_.agent_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.goal_width_) -
    reinterpret_cast<char*>(&_impl_.agent_type_)) + sizeof(_impl_.goal_width_));
  // @@protoc_insertion_point(copy_constructor:protos.ServerParam)
}

inline void ServerParam::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.replay_file_) {}

    , decltype(_impl_.landmark_file_) {}

    , decltype(_impl_.text_log_dir_) {}

    , decltype(_impl_.game_log_dir_) {}

    , decltype(_impl_.text_log_fixed_name_) {}

    , decltype(_impl_.game_log_fixed_name_) {}

    , decltype(_impl_.log_date_format_) {}

    , decltype(_impl_.team_l_start_) {}

    , decltype(_impl_.team_r_start_) {}

    , decltype(_impl_.keepaway_log_dir_) {}

    , decltype(_impl_.keepaway_log_fixed_name_) {}

    , decltype(_impl_.module_dir_) {}

    , decltype(_impl_.coach_msg_file_) {}

    , decltype(_impl_.fixed_teamname_l_) {}

    , decltype(_impl_.fixed_teamname_r_) {}

    , decltype(_impl_.agent_type_) { 0 }

    , decltype(_impl_.inertia_moment_) { 0 }

    , decltype(_impl_.player_size_) { 0 }

    , decltype(_impl_.player_decay_) { 0 }

    , decltype(_impl_.player_rand_) { 0 }

    , decltype(_impl_.player_weight_) { 0 }

    , decltype(_impl_.player_speed_max_) { 0 }

    , decltype(_impl_.player_accel_max_) { 0 }

    , decltype(_impl_.stamina_max_) { 0 }

    , decltype(_impl_.stamina_inc_max_) { 0 }

    , decltype(_impl_.recover_init_) { 0 }

    , decltype(_impl_.recover_dec_thr_) { 0 }

    , decltype(_impl_.recover_min_) { 0 }

    , decltype(_impl_.recover_dec_) { 0 }

    , decltype(_impl_.effort_init_) { 0 }

    , decltype(_impl_.effort_dec_thr_) { 0 }

    , decltype(_impl_.effort_min_) { 0 }

    , decltype(_impl_.effort_dec_) { 0 }

    , decltype(_impl_.effort_inc_thr_) { 0 }

    , decltype(_impl_.effort_inc_) { 0 }

    , decltype(_impl_.kick_rand_) { 0 }

    , decltype(_impl_.player_rand_factor_l_) { 0 }

    , decltype(_impl_.player_rand_factor_r_) { 0 }

    , decltype(_impl_.kick_rand_factor_l_) { 0 }

    , decltype(_impl_.kick_rand_factor_r_) { 0 }

    , decltype(_impl_.ball_size_) { 0 }

    , decltype(_impl_.ball_decay_) { 0 }

    , decltype(_impl_.ball_rand_) { 0 }

    , decltype(_impl_.ball_weight_) { 0 }

    , decltype(_impl_.ball_speed_max_) { 0 }

    , decltype(_impl_.ball_accel_max_) { 0 }

    , decltype(_impl_.dash_power_rate_) { 0 }

    , decltype(_impl_.kick_power_rate_) { 0 }

    , decltype(_impl_.kickable_margin_) { 0 }

    , decltype(_impl_.control_radius_) { 0 }

    , decltype(_impl_.control_radius_width_) { 0 }

    , decltype(_impl_.max_power_) { 0 }

    , decltype(_impl_.min_power_) { 0 }

    , decltype(_impl_.max_moment_) { 0 }

    , decltype(_impl_.min_moment_) { 0 }

    , decltype(_impl_.max_neck_moment_) { 0 }

    , decltype(_impl_.min_neck_moment_) { 0 }

    , decltype(_impl_.max_neck_angle_) { 0 }

    , decltype(_impl_.min_neck_angle_) { 0 }

    , decltype(_impl_.visible_angle_) { 0 }

    , decltype(_impl_.visible_distance_) { 0 }

    , decltype(_impl_.wind_dir_) { 0 }

    , decltype(_impl_.wind_force_) { 0 }

    , decltype(_impl_.wind_angle_) { 0 }

    , decltype(_impl_.wind_rand_) { 0 }

    , decltype(_impl_.kickable_area_) { 0 }

    , decltype(_impl_.catch_area_l_) { 0 }

    , decltype(_impl_.catch_area_w_) { 0 }

    , decltype(_impl_.catch_probability_) { 0 }

    , decltype(_impl_.team_actuator_noise_) { false }

    , decltype(_impl_.wind_none_) { false }

    , decltype(_impl_.use_wind_random_) { false }

    , decltype(_impl_.use_offside_) { false }

    , decltype(_impl_.goalie_max_moves_) { 0 }

    , decltype(_impl_.corner_kick_margin_) { 0 }

    , decltype(_impl_.offside_active_area_size_) { 0 }

    , decltype(_impl_.coach_say_count_max_) { 0 }

    , decltype(_impl_.coach_say_msg_size_) { 0 }

    , decltype(_impl_.clang_win_size_) { 0 }

    , decltype(_impl_.clang_define_win_) { 0 }

    , decltype(_impl_.clang_meta_win_) { 0 }

    , decltype(_impl_.clang_advice_win_) { 0 }

    , decltype(_impl_.clang_info_win_) { 0 }

    , decltype(_impl_.clang_mess_delay_) { 0 }

    , decltype(_impl_.clang_mess_per_cycle_) { 0 }

    , decltype(_impl_.half_time_) { 0 }

    , decltype(_impl_.simulator_step_) { 0 }

    , decltype(_impl_.send_step_) { 0 }

    , decltype(_impl_.recv_step_) { 0 }

    , decltype(_impl_.sense_body_step_) { 0 }

    , decltype(_impl_.lcm_step_) { 0 }

    , decltype(_impl_.player_say_msg_size_) { 0 }

    , decltype(_impl_.player_hear_max_) { 0 }

    , decltype(_impl_.player_hear_inc_) { 0 }

    , decltype(_impl_.player_hear_decay_) { 0 }

    , decltype(_impl_.catch_ban_cycle_) { 0 }

    , decltype(_impl_.slow_down_factor_) { 0 }

    , decltype(_impl_.offside_kick_margin_) { 0 }

    , decltype(_impl_.audio_cut_dist_) { 0 }

    , decltype(_impl_.dist_quantize_step_) { 0 }

    , decltype(_impl_.landmark_dist_quantize_step_) { 0 }

    , decltype(_impl_.dir_quantize_step_) { 0 }

    , decltype(_impl_.dist_quantize_step_l_) { 0 }

    , decltype(_impl_.dist_quantize_step_r_) { 0 }

    , decltype(_impl_.landmark_dist_quantize_step_l_) { 0 }

    , decltype(_impl_.landmark_dist_quantize_step_r_) { 0 }

    , decltype(_impl_.kickoff_offside_) { false }

    , decltype(_impl_.coach_mode_) { false }

    , decltype(_impl_.coach_with_referee_mode_) { false }

    , decltype(_impl_.use_old_coach_hear_) { false }

    , decltype(_impl_.dir_quantize_step_l_) { 0 }

    , decltype(_impl_.dir_quantize_step_r_) { 0 }

    , decltype(_impl_.slowness_on_top_for_left_team_) { 0 }

    , decltype(_impl_.slowness_on_top_for_right_team_) { 0 }

    , decltype(_impl_.start_goal_l_) { 0 }

    , decltype(_impl_.start_goal_r_) { 0 }

    , decltype(_impl_.drop_ball_time_) { 0 }

    , decltype(_impl_.fullstate_l_) { false }

    , decltype(_impl_.fullstate_r_) { false }

    , decltype(_impl_.synch_mode_) { false }

    , decltype(_impl_.verbose_mode_) { false }

    , decltype(_impl_.synch_offset_) { 0 }

    , decltype(_impl_.synch_micro_sleep_) { 0 }

    , decltype(_impl_.point_to_ban_) { 0 }

    , decltype(_impl_.point_to_duration_) { 0 }

    , decltype(_impl_.player_port_) { 0 }

    , decltype(_impl_.trainer_port_) { 0 }

    , decltype(_impl_.online_coach_port_) { 0 }

    , decltype(_impl_.coach_send_vi_step_) { 0 }

    , decltype(_impl_.send_comms_) { false }

    , decltype(_impl_.text_logging_) { false }

    , decltype(_impl_.game_logging_) { false }

    , decltype(_impl_.use_text_log_fixed_) { false }

    , decltype(_impl_.game_log_version_) { 0 }

    , decltype(_impl_.use_game_log_fixed_) { false }

    , decltype(_impl_.use_text_log_dated_) { false }

    , decltype(_impl_.use_game_log_dated_) { false }

    , decltype(_impl_.log_times_) { false }

    , decltype(_impl_.text_log_compression_) { 0 }

    , decltype(_impl_.game_log_compression_) { 0 }

    , decltype(_impl_.tackle_dist_) { 0 }

    , decltype(_impl_.tackle_back_dist_) { 0 }

    , decltype(_impl_.tackle_width_) { 0 }

    , decltype(_impl_.tackle_exponent_) { 0 }

    , decltype(_impl_.record_message_) { false }

    , decltype(_impl_.use_profile_) { false }

    , decltype(_impl_.free_kick_faults_) { false }

    , decltype(_impl_.back_passes_) { false }

    , decltype(_impl_.tackle_cycles_) { 0 }

    , decltype(_impl_.tackle_power_rate_) { 0 }

    , decltype(_impl_.freeform_wait_period_) { 0 }

    , decltype(_impl_.freeform_send_period_) { 0 }

    , decltype(_impl_.stopped_ball_vel_) { 0 }

    , decltype(_impl_.max_goal_kicks_) { 0 }

    , decltype(_impl_.clang_del_win_) { 0 }

    , decltype(_impl_.clang_rule_win_) { 0 }

    , decltype(_impl_.kick_off_wait_) { 0 }

    , decltype(_impl_.connect_wait_) { 0 }

    , decltype(_impl_.proper_goal_kicks_) { false }

    , decltype(_impl_.auto_mode_) { false }

    , decltype(_impl_.keepaway_mode_) { false }

    , decltype(_impl_.keepaway_logging_) { false }

    , decltype(_impl_.game_over_wait_) { 0 }

    , decltype(_impl_.keepaway_length_) { 0 }

    , decltype(_impl_.keepaway_width_) { 0 }

    , decltype(_impl_.keepaway_start_) { 0 }

    , decltype(_impl_.nr_normal_halfs_) { 0 }

    , decltype(_impl_.nr_extra_halfs_) { 0 }

    , decltype(_impl_.keepaway_log_fixed_) { false }

    , decltype(_impl_.keepaway_log_dated_) { false }

    , decltype(_impl_.penalty_shoot_outs_) { false }

    , decltype(_impl_.pen_random_winner_) { false }

    , decltype(_impl_.pen_before_setup_wait_) { 0 }

    , decltype(_impl_.pen_setup_wait_) { 0 }

    , decltype(_impl_.pen_ready_wait_) { 0 }

    , decltype(_impl_.pen_taken_wait_) { 0 }

    , decltype(_impl_.pen_nr_kicks_) { 0 }

    , decltype(_impl_.pen_max_extra_kicks_) { 0 }

    , decltype(_impl_.pen_dist_x_) { 0 }

    , decltype(_impl_.pen_max_goalie_dist_x_) { 0 }

    , decltype(_impl_.ball_stuck_area_) { 0 }

    , decltype(_impl_.max_tackle_power_) { 0 }

    , decltype(_impl_.max_back_tackle_power_) { 0 }

    , decltype(_impl_.player_speed_max_min_) { 0 }

    , decltype(_impl_.pen_allow_mult_kicks_) { false }

    , decltype(_impl_.pen_coach_moves_players_) { false }

    , decltype(_impl_.golden_goal_) { false }

    , decltype(_impl_.extra_stamina_) { 0 }

    , decltype(_impl_.synch_see_offset_) { 0 }

    , decltype(_impl_.extra_half_time_) { 0 }

    , decltype(_impl_.stamina_capacity_) { 0 }

    , decltype(_impl_.max_dash_angle_) { 0 }

    , decltype(_impl_.min_dash_angle_) { 0 }

    , decltype(_impl_.dash_angle_step_) { 0 }

    , decltype(_impl_.side_dash_rate_) { 0 }

    , decltype(_impl_.back_dash_rate_) { 0 }

    , decltype(_impl_.max_dash_power_) { 0 }

    , decltype(_impl_.min_dash_power_) { 0 }

    , decltype(_impl_.tackle_rand_factor_) { 0 }

    , decltype(_impl_.foul_detect_probability_) { 0 }

    , decltype(_impl_.foul_exponent_) { 0 }

    , decltype(_impl_.foul_cycles_) { 0 }

    , decltype(_impl_.red_card_probability_) { 0 }

    , decltype(_impl_.illegal_defense_duration_) { 0 }

    , decltype(_impl_.illegal_defense_number_) { 0 }

    , decltype(_impl_.illegal_defense_dist_x_) { 0 }

    , decltype(_impl_.illegal_defense_width_) { 0 }

    , decltype(_impl_.max_catch_angle_) { 0 }

    , decltype(_impl_.min_catch_angle_) { 0 }

    , decltype(_impl_.random_seed_) { 0 }

    , decltype(_impl_.long_kick_power_factor_) { 0 }

    , decltype(_impl_.long_kick_delay_) { 0 }

    , decltype(_impl_.max_monitors_) { 0 }

    , decltype(_impl_.catchable_area_) { 0 }

    , decltype(_impl_.real_speed_max_) { 0 }

    , decltype(_impl_.pitch_half_length_) { 0 }

    , decltype(_impl_.pitch_half_width_) { 0 }

    , decltype(_impl_.our_penalty_area_line_x_) { 0 }

    , decltype(_impl_.their_penalty_area_line_x_) { 0 }

    , decltype(_impl_.penalty_area_half_width_) { 0 }

    , decltype(_impl_.penalty_area_length_) { 0 }

    , decltype(_impl_.goal_width_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.replay_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.replay_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.landmark_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.landmark_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_log_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_log_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_log_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.game_log_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_log_fixed_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_log_fixed_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_log_fixed_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.game_log_fixed_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.log_date_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.log_date_format_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_l_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.team_l_start_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_r_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.team_r_start_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.keepaway_log_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.keepaway_log_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.keepaway_log_fixed_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.keepaway_log_fixed_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.module_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.module_dir_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.coach_msg_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.coach_msg_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fixed_teamname_l_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fixed_teamname_l_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fixed_teamname_r_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fixed_teamname_r_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServerParam::~ServerParam() {
  // @@protoc_insertion_point(destructor:protos.ServerParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerParam::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.replay_file_.Destroy();
  _impl_.landmark_file_.Destroy();
  _impl_.text_log_dir_.Destroy();
  _impl_.game_log_dir_.Destroy();
  _impl_.text_log_fixed_name_.Destroy();
  _impl_.game_log_fixed_name_.Destroy();
  _impl_.log_date_format_.Destroy();
  _impl_.team_l_start_.Destroy();
  _impl_.team_r_start_.Destroy();
  _impl_.keepaway_log_dir_.Destroy();
  _impl_.keepaway_log_fixed_name_.Destroy();
  _impl_.module_dir_.Destroy();
  _impl_.coach_msg_file_.Destroy();
  _impl_.fixed_teamname_l_.Destroy();
  _impl_.fixed_teamname_r_.Destroy();
}

void ServerParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerParam::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.ServerParam)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.replay_file_.ClearToEmpty();
  _impl_.landmark_file_.ClearToEmpty();
  _impl_.text_log_dir_.ClearToEmpty();
  _impl_.game_log_dir_.ClearToEmpty();
  _impl_.text_log_fixed_name_.ClearToEmpty();
  _impl_.game_log_fixed_name_.ClearToEmpty();
  _impl_.log_date_format_.ClearToEmpty();
  _impl_.team_l_start_.ClearToEmpty();
  _impl_.team_r_start_.ClearToEmpty();
  _impl_.keepaway_log_dir_.ClearToEmpty();
  _impl_.keepaway_log_fixed_name_.ClearToEmpty();
  _impl_.module_dir_.ClearToEmpty();
  _impl_.coach_msg_file_.ClearToEmpty();
  _impl_.fixed_teamname_l_.ClearToEmpty();
  _impl_.fixed_teamname_r_.ClearToEmpty();
  ::memset(&_impl_.agent_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.goal_width_) -
      reinterpret_cast<char*>(&_impl_.agent_type_)) + sizeof(_impl_.goal_width_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.AgentType agent_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_agent_type(static_cast<::protos::AgentType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // float inertia_moment = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.inertia_moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.player_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_decay = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.player_decay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_rand = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.player_rand_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_weight = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.player_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_speed_max = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _impl_.player_speed_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_accel_max = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.player_accel_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina_max = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.stamina_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina_inc_max = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.stamina_inc_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float recover_init = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 93)) {
          _impl_.recover_init_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float recover_dec_thr = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.recover_dec_thr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float recover_min = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.recover_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float recover_dec = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 117)) {
          _impl_.recover_dec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_init = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _impl_.effort_init_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_dec_thr = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.effort_dec_thr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_min = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.effort_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_dec = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 149)) {
          _impl_.effort_dec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_inc_thr = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.effort_inc_thr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_inc = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 165)) {
          _impl_.effort_inc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_rand = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.kick_rand_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool team_actuator_noise = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.team_actuator_noise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_rand_factor_l = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.player_rand_factor_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_rand_factor_r = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.player_rand_factor_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_rand_factor_l = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.kick_rand_factor_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_rand_factor_r = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.kick_rand_factor_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_size = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.ball_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_decay = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.ball_decay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_rand = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.ball_rand_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_weight = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 245)) {
          _impl_.ball_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_speed_max = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 253)) {
          _impl_.ball_speed_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_accel_max = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 5)) {
          _impl_.ball_accel_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power_rate = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.dash_power_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_power_rate = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.kick_power_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kickable_margin = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.kickable_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float control_radius = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.control_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float control_radius_width = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.control_radius_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_power = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.max_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_power = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _impl_.min_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_moment = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.max_moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_moment = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.min_moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_neck_moment = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.max_neck_moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_neck_moment = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 93)) {
          _impl_.min_neck_moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_neck_angle = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.max_neck_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_neck_angle = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.min_neck_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float visible_angle = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 117)) {
          _impl_.visible_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float visible_distance = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _impl_.visible_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wind_dir = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.wind_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wind_force = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.wind_force_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wind_angle = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 149)) {
          _impl_.wind_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wind_rand = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.wind_rand_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kickable_area = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 165)) {
          _impl_.kickable_area_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catch_area_l = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.catch_area_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catch_area_w = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 181)) {
          _impl_.catch_area_w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catch_probability = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.catch_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 goalie_max_moves = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.goalie_max_moves_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float corner_kick_margin = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.corner_kick_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float offside_active_area_size = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.offside_active_area_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool wind_none = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.wind_none_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_wind_random = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.use_wind_random_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 coach_say_count_max = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.coach_say_count_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 coach_say_msg_size = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _impl_.coach_say_msg_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_win_size = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 248)) {
          _impl_.clang_win_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_define_win = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 0)) {
          _impl_.clang_define_win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_meta_win = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.clang_meta_win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_advice_win = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.clang_advice_win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_info_win = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.clang_info_win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_mess_delay = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.clang_mess_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_mess_per_cycle = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.clang_mess_per_cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 half_time = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.half_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 simulator_step = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.simulator_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 send_step = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.send_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 recv_step = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.recv_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 sense_body_step = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.sense_body_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 lcm_step = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.lcm_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_say_msg_size = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.player_say_msg_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_hear_max = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.player_hear_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_hear_inc = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.player_hear_inc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_hear_decay = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.player_hear_decay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 catch_ban_cycle = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.catch_ban_cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 slow_down_factor = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.slow_down_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_offside = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.use_offside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool kickoff_offside = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          _impl_.kickoff_offside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float offside_kick_margin = 84;
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 165)) {
          _impl_.offside_kick_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float audio_cut_dist = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.audio_cut_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_quantize_step = 86;
      case 86:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 181)) {
          _impl_.dist_quantize_step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float landmark_dist_quantize_step = 87;
      case 87:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.landmark_dist_quantize_step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dir_quantize_step = 88;
      case 88:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.dir_quantize_step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_quantize_step_l = 89;
      case 89:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.dist_quantize_step_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_quantize_step_r = 90;
      case 90:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.dist_quantize_step_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float landmark_dist_quantize_step_l = 91;
      case 91:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.landmark_dist_quantize_step_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float landmark_dist_quantize_step_r = 92;
      case 92:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.landmark_dist_quantize_step_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dir_quantize_step_l = 93;
      case 93:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.dir_quantize_step_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dir_quantize_step_r = 94;
      case 94:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 245)) {
          _impl_.dir_quantize_step_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool coach_mode = 95;
      case 95:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 248)) {
          _impl_.coach_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool coach_with_referee_mode = 96;
      case 96:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 0)) {
          _impl_.coach_with_referee_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_old_coach_hear = 97;
      case 97:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.use_old_coach_hear_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float slowness_on_top_for_left_team = 98;
      case 98:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.slowness_on_top_for_left_team_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float slowness_on_top_for_right_team = 99;
      case 99:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.slowness_on_top_for_right_team_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 start_goal_l = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.start_goal_l_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 start_goal_r = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.start_goal_r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fullstate_l = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.fullstate_l_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fullstate_r = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.fullstate_r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 drop_ball_time = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.drop_ball_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool synch_mode = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.synch_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 synch_offset = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.synch_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 synch_micro_sleep = 107;
      case 107:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.synch_micro_sleep_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_ban = 108;
      case 108:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.point_to_ban_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_duration = 109;
      case 109:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.point_to_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_port = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.player_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 trainer_port = 111;
      case 111:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.trainer_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 online_coach_port = 112;
      case 112:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.online_coach_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool verbose_mode = 113;
      case 113:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.verbose_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 coach_send_vi_step = 114;
      case 114:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.coach_send_vi_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string replay_file = 115;
      case 115:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_replay_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.replay_file"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string landmark_file = 116;
      case 116:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_landmark_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.landmark_file"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool send_comms = 117;
      case 117:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.send_comms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool text_logging = 118;
      case 118:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.text_logging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool game_logging = 119;
      case 119:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.game_logging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 game_log_version = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.game_log_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string text_log_dir = 121;
      case 121:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_text_log_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.text_log_dir"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string game_log_dir = 122;
      case 122:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_game_log_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.game_log_dir"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string text_log_fixed_name = 123;
      case 123:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_text_log_fixed_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.text_log_fixed_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string game_log_fixed_name = 124;
      case 124:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_game_log_fixed_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.game_log_fixed_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_text_log_fixed = 125;
      case 125:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.use_text_log_fixed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_game_log_fixed = 126;
      case 126:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _impl_.use_game_log_fixed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_text_log_dated = 127;
      case 127:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 248)) {
          _impl_.use_text_log_dated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_game_log_dated = 128;
      case 128:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 0)) {
          _impl_.use_game_log_dated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string log_date_format = 129;
      case 129:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_log_date_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.log_date_format"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool log_times = 130;
      case 130:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.log_times_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool record_message = 131;
      case 131:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.record_message_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 text_log_compression = 132;
      case 132:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.text_log_compression_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 game_log_compression = 133;
      case 133:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.game_log_compression_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_profile = 134;
      case 134:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.use_profile_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_dist = 135;
      case 135:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _impl_.tackle_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_back_dist = 136;
      case 136:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.tackle_back_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_width = 137;
      case 137:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.tackle_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_exponent = 138;
      case 138:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.tackle_exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 tackle_cycles = 139;
      case 139:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.tackle_cycles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_power_rate = 140;
      case 140:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.tackle_power_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 freeform_wait_period = 141;
      case 141:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.freeform_wait_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 freeform_send_period = 142;
      case 142:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.freeform_send_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool free_kick_faults = 143;
      case 143:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.free_kick_faults_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool back_passes = 144;
      case 144:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.back_passes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool proper_goal_kicks = 145;
      case 145:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.proper_goal_kicks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stopped_ball_vel = 146;
      case 146:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 149)) {
          _impl_.stopped_ball_vel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 max_goal_kicks = 147;
      case 147:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          _impl_.max_goal_kicks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_del_win = 148;
      case 148:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.clang_del_win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 clang_rule_win = 149;
      case 149:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.clang_rule_win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool auto_mode = 150;
      case 150:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.auto_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 kick_off_wait = 151;
      case 151:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.kick_off_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 connect_wait = 152;
      case 152:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.connect_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 game_over_wait = 153;
      case 153:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.game_over_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string team_l_start = 154;
      case 154:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_team_l_start();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.team_l_start"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string team_r_start = 155;
      case 155:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_team_r_start();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.team_r_start"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool keepaway_mode = 156;
      case 156:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.keepaway_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float keepaway_length = 157;
      case 157:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.keepaway_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float keepaway_width = 158;
      case 158:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 245)) {
          _impl_.keepaway_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool keepaway_logging = 159;
      case 159:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 248)) {
          _impl_.keepaway_logging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string keepaway_log_dir = 160;
      case 160:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_keepaway_log_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.keepaway_log_dir"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string keepaway_log_fixed_name = 161;
      case 161:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_keepaway_log_fixed_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.keepaway_log_fixed_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool keepaway_log_fixed = 162;
      case 162:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.keepaway_log_fixed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool keepaway_log_dated = 163;
      case 163:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.keepaway_log_dated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 keepaway_start = 164;
      case 164:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.keepaway_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 nr_normal_halfs = 165;
      case 165:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.nr_normal_halfs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 nr_extra_halfs = 166;
      case 166:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.nr_extra_halfs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool penalty_shoot_outs = 167;
      case 167:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.penalty_shoot_outs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pen_before_setup_wait = 168;
      case 168:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.pen_before_setup_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pen_setup_wait = 169;
      case 169:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.pen_setup_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pen_ready_wait = 170;
      case 170:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.pen_ready_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pen_taken_wait = 171;
      case 171:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.pen_taken_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pen_nr_kicks = 172;
      case 172:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.pen_nr_kicks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pen_max_extra_kicks = 173;
      case 173:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.pen_max_extra_kicks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float pen_dist_x = 174;
      case 174:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 117)) {
          _impl_.pen_dist_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool pen_random_winner = 175;
      case 175:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.pen_random_winner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool pen_allow_mult_kicks = 176;
      case 176:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.pen_allow_mult_kicks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float pen_max_goalie_dist_x = 177;
      case 177:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.pen_max_goalie_dist_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool pen_coach_moves_players = 178;
      case 178:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.pen_coach_moves_players_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string module_dir = 179;
      case 179:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_module_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.module_dir"));
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_stuck_area = 180;
      case 180:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 165)) {
          _impl_.ball_stuck_area_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string coach_msg_file = 181;
      case 181:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_coach_msg_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.coach_msg_file"));
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_tackle_power = 182;
      case 182:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 181)) {
          _impl_.max_tackle_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_back_tackle_power = 183;
      case 183:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.max_back_tackle_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_speed_max_min = 184;
      case 184:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.player_speed_max_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float extra_stamina = 185;
      case 185:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.extra_stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 synch_see_offset = 186;
      case 186:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.synch_see_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 extra_half_time = 187;
      case 187:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.extra_half_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina_capacity = 188;
      case 188:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.stamina_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_dash_angle = 189;
      case 189:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.max_dash_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_dash_angle = 190;
      case 190:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 245)) {
          _impl_.min_dash_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_angle_step = 191;
      case 191:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 253)) {
          _impl_.dash_angle_step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float side_dash_rate = 192;
      case 192:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 5)) {
          _impl_.side_dash_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float back_dash_rate = 193;
      case 193:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.back_dash_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_dash_power = 194;
      case 194:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.max_dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_dash_power = 195;
      case 195:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.min_dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_rand_factor = 196;
      case 196:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.tackle_rand_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float foul_detect_probability = 197;
      case 197:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.foul_detect_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float foul_exponent = 198;
      case 198:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.foul_exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 foul_cycles = 199;
      case 199:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.foul_cycles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool golden_goal = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.golden_goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float red_card_probability = 201;
      case 201:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.red_card_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 illegal_defense_duration = 202;
      case 202:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.illegal_defense_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 illegal_defense_number = 203;
      case 203:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.illegal_defense_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float illegal_defense_dist_x = 204;
      case 204:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.illegal_defense_dist_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float illegal_defense_width = 205;
      case 205:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.illegal_defense_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string fixed_teamname_l = 206;
      case 206:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_fixed_teamname_l();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.fixed_teamname_l"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string fixed_teamname_r = 207;
      case 207:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_fixed_teamname_r();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.ServerParam.fixed_teamname_r"));
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_catch_angle = 208;
      case 208:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.max_catch_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_catch_angle = 209;
      case 209:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.min_catch_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 random_seed = 210;
      case 210:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float long_kick_power_factor = 211;
      case 211:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.long_kick_power_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 long_kick_delay = 212;
      case 212:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.long_kick_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 max_monitors = 213;
      case 213:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.max_monitors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catchable_area = 214;
      case 214:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 181)) {
          _impl_.catchable_area_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float real_speed_max = 215;
      case 215:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.real_speed_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float pitch_half_length = 216;
      case 216:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.pitch_half_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float pitch_half_width = 217;
      case 217:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.pitch_half_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float our_penalty_area_line_x = 218;
      case 218:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.our_penalty_area_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float their_penalty_area_line_x = 219;
      case 219:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.their_penalty_area_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float penalty_area_half_width = 220;
      case 220:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.penalty_area_half_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float penalty_area_length = 221;
      case 221:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.penalty_area_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float goal_width = 222;
      case 222:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 245)) {
          _impl_.goal_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ServerParam::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.ServerParam)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_agent_type(), target);
  }

  // float inertia_moment = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment = this->_internal_inertia_moment();
  ::uint32_t raw_inertia_moment;
  memcpy(&raw_inertia_moment, &tmp_inertia_moment, sizeof(tmp_inertia_moment));
  if (raw_inertia_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_inertia_moment(), target);
  }

  // float player_size = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size = this->_internal_player_size();
  ::uint32_t raw_player_size;
  memcpy(&raw_player_size, &tmp_player_size, sizeof(tmp_player_size));
  if (raw_player_size != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_player_size(), target);
  }

  // float player_decay = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay = this->_internal_player_decay();
  ::uint32_t raw_player_decay;
  memcpy(&raw_player_decay, &tmp_player_decay, sizeof(tmp_player_decay));
  if (raw_player_decay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_player_decay(), target);
  }

  // float player_rand = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand = this->_internal_player_rand();
  ::uint32_t raw_player_rand;
  memcpy(&raw_player_rand, &tmp_player_rand, sizeof(tmp_player_rand));
  if (raw_player_rand != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_player_rand(), target);
  }

  // float player_weight = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_weight = this->_internal_player_weight();
  ::uint32_t raw_player_weight;
  memcpy(&raw_player_weight, &tmp_player_weight, sizeof(tmp_player_weight));
  if (raw_player_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_player_weight(), target);
  }

  // float player_speed_max = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max = this->_internal_player_speed_max();
  ::uint32_t raw_player_speed_max;
  memcpy(&raw_player_speed_max, &tmp_player_speed_max, sizeof(tmp_player_speed_max));
  if (raw_player_speed_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_player_speed_max(), target);
  }

  // float player_accel_max = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_accel_max = this->_internal_player_accel_max();
  ::uint32_t raw_player_accel_max;
  memcpy(&raw_player_accel_max, &tmp_player_accel_max, sizeof(tmp_player_accel_max));
  if (raw_player_accel_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_player_accel_max(), target);
  }

  // float stamina_max = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_max = this->_internal_stamina_max();
  ::uint32_t raw_stamina_max;
  memcpy(&raw_stamina_max, &tmp_stamina_max, sizeof(tmp_stamina_max));
  if (raw_stamina_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_stamina_max(), target);
  }

  // float stamina_inc_max = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max = this->_internal_stamina_inc_max();
  ::uint32_t raw_stamina_inc_max;
  memcpy(&raw_stamina_inc_max, &tmp_stamina_inc_max, sizeof(tmp_stamina_inc_max));
  if (raw_stamina_inc_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_stamina_inc_max(), target);
  }

  // float recover_init = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_init = this->_internal_recover_init();
  ::uint32_t raw_recover_init;
  memcpy(&raw_recover_init, &tmp_recover_init, sizeof(tmp_recover_init));
  if (raw_recover_init != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_recover_init(), target);
  }

  // float recover_dec_thr = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_dec_thr = this->_internal_recover_dec_thr();
  ::uint32_t raw_recover_dec_thr;
  memcpy(&raw_recover_dec_thr, &tmp_recover_dec_thr, sizeof(tmp_recover_dec_thr));
  if (raw_recover_dec_thr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_recover_dec_thr(), target);
  }

  // float recover_min = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_min = this->_internal_recover_min();
  ::uint32_t raw_recover_min;
  memcpy(&raw_recover_min, &tmp_recover_min, sizeof(tmp_recover_min));
  if (raw_recover_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_recover_min(), target);
  }

  // float recover_dec = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_dec = this->_internal_recover_dec();
  ::uint32_t raw_recover_dec;
  memcpy(&raw_recover_dec, &tmp_recover_dec, sizeof(tmp_recover_dec));
  if (raw_recover_dec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_recover_dec(), target);
  }

  // float effort_init = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_init = this->_internal_effort_init();
  ::uint32_t raw_effort_init;
  memcpy(&raw_effort_init, &tmp_effort_init, sizeof(tmp_effort_init));
  if (raw_effort_init != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_effort_init(), target);
  }

  // float effort_dec_thr = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_dec_thr = this->_internal_effort_dec_thr();
  ::uint32_t raw_effort_dec_thr;
  memcpy(&raw_effort_dec_thr, &tmp_effort_dec_thr, sizeof(tmp_effort_dec_thr));
  if (raw_effort_dec_thr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_effort_dec_thr(), target);
  }

  // float effort_min = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min = this->_internal_effort_min();
  ::uint32_t raw_effort_min;
  memcpy(&raw_effort_min, &tmp_effort_min, sizeof(tmp_effort_min));
  if (raw_effort_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_effort_min(), target);
  }

  // float effort_dec = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_dec = this->_internal_effort_dec();
  ::uint32_t raw_effort_dec;
  memcpy(&raw_effort_dec, &tmp_effort_dec, sizeof(tmp_effort_dec));
  if (raw_effort_dec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        18, this->_internal_effort_dec(), target);
  }

  // float effort_inc_thr = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_inc_thr = this->_internal_effort_inc_thr();
  ::uint32_t raw_effort_inc_thr;
  memcpy(&raw_effort_inc_thr, &tmp_effort_inc_thr, sizeof(tmp_effort_inc_thr));
  if (raw_effort_inc_thr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_effort_inc_thr(), target);
  }

  // float effort_inc = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_inc = this->_internal_effort_inc();
  ::uint32_t raw_effort_inc;
  memcpy(&raw_effort_inc, &tmp_effort_inc, sizeof(tmp_effort_inc));
  if (raw_effort_inc != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        20, this->_internal_effort_inc(), target);
  }

  // float kick_rand = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand = this->_internal_kick_rand();
  ::uint32_t raw_kick_rand;
  memcpy(&raw_kick_rand, &tmp_kick_rand, sizeof(tmp_kick_rand));
  if (raw_kick_rand != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_kick_rand(), target);
  }

  // bool team_actuator_noise = 22;
  if (this->_internal_team_actuator_noise() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        22, this->_internal_team_actuator_noise(), target);
  }

  // float player_rand_factor_l = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand_factor_l = this->_internal_player_rand_factor_l();
  ::uint32_t raw_player_rand_factor_l;
  memcpy(&raw_player_rand_factor_l, &tmp_player_rand_factor_l, sizeof(tmp_player_rand_factor_l));
  if (raw_player_rand_factor_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        23, this->_internal_player_rand_factor_l(), target);
  }

  // float player_rand_factor_r = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand_factor_r = this->_internal_player_rand_factor_r();
  ::uint32_t raw_player_rand_factor_r;
  memcpy(&raw_player_rand_factor_r, &tmp_player_rand_factor_r, sizeof(tmp_player_rand_factor_r));
  if (raw_player_rand_factor_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        24, this->_internal_player_rand_factor_r(), target);
  }

  // float kick_rand_factor_l = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_factor_l = this->_internal_kick_rand_factor_l();
  ::uint32_t raw_kick_rand_factor_l;
  memcpy(&raw_kick_rand_factor_l, &tmp_kick_rand_factor_l, sizeof(tmp_kick_rand_factor_l));
  if (raw_kick_rand_factor_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        25, this->_internal_kick_rand_factor_l(), target);
  }

  // float kick_rand_factor_r = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_factor_r = this->_internal_kick_rand_factor_r();
  ::uint32_t raw_kick_rand_factor_r;
  memcpy(&raw_kick_rand_factor_r, &tmp_kick_rand_factor_r, sizeof(tmp_kick_rand_factor_r));
  if (raw_kick_rand_factor_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        26, this->_internal_kick_rand_factor_r(), target);
  }

  // float ball_size = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_size = this->_internal_ball_size();
  ::uint32_t raw_ball_size;
  memcpy(&raw_ball_size, &tmp_ball_size, sizeof(tmp_ball_size));
  if (raw_ball_size != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        27, this->_internal_ball_size(), target);
  }

  // float ball_decay = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_decay = this->_internal_ball_decay();
  ::uint32_t raw_ball_decay;
  memcpy(&raw_ball_decay, &tmp_ball_decay, sizeof(tmp_ball_decay));
  if (raw_ball_decay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        28, this->_internal_ball_decay(), target);
  }

  // float ball_rand = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_rand = this->_internal_ball_rand();
  ::uint32_t raw_ball_rand;
  memcpy(&raw_ball_rand, &tmp_ball_rand, sizeof(tmp_ball_rand));
  if (raw_ball_rand != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        29, this->_internal_ball_rand(), target);
  }

  // float ball_weight = 30;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_weight = this->_internal_ball_weight();
  ::uint32_t raw_ball_weight;
  memcpy(&raw_ball_weight, &tmp_ball_weight, sizeof(tmp_ball_weight));
  if (raw_ball_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        30, this->_internal_ball_weight(), target);
  }

  // float ball_speed_max = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_speed_max = this->_internal_ball_speed_max();
  ::uint32_t raw_ball_speed_max;
  memcpy(&raw_ball_speed_max, &tmp_ball_speed_max, sizeof(tmp_ball_speed_max));
  if (raw_ball_speed_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        31, this->_internal_ball_speed_max(), target);
  }

  // float ball_accel_max = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_accel_max = this->_internal_ball_accel_max();
  ::uint32_t raw_ball_accel_max;
  memcpy(&raw_ball_accel_max, &tmp_ball_accel_max, sizeof(tmp_ball_accel_max));
  if (raw_ball_accel_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        32, this->_internal_ball_accel_max(), target);
  }

  // float dash_power_rate = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate = this->_internal_dash_power_rate();
  ::uint32_t raw_dash_power_rate;
  memcpy(&raw_dash_power_rate, &tmp_dash_power_rate, sizeof(tmp_dash_power_rate));
  if (raw_dash_power_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        33, this->_internal_dash_power_rate(), target);
  }

  // float kick_power_rate = 34;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate = this->_internal_kick_power_rate();
  ::uint32_t raw_kick_power_rate;
  memcpy(&raw_kick_power_rate, &tmp_kick_power_rate, sizeof(tmp_kick_power_rate));
  if (raw_kick_power_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        34, this->_internal_kick_power_rate(), target);
  }

  // float kickable_margin = 35;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin = this->_internal_kickable_margin();
  ::uint32_t raw_kickable_margin;
  memcpy(&raw_kickable_margin, &tmp_kickable_margin, sizeof(tmp_kickable_margin));
  if (raw_kickable_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        35, this->_internal_kickable_margin(), target);
  }

  // float control_radius = 36;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_control_radius = this->_internal_control_radius();
  ::uint32_t raw_control_radius;
  memcpy(&raw_control_radius, &tmp_control_radius, sizeof(tmp_control_radius));
  if (raw_control_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        36, this->_internal_control_radius(), target);
  }

  // float control_radius_width = 37;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_control_radius_width = this->_internal_control_radius_width();
  ::uint32_t raw_control_radius_width;
  memcpy(&raw_control_radius_width, &tmp_control_radius_width, sizeof(tmp_control_radius_width));
  if (raw_control_radius_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        37, this->_internal_control_radius_width(), target);
  }

  // float max_power = 38;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_power = this->_internal_max_power();
  ::uint32_t raw_max_power;
  memcpy(&raw_max_power, &tmp_max_power, sizeof(tmp_max_power));
  if (raw_max_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        38, this->_internal_max_power(), target);
  }

  // float min_power = 39;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_power = this->_internal_min_power();
  ::uint32_t raw_min_power;
  memcpy(&raw_min_power, &tmp_min_power, sizeof(tmp_min_power));
  if (raw_min_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        39, this->_internal_min_power(), target);
  }

  // float max_moment = 40;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_moment = this->_internal_max_moment();
  ::uint32_t raw_max_moment;
  memcpy(&raw_max_moment, &tmp_max_moment, sizeof(tmp_max_moment));
  if (raw_max_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        40, this->_internal_max_moment(), target);
  }

  // float min_moment = 41;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_moment = this->_internal_min_moment();
  ::uint32_t raw_min_moment;
  memcpy(&raw_min_moment, &tmp_min_moment, sizeof(tmp_min_moment));
  if (raw_min_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        41, this->_internal_min_moment(), target);
  }

  // float max_neck_moment = 42;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_neck_moment = this->_internal_max_neck_moment();
  ::uint32_t raw_max_neck_moment;
  memcpy(&raw_max_neck_moment, &tmp_max_neck_moment, sizeof(tmp_max_neck_moment));
  if (raw_max_neck_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        42, this->_internal_max_neck_moment(), target);
  }

  // float min_neck_moment = 43;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_neck_moment = this->_internal_min_neck_moment();
  ::uint32_t raw_min_neck_moment;
  memcpy(&raw_min_neck_moment, &tmp_min_neck_moment, sizeof(tmp_min_neck_moment));
  if (raw_min_neck_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        43, this->_internal_min_neck_moment(), target);
  }

  // float max_neck_angle = 44;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_neck_angle = this->_internal_max_neck_angle();
  ::uint32_t raw_max_neck_angle;
  memcpy(&raw_max_neck_angle, &tmp_max_neck_angle, sizeof(tmp_max_neck_angle));
  if (raw_max_neck_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        44, this->_internal_max_neck_angle(), target);
  }

  // float min_neck_angle = 45;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_neck_angle = this->_internal_min_neck_angle();
  ::uint32_t raw_min_neck_angle;
  memcpy(&raw_min_neck_angle, &tmp_min_neck_angle, sizeof(tmp_min_neck_angle));
  if (raw_min_neck_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        45, this->_internal_min_neck_angle(), target);
  }

  // float visible_angle = 46;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_visible_angle = this->_internal_visible_angle();
  ::uint32_t raw_visible_angle;
  memcpy(&raw_visible_angle, &tmp_visible_angle, sizeof(tmp_visible_angle));
  if (raw_visible_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        46, this->_internal_visible_angle(), target);
  }

  // float visible_distance = 47;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_visible_distance = this->_internal_visible_distance();
  ::uint32_t raw_visible_distance;
  memcpy(&raw_visible_distance, &tmp_visible_distance, sizeof(tmp_visible_distance));
  if (raw_visible_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        47, this->_internal_visible_distance(), target);
  }

  // float wind_dir = 48;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_dir = this->_internal_wind_dir();
  ::uint32_t raw_wind_dir;
  memcpy(&raw_wind_dir, &tmp_wind_dir, sizeof(tmp_wind_dir));
  if (raw_wind_dir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        48, this->_internal_wind_dir(), target);
  }

  // float wind_force = 49;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_force = this->_internal_wind_force();
  ::uint32_t raw_wind_force;
  memcpy(&raw_wind_force, &tmp_wind_force, sizeof(tmp_wind_force));
  if (raw_wind_force != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        49, this->_internal_wind_force(), target);
  }

  // float wind_angle = 50;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_angle = this->_internal_wind_angle();
  ::uint32_t raw_wind_angle;
  memcpy(&raw_wind_angle, &tmp_wind_angle, sizeof(tmp_wind_angle));
  if (raw_wind_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        50, this->_internal_wind_angle(), target);
  }

  // float wind_rand = 51;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_rand = this->_internal_wind_rand();
  ::uint32_t raw_wind_rand;
  memcpy(&raw_wind_rand, &tmp_wind_rand, sizeof(tmp_wind_rand));
  if (raw_wind_rand != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        51, this->_internal_wind_rand(), target);
  }

  // float kickable_area = 52;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_area = this->_internal_kickable_area();
  ::uint32_t raw_kickable_area;
  memcpy(&raw_kickable_area, &tmp_kickable_area, sizeof(tmp_kickable_area));
  if (raw_kickable_area != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        52, this->_internal_kickable_area(), target);
  }

  // float catch_area_l = 53;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_area_l = this->_internal_catch_area_l();
  ::uint32_t raw_catch_area_l;
  memcpy(&raw_catch_area_l, &tmp_catch_area_l, sizeof(tmp_catch_area_l));
  if (raw_catch_area_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        53, this->_internal_catch_area_l(), target);
  }

  // float catch_area_w = 54;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_area_w = this->_internal_catch_area_w();
  ::uint32_t raw_catch_area_w;
  memcpy(&raw_catch_area_w, &tmp_catch_area_w, sizeof(tmp_catch_area_w));
  if (raw_catch_area_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        54, this->_internal_catch_area_w(), target);
  }

  // float catch_probability = 55;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        55, this->_internal_catch_probability(), target);
  }

  // int32 goalie_max_moves = 56;
  if (this->_internal_goalie_max_moves() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        56, this->_internal_goalie_max_moves(), target);
  }

  // float corner_kick_margin = 57;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_corner_kick_margin = this->_internal_corner_kick_margin();
  ::uint32_t raw_corner_kick_margin;
  memcpy(&raw_corner_kick_margin, &tmp_corner_kick_margin, sizeof(tmp_corner_kick_margin));
  if (raw_corner_kick_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        57, this->_internal_corner_kick_margin(), target);
  }

  // float offside_active_area_size = 58;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_active_area_size = this->_internal_offside_active_area_size();
  ::uint32_t raw_offside_active_area_size;
  memcpy(&raw_offside_active_area_size, &tmp_offside_active_area_size, sizeof(tmp_offside_active_area_size));
  if (raw_offside_active_area_size != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        58, this->_internal_offside_active_area_size(), target);
  }

  // bool wind_none = 59;
  if (this->_internal_wind_none() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        59, this->_internal_wind_none(), target);
  }

  // bool use_wind_random = 60;
  if (this->_internal_use_wind_random() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        60, this->_internal_use_wind_random(), target);
  }

  // int32 coach_say_count_max = 61;
  if (this->_internal_coach_say_count_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        61, this->_internal_coach_say_count_max(), target);
  }

  // int32 coach_say_msg_size = 62;
  if (this->_internal_coach_say_msg_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        62, this->_internal_coach_say_msg_size(), target);
  }

  // int32 clang_win_size = 63;
  if (this->_internal_clang_win_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        63, this->_internal_clang_win_size(), target);
  }

  // int32 clang_define_win = 64;
  if (this->_internal_clang_define_win() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        64, this->_internal_clang_define_win(), target);
  }

  // int32 clang_meta_win = 65;
  if (this->_internal_clang_meta_win() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        65, this->_internal_clang_meta_win(), target);
  }

  // int32 clang_advice_win = 66;
  if (this->_internal_clang_advice_win() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        66, this->_internal_clang_advice_win(), target);
  }

  // int32 clang_info_win = 67;
  if (this->_internal_clang_info_win() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        67, this->_internal_clang_info_win(), target);
  }

  // int32 clang_mess_delay = 68;
  if (this->_internal_clang_mess_delay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        68, this->_internal_clang_mess_delay(), target);
  }

  // int32 clang_mess_per_cycle = 69;
  if (this->_internal_clang_mess_per_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        69, this->_internal_clang_mess_per_cycle(), target);
  }

  // int32 half_time = 70;
  if (this->_internal_half_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        70, this->_internal_half_time(), target);
  }

  // int32 simulator_step = 71;
  if (this->_internal_simulator_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        71, this->_internal_simulator_step(), target);
  }

  // int32 send_step = 72;
  if (this->_internal_send_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        72, this->_internal_send_step(), target);
  }

  // int32 recv_step = 73;
  if (this->_internal_recv_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        73, this->_internal_recv_step(), target);
  }

  // int32 sense_body_step = 74;
  if (this->_internal_sense_body_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        74, this->_internal_sense_body_step(), target);
  }

  // int32 lcm_step = 75;
  if (this->_internal_lcm_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        75, this->_internal_lcm_step(), target);
  }

  // int32 player_say_msg_size = 76;
  if (this->_internal_player_say_msg_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        76, this->_internal_player_say_msg_size(), target);
  }

  // int32 player_hear_max = 77;
  if (this->_internal_player_hear_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        77, this->_internal_player_hear_max(), target);
  }

  // int32 player_hear_inc = 78;
  if (this->_internal_player_hear_inc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        78, this->_internal_player_hear_inc(), target);
  }

  // int32 player_hear_decay = 79;
  if (this->_internal_player_hear_decay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        79, this->_internal_player_hear_decay(), target);
  }

  // int32 catch_ban_cycle = 80;
  if (this->_internal_catch_ban_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        80, this->_internal_catch_ban_cycle(), target);
  }

  // int32 slow_down_factor = 81;
  if (this->_internal_slow_down_factor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        81, this->_internal_slow_down_factor(), target);
  }

  // bool use_offside = 82;
  if (this->_internal_use_offside() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        82, this->_internal_use_offside(), target);
  }

  // bool kickoff_offside = 83;
  if (this->_internal_kickoff_offside() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        83, this->_internal_kickoff_offside(), target);
  }

  // float offside_kick_margin = 84;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_kick_margin = this->_internal_offside_kick_margin();
  ::uint32_t raw_offside_kick_margin;
  memcpy(&raw_offside_kick_margin, &tmp_offside_kick_margin, sizeof(tmp_offside_kick_margin));
  if (raw_offside_kick_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        84, this->_internal_offside_kick_margin(), target);
  }

  // float audio_cut_dist = 85;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_audio_cut_dist = this->_internal_audio_cut_dist();
  ::uint32_t raw_audio_cut_dist;
  memcpy(&raw_audio_cut_dist, &tmp_audio_cut_dist, sizeof(tmp_audio_cut_dist));
  if (raw_audio_cut_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        85, this->_internal_audio_cut_dist(), target);
  }

  // float dist_quantize_step = 86;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step = this->_internal_dist_quantize_step();
  ::uint32_t raw_dist_quantize_step;
  memcpy(&raw_dist_quantize_step, &tmp_dist_quantize_step, sizeof(tmp_dist_quantize_step));
  if (raw_dist_quantize_step != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        86, this->_internal_dist_quantize_step(), target);
  }

  // float landmark_dist_quantize_step = 87;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step = this->_internal_landmark_dist_quantize_step();
  ::uint32_t raw_landmark_dist_quantize_step;
  memcpy(&raw_landmark_dist_quantize_step, &tmp_landmark_dist_quantize_step, sizeof(tmp_landmark_dist_quantize_step));
  if (raw_landmark_dist_quantize_step != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        87, this->_internal_landmark_dist_quantize_step(), target);
  }

  // float dir_quantize_step = 88;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step = this->_internal_dir_quantize_step();
  ::uint32_t raw_dir_quantize_step;
  memcpy(&raw_dir_quantize_step, &tmp_dir_quantize_step, sizeof(tmp_dir_quantize_step));
  if (raw_dir_quantize_step != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        88, this->_internal_dir_quantize_step(), target);
  }

  // float dist_quantize_step_l = 89;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step_l = this->_internal_dist_quantize_step_l();
  ::uint32_t raw_dist_quantize_step_l;
  memcpy(&raw_dist_quantize_step_l, &tmp_dist_quantize_step_l, sizeof(tmp_dist_quantize_step_l));
  if (raw_dist_quantize_step_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        89, this->_internal_dist_quantize_step_l(), target);
  }

  // float dist_quantize_step_r = 90;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step_r = this->_internal_dist_quantize_step_r();
  ::uint32_t raw_dist_quantize_step_r;
  memcpy(&raw_dist_quantize_step_r, &tmp_dist_quantize_step_r, sizeof(tmp_dist_quantize_step_r));
  if (raw_dist_quantize_step_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        90, this->_internal_dist_quantize_step_r(), target);
  }

  // float landmark_dist_quantize_step_l = 91;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step_l = this->_internal_landmark_dist_quantize_step_l();
  ::uint32_t raw_landmark_dist_quantize_step_l;
  memcpy(&raw_landmark_dist_quantize_step_l, &tmp_landmark_dist_quantize_step_l, sizeof(tmp_landmark_dist_quantize_step_l));
  if (raw_landmark_dist_quantize_step_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        91, this->_internal_landmark_dist_quantize_step_l(), target);
  }

  // float landmark_dist_quantize_step_r = 92;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step_r = this->_internal_landmark_dist_quantize_step_r();
  ::uint32_t raw_landmark_dist_quantize_step_r;
  memcpy(&raw_landmark_dist_quantize_step_r, &tmp_landmark_dist_quantize_step_r, sizeof(tmp_landmark_dist_quantize_step_r));
  if (raw_landmark_dist_quantize_step_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        92, this->_internal_landmark_dist_quantize_step_r(), target);
  }

  // float dir_quantize_step_l = 93;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step_l = this->_internal_dir_quantize_step_l();
  ::uint32_t raw_dir_quantize_step_l;
  memcpy(&raw_dir_quantize_step_l, &tmp_dir_quantize_step_l, sizeof(tmp_dir_quantize_step_l));
  if (raw_dir_quantize_step_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        93, this->_internal_dir_quantize_step_l(), target);
  }

  // float dir_quantize_step_r = 94;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step_r = this->_internal_dir_quantize_step_r();
  ::uint32_t raw_dir_quantize_step_r;
  memcpy(&raw_dir_quantize_step_r, &tmp_dir_quantize_step_r, sizeof(tmp_dir_quantize_step_r));
  if (raw_dir_quantize_step_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        94, this->_internal_dir_quantize_step_r(), target);
  }

  // bool coach_mode = 95;
  if (this->_internal_coach_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        95, this->_internal_coach_mode(), target);
  }

  // bool coach_with_referee_mode = 96;
  if (this->_internal_coach_with_referee_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        96, this->_internal_coach_with_referee_mode(), target);
  }

  // bool use_old_coach_hear = 97;
  if (this->_internal_use_old_coach_hear() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        97, this->_internal_use_old_coach_hear(), target);
  }

  // float slowness_on_top_for_left_team = 98;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slowness_on_top_for_left_team = this->_internal_slowness_on_top_for_left_team();
  ::uint32_t raw_slowness_on_top_for_left_team;
  memcpy(&raw_slowness_on_top_for_left_team, &tmp_slowness_on_top_for_left_team, sizeof(tmp_slowness_on_top_for_left_team));
  if (raw_slowness_on_top_for_left_team != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        98, this->_internal_slowness_on_top_for_left_team(), target);
  }

  // float slowness_on_top_for_right_team = 99;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slowness_on_top_for_right_team = this->_internal_slowness_on_top_for_right_team();
  ::uint32_t raw_slowness_on_top_for_right_team;
  memcpy(&raw_slowness_on_top_for_right_team, &tmp_slowness_on_top_for_right_team, sizeof(tmp_slowness_on_top_for_right_team));
  if (raw_slowness_on_top_for_right_team != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        99, this->_internal_slowness_on_top_for_right_team(), target);
  }

  // int32 start_goal_l = 100;
  if (this->_internal_start_goal_l() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        100, this->_internal_start_goal_l(), target);
  }

  // int32 start_goal_r = 101;
  if (this->_internal_start_goal_r() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        101, this->_internal_start_goal_r(), target);
  }

  // bool fullstate_l = 102;
  if (this->_internal_fullstate_l() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        102, this->_internal_fullstate_l(), target);
  }

  // bool fullstate_r = 103;
  if (this->_internal_fullstate_r() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        103, this->_internal_fullstate_r(), target);
  }

  // int32 drop_ball_time = 104;
  if (this->_internal_drop_ball_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        104, this->_internal_drop_ball_time(), target);
  }

  // bool synch_mode = 105;
  if (this->_internal_synch_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        105, this->_internal_synch_mode(), target);
  }

  // int32 synch_offset = 106;
  if (this->_internal_synch_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        106, this->_internal_synch_offset(), target);
  }

  // int32 synch_micro_sleep = 107;
  if (this->_internal_synch_micro_sleep() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        107, this->_internal_synch_micro_sleep(), target);
  }

  // int32 point_to_ban = 108;
  if (this->_internal_point_to_ban() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        108, this->_internal_point_to_ban(), target);
  }

  // int32 point_to_duration = 109;
  if (this->_internal_point_to_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        109, this->_internal_point_to_duration(), target);
  }

  // int32 player_port = 110;
  if (this->_internal_player_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        110, this->_internal_player_port(), target);
  }

  // int32 trainer_port = 111;
  if (this->_internal_trainer_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        111, this->_internal_trainer_port(), target);
  }

  // int32 online_coach_port = 112;
  if (this->_internal_online_coach_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        112, this->_internal_online_coach_port(), target);
  }

  // bool verbose_mode = 113;
  if (this->_internal_verbose_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        113, this->_internal_verbose_mode(), target);
  }

  // int32 coach_send_vi_step = 114;
  if (this->_internal_coach_send_vi_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        114, this->_internal_coach_send_vi_step(), target);
  }

  // string replay_file = 115;
  if (!this->_internal_replay_file().empty()) {
    const std::string& _s = this->_internal_replay_file();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.replay_file");
    target = stream->WriteStringMaybeAliased(115, _s, target);
  }

  // string landmark_file = 116;
  if (!this->_internal_landmark_file().empty()) {
    const std::string& _s = this->_internal_landmark_file();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.landmark_file");
    target = stream->WriteStringMaybeAliased(116, _s, target);
  }

  // bool send_comms = 117;
  if (this->_internal_send_comms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        117, this->_internal_send_comms(), target);
  }

  // bool text_logging = 118;
  if (this->_internal_text_logging() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        118, this->_internal_text_logging(), target);
  }

  // bool game_logging = 119;
  if (this->_internal_game_logging() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        119, this->_internal_game_logging(), target);
  }

  // int32 game_log_version = 120;
  if (this->_internal_game_log_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        120, this->_internal_game_log_version(), target);
  }

  // string text_log_dir = 121;
  if (!this->_internal_text_log_dir().empty()) {
    const std::string& _s = this->_internal_text_log_dir();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.text_log_dir");
    target = stream->WriteStringMaybeAliased(121, _s, target);
  }

  // string game_log_dir = 122;
  if (!this->_internal_game_log_dir().empty()) {
    const std::string& _s = this->_internal_game_log_dir();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.game_log_dir");
    target = stream->WriteStringMaybeAliased(122, _s, target);
  }

  // string text_log_fixed_name = 123;
  if (!this->_internal_text_log_fixed_name().empty()) {
    const std::string& _s = this->_internal_text_log_fixed_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.text_log_fixed_name");
    target = stream->WriteStringMaybeAliased(123, _s, target);
  }

  // string game_log_fixed_name = 124;
  if (!this->_internal_game_log_fixed_name().empty()) {
    const std::string& _s = this->_internal_game_log_fixed_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.game_log_fixed_name");
    target = stream->WriteStringMaybeAliased(124, _s, target);
  }

  // bool use_text_log_fixed = 125;
  if (this->_internal_use_text_log_fixed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        125, this->_internal_use_text_log_fixed(), target);
  }

  // bool use_game_log_fixed = 126;
  if (this->_internal_use_game_log_fixed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        126, this->_internal_use_game_log_fixed(), target);
  }

  // bool use_text_log_dated = 127;
  if (this->_internal_use_text_log_dated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        127, this->_internal_use_text_log_dated(), target);
  }

  // bool use_game_log_dated = 128;
  if (this->_internal_use_game_log_dated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        128, this->_internal_use_game_log_dated(), target);
  }

  // string log_date_format = 129;
  if (!this->_internal_log_date_format().empty()) {
    const std::string& _s = this->_internal_log_date_format();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.log_date_format");
    target = stream->WriteStringMaybeAliased(129, _s, target);
  }

  // bool log_times = 130;
  if (this->_internal_log_times() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        130, this->_internal_log_times(), target);
  }

  // bool record_message = 131;
  if (this->_internal_record_message() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        131, this->_internal_record_message(), target);
  }

  // int32 text_log_compression = 132;
  if (this->_internal_text_log_compression() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        132, this->_internal_text_log_compression(), target);
  }

  // int32 game_log_compression = 133;
  if (this->_internal_game_log_compression() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        133, this->_internal_game_log_compression(), target);
  }

  // bool use_profile = 134;
  if (this->_internal_use_profile() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        134, this->_internal_use_profile(), target);
  }

  // float tackle_dist = 135;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_dist = this->_internal_tackle_dist();
  ::uint32_t raw_tackle_dist;
  memcpy(&raw_tackle_dist, &tmp_tackle_dist, sizeof(tmp_tackle_dist));
  if (raw_tackle_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        135, this->_internal_tackle_dist(), target);
  }

  // float tackle_back_dist = 136;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_back_dist = this->_internal_tackle_back_dist();
  ::uint32_t raw_tackle_back_dist;
  memcpy(&raw_tackle_back_dist, &tmp_tackle_back_dist, sizeof(tmp_tackle_back_dist));
  if (raw_tackle_back_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        136, this->_internal_tackle_back_dist(), target);
  }

  // float tackle_width = 137;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_width = this->_internal_tackle_width();
  ::uint32_t raw_tackle_width;
  memcpy(&raw_tackle_width, &tmp_tackle_width, sizeof(tmp_tackle_width));
  if (raw_tackle_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        137, this->_internal_tackle_width(), target);
  }

  // float tackle_exponent = 138;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_exponent = this->_internal_tackle_exponent();
  ::uint32_t raw_tackle_exponent;
  memcpy(&raw_tackle_exponent, &tmp_tackle_exponent, sizeof(tmp_tackle_exponent));
  if (raw_tackle_exponent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        138, this->_internal_tackle_exponent(), target);
  }

  // int32 tackle_cycles = 139;
  if (this->_internal_tackle_cycles() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        139, this->_internal_tackle_cycles(), target);
  }

  // float tackle_power_rate = 140;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_power_rate = this->_internal_tackle_power_rate();
  ::uint32_t raw_tackle_power_rate;
  memcpy(&raw_tackle_power_rate, &tmp_tackle_power_rate, sizeof(tmp_tackle_power_rate));
  if (raw_tackle_power_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        140, this->_internal_tackle_power_rate(), target);
  }

  // int32 freeform_wait_period = 141;
  if (this->_internal_freeform_wait_period() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        141, this->_internal_freeform_wait_period(), target);
  }

  // int32 freeform_send_period = 142;
  if (this->_internal_freeform_send_period() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        142, this->_internal_freeform_send_period(), target);
  }

  // bool free_kick_faults = 143;
  if (this->_internal_free_kick_faults() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        143, this->_internal_free_kick_faults(), target);
  }

  // bool back_passes = 144;
  if (this->_internal_back_passes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        144, this->_internal_back_passes(), target);
  }

  // bool proper_goal_kicks = 145;
  if (this->_internal_proper_goal_kicks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        145, this->_internal_proper_goal_kicks(), target);
  }

  // float stopped_ball_vel = 146;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stopped_ball_vel = this->_internal_stopped_ball_vel();
  ::uint32_t raw_stopped_ball_vel;
  memcpy(&raw_stopped_ball_vel, &tmp_stopped_ball_vel, sizeof(tmp_stopped_ball_vel));
  if (raw_stopped_ball_vel != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        146, this->_internal_stopped_ball_vel(), target);
  }

  // int32 max_goal_kicks = 147;
  if (this->_internal_max_goal_kicks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        147, this->_internal_max_goal_kicks(), target);
  }

  // int32 clang_del_win = 148;
  if (this->_internal_clang_del_win() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        148, this->_internal_clang_del_win(), target);
  }

  // int32 clang_rule_win = 149;
  if (this->_internal_clang_rule_win() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        149, this->_internal_clang_rule_win(), target);
  }

  // bool auto_mode = 150;
  if (this->_internal_auto_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        150, this->_internal_auto_mode(), target);
  }

  // int32 kick_off_wait = 151;
  if (this->_internal_kick_off_wait() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        151, this->_internal_kick_off_wait(), target);
  }

  // int32 connect_wait = 152;
  if (this->_internal_connect_wait() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        152, this->_internal_connect_wait(), target);
  }

  // int32 game_over_wait = 153;
  if (this->_internal_game_over_wait() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        153, this->_internal_game_over_wait(), target);
  }

  // string team_l_start = 154;
  if (!this->_internal_team_l_start().empty()) {
    const std::string& _s = this->_internal_team_l_start();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.team_l_start");
    target = stream->WriteStringMaybeAliased(154, _s, target);
  }

  // string team_r_start = 155;
  if (!this->_internal_team_r_start().empty()) {
    const std::string& _s = this->_internal_team_r_start();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.team_r_start");
    target = stream->WriteStringMaybeAliased(155, _s, target);
  }

  // bool keepaway_mode = 156;
  if (this->_internal_keepaway_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        156, this->_internal_keepaway_mode(), target);
  }

  // float keepaway_length = 157;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_keepaway_length = this->_internal_keepaway_length();
  ::uint32_t raw_keepaway_length;
  memcpy(&raw_keepaway_length, &tmp_keepaway_length, sizeof(tmp_keepaway_length));
  if (raw_keepaway_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        157, this->_internal_keepaway_length(), target);
  }

  // float keepaway_width = 158;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_keepaway_width = this->_internal_keepaway_width();
  ::uint32_t raw_keepaway_width;
  memcpy(&raw_keepaway_width, &tmp_keepaway_width, sizeof(tmp_keepaway_width));
  if (raw_keepaway_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        158, this->_internal_keepaway_width(), target);
  }

  // bool keepaway_logging = 159;
  if (this->_internal_keepaway_logging() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        159, this->_internal_keepaway_logging(), target);
  }

  // string keepaway_log_dir = 160;
  if (!this->_internal_keepaway_log_dir().empty()) {
    const std::string& _s = this->_internal_keepaway_log_dir();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.keepaway_log_dir");
    target = stream->WriteStringMaybeAliased(160, _s, target);
  }

  // string keepaway_log_fixed_name = 161;
  if (!this->_internal_keepaway_log_fixed_name().empty()) {
    const std::string& _s = this->_internal_keepaway_log_fixed_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.keepaway_log_fixed_name");
    target = stream->WriteStringMaybeAliased(161, _s, target);
  }

  // bool keepaway_log_fixed = 162;
  if (this->_internal_keepaway_log_fixed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        162, this->_internal_keepaway_log_fixed(), target);
  }

  // bool keepaway_log_dated = 163;
  if (this->_internal_keepaway_log_dated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        163, this->_internal_keepaway_log_dated(), target);
  }

  // int32 keepaway_start = 164;
  if (this->_internal_keepaway_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        164, this->_internal_keepaway_start(), target);
  }

  // int32 nr_normal_halfs = 165;
  if (this->_internal_nr_normal_halfs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        165, this->_internal_nr_normal_halfs(), target);
  }

  // int32 nr_extra_halfs = 166;
  if (this->_internal_nr_extra_halfs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        166, this->_internal_nr_extra_halfs(), target);
  }

  // bool penalty_shoot_outs = 167;
  if (this->_internal_penalty_shoot_outs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        167, this->_internal_penalty_shoot_outs(), target);
  }

  // int32 pen_before_setup_wait = 168;
  if (this->_internal_pen_before_setup_wait() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        168, this->_internal_pen_before_setup_wait(), target);
  }

  // int32 pen_setup_wait = 169;
  if (this->_internal_pen_setup_wait() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        169, this->_internal_pen_setup_wait(), target);
  }

  // int32 pen_ready_wait = 170;
  if (this->_internal_pen_ready_wait() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        170, this->_internal_pen_ready_wait(), target);
  }

  // int32 pen_taken_wait = 171;
  if (this->_internal_pen_taken_wait() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        171, this->_internal_pen_taken_wait(), target);
  }

  // int32 pen_nr_kicks = 172;
  if (this->_internal_pen_nr_kicks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        172, this->_internal_pen_nr_kicks(), target);
  }

  // int32 pen_max_extra_kicks = 173;
  if (this->_internal_pen_max_extra_kicks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        173, this->_internal_pen_max_extra_kicks(), target);
  }

  // float pen_dist_x = 174;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pen_dist_x = this->_internal_pen_dist_x();
  ::uint32_t raw_pen_dist_x;
  memcpy(&raw_pen_dist_x, &tmp_pen_dist_x, sizeof(tmp_pen_dist_x));
  if (raw_pen_dist_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        174, this->_internal_pen_dist_x(), target);
  }

  // bool pen_random_winner = 175;
  if (this->_internal_pen_random_winner() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        175, this->_internal_pen_random_winner(), target);
  }

  // bool pen_allow_mult_kicks = 176;
  if (this->_internal_pen_allow_mult_kicks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        176, this->_internal_pen_allow_mult_kicks(), target);
  }

  // float pen_max_goalie_dist_x = 177;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pen_max_goalie_dist_x = this->_internal_pen_max_goalie_dist_x();
  ::uint32_t raw_pen_max_goalie_dist_x;
  memcpy(&raw_pen_max_goalie_dist_x, &tmp_pen_max_goalie_dist_x, sizeof(tmp_pen_max_goalie_dist_x));
  if (raw_pen_max_goalie_dist_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        177, this->_internal_pen_max_goalie_dist_x(), target);
  }

  // bool pen_coach_moves_players = 178;
  if (this->_internal_pen_coach_moves_players() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        178, this->_internal_pen_coach_moves_players(), target);
  }

  // string module_dir = 179;
  if (!this->_internal_module_dir().empty()) {
    const std::string& _s = this->_internal_module_dir();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.module_dir");
    target = stream->WriteStringMaybeAliased(179, _s, target);
  }

  // float ball_stuck_area = 180;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_stuck_area = this->_internal_ball_stuck_area();
  ::uint32_t raw_ball_stuck_area;
  memcpy(&raw_ball_stuck_area, &tmp_ball_stuck_area, sizeof(tmp_ball_stuck_area));
  if (raw_ball_stuck_area != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        180, this->_internal_ball_stuck_area(), target);
  }

  // string coach_msg_file = 181;
  if (!this->_internal_coach_msg_file().empty()) {
    const std::string& _s = this->_internal_coach_msg_file();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.coach_msg_file");
    target = stream->WriteStringMaybeAliased(181, _s, target);
  }

  // float max_tackle_power = 182;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_tackle_power = this->_internal_max_tackle_power();
  ::uint32_t raw_max_tackle_power;
  memcpy(&raw_max_tackle_power, &tmp_max_tackle_power, sizeof(tmp_max_tackle_power));
  if (raw_max_tackle_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        182, this->_internal_max_tackle_power(), target);
  }

  // float max_back_tackle_power = 183;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_back_tackle_power = this->_internal_max_back_tackle_power();
  ::uint32_t raw_max_back_tackle_power;
  memcpy(&raw_max_back_tackle_power, &tmp_max_back_tackle_power, sizeof(tmp_max_back_tackle_power));
  if (raw_max_back_tackle_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        183, this->_internal_max_back_tackle_power(), target);
  }

  // float player_speed_max_min = 184;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_min = this->_internal_player_speed_max_min();
  ::uint32_t raw_player_speed_max_min;
  memcpy(&raw_player_speed_max_min, &tmp_player_speed_max_min, sizeof(tmp_player_speed_max_min));
  if (raw_player_speed_max_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        184, this->_internal_player_speed_max_min(), target);
  }

  // float extra_stamina = 185;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina = this->_internal_extra_stamina();
  ::uint32_t raw_extra_stamina;
  memcpy(&raw_extra_stamina, &tmp_extra_stamina, sizeof(tmp_extra_stamina));
  if (raw_extra_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        185, this->_internal_extra_stamina(), target);
  }

  // int32 synch_see_offset = 186;
  if (this->_internal_synch_see_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        186, this->_internal_synch_see_offset(), target);
  }

  // int32 extra_half_time = 187;
  if (this->_internal_extra_half_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        187, this->_internal_extra_half_time(), target);
  }

  // float stamina_capacity = 188;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = this->_internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        188, this->_internal_stamina_capacity(), target);
  }

  // float max_dash_angle = 189;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_angle = this->_internal_max_dash_angle();
  ::uint32_t raw_max_dash_angle;
  memcpy(&raw_max_dash_angle, &tmp_max_dash_angle, sizeof(tmp_max_dash_angle));
  if (raw_max_dash_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        189, this->_internal_max_dash_angle(), target);
  }

  // float min_dash_angle = 190;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_dash_angle = this->_internal_min_dash_angle();
  ::uint32_t raw_min_dash_angle;
  memcpy(&raw_min_dash_angle, &tmp_min_dash_angle, sizeof(tmp_min_dash_angle));
  if (raw_min_dash_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        190, this->_internal_min_dash_angle(), target);
  }

  // float dash_angle_step = 191;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_angle_step = this->_internal_dash_angle_step();
  ::uint32_t raw_dash_angle_step;
  memcpy(&raw_dash_angle_step, &tmp_dash_angle_step, sizeof(tmp_dash_angle_step));
  if (raw_dash_angle_step != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        191, this->_internal_dash_angle_step(), target);
  }

  // float side_dash_rate = 192;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_side_dash_rate = this->_internal_side_dash_rate();
  ::uint32_t raw_side_dash_rate;
  memcpy(&raw_side_dash_rate, &tmp_side_dash_rate, sizeof(tmp_side_dash_rate));
  if (raw_side_dash_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        192, this->_internal_side_dash_rate(), target);
  }

  // float back_dash_rate = 193;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_back_dash_rate = this->_internal_back_dash_rate();
  ::uint32_t raw_back_dash_rate;
  memcpy(&raw_back_dash_rate, &tmp_back_dash_rate, sizeof(tmp_back_dash_rate));
  if (raw_back_dash_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        193, this->_internal_back_dash_rate(), target);
  }

  // float max_dash_power = 194;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = this->_internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        194, this->_internal_max_dash_power(), target);
  }

  // float min_dash_power = 195;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_dash_power = this->_internal_min_dash_power();
  ::uint32_t raw_min_dash_power;
  memcpy(&raw_min_dash_power, &tmp_min_dash_power, sizeof(tmp_min_dash_power));
  if (raw_min_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        195, this->_internal_min_dash_power(), target);
  }

  // float tackle_rand_factor = 196;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_rand_factor = this->_internal_tackle_rand_factor();
  ::uint32_t raw_tackle_rand_factor;
  memcpy(&raw_tackle_rand_factor, &tmp_tackle_rand_factor, sizeof(tmp_tackle_rand_factor));
  if (raw_tackle_rand_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        196, this->_internal_tackle_rand_factor(), target);
  }

  // float foul_detect_probability = 197;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability = this->_internal_foul_detect_probability();
  ::uint32_t raw_foul_detect_probability;
  memcpy(&raw_foul_detect_probability, &tmp_foul_detect_probability, sizeof(tmp_foul_detect_probability));
  if (raw_foul_detect_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        197, this->_internal_foul_detect_probability(), target);
  }

  // float foul_exponent = 198;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_exponent = this->_internal_foul_exponent();
  ::uint32_t raw_foul_exponent;
  memcpy(&raw_foul_exponent, &tmp_foul_exponent, sizeof(tmp_foul_exponent));
  if (raw_foul_exponent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        198, this->_internal_foul_exponent(), target);
  }

  // int32 foul_cycles = 199;
  if (this->_internal_foul_cycles() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        199, this->_internal_foul_cycles(), target);
  }

  // bool golden_goal = 200;
  if (this->_internal_golden_goal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        200, this->_internal_golden_goal(), target);
  }

  // float red_card_probability = 201;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_red_card_probability = this->_internal_red_card_probability();
  ::uint32_t raw_red_card_probability;
  memcpy(&raw_red_card_probability, &tmp_red_card_probability, sizeof(tmp_red_card_probability));
  if (raw_red_card_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        201, this->_internal_red_card_probability(), target);
  }

  // int32 illegal_defense_duration = 202;
  if (this->_internal_illegal_defense_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        202, this->_internal_illegal_defense_duration(), target);
  }

  // int32 illegal_defense_number = 203;
  if (this->_internal_illegal_defense_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        203, this->_internal_illegal_defense_number(), target);
  }

  // float illegal_defense_dist_x = 204;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_illegal_defense_dist_x = this->_internal_illegal_defense_dist_x();
  ::uint32_t raw_illegal_defense_dist_x;
  memcpy(&raw_illegal_defense_dist_x, &tmp_illegal_defense_dist_x, sizeof(tmp_illegal_defense_dist_x));
  if (raw_illegal_defense_dist_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        204, this->_internal_illegal_defense_dist_x(), target);
  }

  // float illegal_defense_width = 205;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_illegal_defense_width = this->_internal_illegal_defense_width();
  ::uint32_t raw_illegal_defense_width;
  memcpy(&raw_illegal_defense_width, &tmp_illegal_defense_width, sizeof(tmp_illegal_defense_width));
  if (raw_illegal_defense_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        205, this->_internal_illegal_defense_width(), target);
  }

  // string fixed_teamname_l = 206;
  if (!this->_internal_fixed_teamname_l().empty()) {
    const std::string& _s = this->_internal_fixed_teamname_l();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.fixed_teamname_l");
    target = stream->WriteStringMaybeAliased(206, _s, target);
  }

  // string fixed_teamname_r = 207;
  if (!this->_internal_fixed_teamname_r().empty()) {
    const std::string& _s = this->_internal_fixed_teamname_r();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.ServerParam.fixed_teamname_r");
    target = stream->WriteStringMaybeAliased(207, _s, target);
  }

  // float max_catch_angle = 208;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_catch_angle = this->_internal_max_catch_angle();
  ::uint32_t raw_max_catch_angle;
  memcpy(&raw_max_catch_angle, &tmp_max_catch_angle, sizeof(tmp_max_catch_angle));
  if (raw_max_catch_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        208, this->_internal_max_catch_angle(), target);
  }

  // float min_catch_angle = 209;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_catch_angle = this->_internal_min_catch_angle();
  ::uint32_t raw_min_catch_angle;
  memcpy(&raw_min_catch_angle, &tmp_min_catch_angle, sizeof(tmp_min_catch_angle));
  if (raw_min_catch_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        209, this->_internal_min_catch_angle(), target);
  }

  // int32 random_seed = 210;
  if (this->_internal_random_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        210, this->_internal_random_seed(), target);
  }

  // float long_kick_power_factor = 211;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_long_kick_power_factor = this->_internal_long_kick_power_factor();
  ::uint32_t raw_long_kick_power_factor;
  memcpy(&raw_long_kick_power_factor, &tmp_long_kick_power_factor, sizeof(tmp_long_kick_power_factor));
  if (raw_long_kick_power_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        211, this->_internal_long_kick_power_factor(), target);
  }

  // int32 long_kick_delay = 212;
  if (this->_internal_long_kick_delay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        212, this->_internal_long_kick_delay(), target);
  }

  // int32 max_monitors = 213;
  if (this->_internal_max_monitors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        213, this->_internal_max_monitors(), target);
  }

  // float catchable_area = 214;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area = this->_internal_catchable_area();
  ::uint32_t raw_catchable_area;
  memcpy(&raw_catchable_area, &tmp_catchable_area, sizeof(tmp_catchable_area));
  if (raw_catchable_area != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        214, this->_internal_catchable_area(), target);
  }

  // float real_speed_max = 215;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max = this->_internal_real_speed_max();
  ::uint32_t raw_real_speed_max;
  memcpy(&raw_real_speed_max, &tmp_real_speed_max, sizeof(tmp_real_speed_max));
  if (raw_real_speed_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        215, this->_internal_real_speed_max(), target);
  }

  // float pitch_half_length = 216;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pitch_half_length = this->_internal_pitch_half_length();
  ::uint32_t raw_pitch_half_length;
  memcpy(&raw_pitch_half_length, &tmp_pitch_half_length, sizeof(tmp_pitch_half_length));
  if (raw_pitch_half_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        216, this->_internal_pitch_half_length(), target);
  }

  // float pitch_half_width = 217;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pitch_half_width = this->_internal_pitch_half_width();
  ::uint32_t raw_pitch_half_width;
  memcpy(&raw_pitch_half_width, &tmp_pitch_half_width, sizeof(tmp_pitch_half_width));
  if (raw_pitch_half_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        217, this->_internal_pitch_half_width(), target);
  }

  // float our_penalty_area_line_x = 218;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_our_penalty_area_line_x = this->_internal_our_penalty_area_line_x();
  ::uint32_t raw_our_penalty_area_line_x;
  memcpy(&raw_our_penalty_area_line_x, &tmp_our_penalty_area_line_x, sizeof(tmp_our_penalty_area_line_x));
  if (raw_our_penalty_area_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        218, this->_internal_our_penalty_area_line_x(), target);
  }

  // float their_penalty_area_line_x = 219;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_their_penalty_area_line_x = this->_internal_their_penalty_area_line_x();
  ::uint32_t raw_their_penalty_area_line_x;
  memcpy(&raw_their_penalty_area_line_x, &tmp_their_penalty_area_line_x, sizeof(tmp_their_penalty_area_line_x));
  if (raw_their_penalty_area_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        219, this->_internal_their_penalty_area_line_x(), target);
  }

  // float penalty_area_half_width = 220;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_penalty_area_half_width = this->_internal_penalty_area_half_width();
  ::uint32_t raw_penalty_area_half_width;
  memcpy(&raw_penalty_area_half_width, &tmp_penalty_area_half_width, sizeof(tmp_penalty_area_half_width));
  if (raw_penalty_area_half_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        220, this->_internal_penalty_area_half_width(), target);
  }

  // float penalty_area_length = 221;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_penalty_area_length = this->_internal_penalty_area_length();
  ::uint32_t raw_penalty_area_length;
  memcpy(&raw_penalty_area_length, &tmp_penalty_area_length, sizeof(tmp_penalty_area_length));
  if (raw_penalty_area_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        221, this->_internal_penalty_area_length(), target);
  }

  // float goal_width = 222;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goal_width = this->_internal_goal_width();
  ::uint32_t raw_goal_width;
  memcpy(&raw_goal_width, &tmp_goal_width, sizeof(tmp_goal_width));
  if (raw_goal_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        222, this->_internal_goal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.ServerParam)
  return target;
}

::size_t ServerParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.ServerParam)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string replay_file = 115;
  if (!this->_internal_replay_file().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_replay_file());
  }

  // string landmark_file = 116;
  if (!this->_internal_landmark_file().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_landmark_file());
  }

  // string text_log_dir = 121;
  if (!this->_internal_text_log_dir().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_text_log_dir());
  }

  // string game_log_dir = 122;
  if (!this->_internal_game_log_dir().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_game_log_dir());
  }

  // string text_log_fixed_name = 123;
  if (!this->_internal_text_log_fixed_name().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_text_log_fixed_name());
  }

  // string game_log_fixed_name = 124;
  if (!this->_internal_game_log_fixed_name().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_game_log_fixed_name());
  }

  // string log_date_format = 129;
  if (!this->_internal_log_date_format().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_log_date_format());
  }

  // string team_l_start = 154;
  if (!this->_internal_team_l_start().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_team_l_start());
  }

  // string team_r_start = 155;
  if (!this->_internal_team_r_start().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_team_r_start());
  }

  // string keepaway_log_dir = 160;
  if (!this->_internal_keepaway_log_dir().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_keepaway_log_dir());
  }

  // string keepaway_log_fixed_name = 161;
  if (!this->_internal_keepaway_log_fixed_name().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_keepaway_log_fixed_name());
  }

  // string module_dir = 179;
  if (!this->_internal_module_dir().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_module_dir());
  }

  // string coach_msg_file = 181;
  if (!this->_internal_coach_msg_file().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_coach_msg_file());
  }

  // string fixed_teamname_l = 206;
  if (!this->_internal_fixed_teamname_l().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fixed_teamname_l());
  }

  // string fixed_teamname_r = 207;
  if (!this->_internal_fixed_teamname_r().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fixed_teamname_r());
  }

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_agent_type());
  }

  // float inertia_moment = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment = this->_internal_inertia_moment();
  ::uint32_t raw_inertia_moment;
  memcpy(&raw_inertia_moment, &tmp_inertia_moment, sizeof(tmp_inertia_moment));
  if (raw_inertia_moment != 0) {
    total_size += 5;
  }

  // float player_size = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size = this->_internal_player_size();
  ::uint32_t raw_player_size;
  memcpy(&raw_player_size, &tmp_player_size, sizeof(tmp_player_size));
  if (raw_player_size != 0) {
    total_size += 5;
  }

  // float player_decay = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay = this->_internal_player_decay();
  ::uint32_t raw_player_decay;
  memcpy(&raw_player_decay, &tmp_player_decay, sizeof(tmp_player_decay));
  if (raw_player_decay != 0) {
    total_size += 5;
  }

  // float player_rand = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand = this->_internal_player_rand();
  ::uint32_t raw_player_rand;
  memcpy(&raw_player_rand, &tmp_player_rand, sizeof(tmp_player_rand));
  if (raw_player_rand != 0) {
    total_size += 5;
  }

  // float player_weight = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_weight = this->_internal_player_weight();
  ::uint32_t raw_player_weight;
  memcpy(&raw_player_weight, &tmp_player_weight, sizeof(tmp_player_weight));
  if (raw_player_weight != 0) {
    total_size += 5;
  }

  // float player_speed_max = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max = this->_internal_player_speed_max();
  ::uint32_t raw_player_speed_max;
  memcpy(&raw_player_speed_max, &tmp_player_speed_max, sizeof(tmp_player_speed_max));
  if (raw_player_speed_max != 0) {
    total_size += 5;
  }

  // float player_accel_max = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_accel_max = this->_internal_player_accel_max();
  ::uint32_t raw_player_accel_max;
  memcpy(&raw_player_accel_max, &tmp_player_accel_max, sizeof(tmp_player_accel_max));
  if (raw_player_accel_max != 0) {
    total_size += 5;
  }

  // float stamina_max = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_max = this->_internal_stamina_max();
  ::uint32_t raw_stamina_max;
  memcpy(&raw_stamina_max, &tmp_stamina_max, sizeof(tmp_stamina_max));
  if (raw_stamina_max != 0) {
    total_size += 5;
  }

  // float stamina_inc_max = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max = this->_internal_stamina_inc_max();
  ::uint32_t raw_stamina_inc_max;
  memcpy(&raw_stamina_inc_max, &tmp_stamina_inc_max, sizeof(tmp_stamina_inc_max));
  if (raw_stamina_inc_max != 0) {
    total_size += 5;
  }

  // float recover_init = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_init = this->_internal_recover_init();
  ::uint32_t raw_recover_init;
  memcpy(&raw_recover_init, &tmp_recover_init, sizeof(tmp_recover_init));
  if (raw_recover_init != 0) {
    total_size += 5;
  }

  // float recover_dec_thr = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_dec_thr = this->_internal_recover_dec_thr();
  ::uint32_t raw_recover_dec_thr;
  memcpy(&raw_recover_dec_thr, &tmp_recover_dec_thr, sizeof(tmp_recover_dec_thr));
  if (raw_recover_dec_thr != 0) {
    total_size += 5;
  }

  // float recover_min = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_min = this->_internal_recover_min();
  ::uint32_t raw_recover_min;
  memcpy(&raw_recover_min, &tmp_recover_min, sizeof(tmp_recover_min));
  if (raw_recover_min != 0) {
    total_size += 5;
  }

  // float recover_dec = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_dec = this->_internal_recover_dec();
  ::uint32_t raw_recover_dec;
  memcpy(&raw_recover_dec, &tmp_recover_dec, sizeof(tmp_recover_dec));
  if (raw_recover_dec != 0) {
    total_size += 5;
  }

  // float effort_init = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_init = this->_internal_effort_init();
  ::uint32_t raw_effort_init;
  memcpy(&raw_effort_init, &tmp_effort_init, sizeof(tmp_effort_init));
  if (raw_effort_init != 0) {
    total_size += 5;
  }

  // float effort_dec_thr = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_dec_thr = this->_internal_effort_dec_thr();
  ::uint32_t raw_effort_dec_thr;
  memcpy(&raw_effort_dec_thr, &tmp_effort_dec_thr, sizeof(tmp_effort_dec_thr));
  if (raw_effort_dec_thr != 0) {
    total_size += 6;
  }

  // float effort_min = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min = this->_internal_effort_min();
  ::uint32_t raw_effort_min;
  memcpy(&raw_effort_min, &tmp_effort_min, sizeof(tmp_effort_min));
  if (raw_effort_min != 0) {
    total_size += 6;
  }

  // float effort_dec = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_dec = this->_internal_effort_dec();
  ::uint32_t raw_effort_dec;
  memcpy(&raw_effort_dec, &tmp_effort_dec, sizeof(tmp_effort_dec));
  if (raw_effort_dec != 0) {
    total_size += 6;
  }

  // float effort_inc_thr = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_inc_thr = this->_internal_effort_inc_thr();
  ::uint32_t raw_effort_inc_thr;
  memcpy(&raw_effort_inc_thr, &tmp_effort_inc_thr, sizeof(tmp_effort_inc_thr));
  if (raw_effort_inc_thr != 0) {
    total_size += 6;
  }

  // float effort_inc = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_inc = this->_internal_effort_inc();
  ::uint32_t raw_effort_inc;
  memcpy(&raw_effort_inc, &tmp_effort_inc, sizeof(tmp_effort_inc));
  if (raw_effort_inc != 0) {
    total_size += 6;
  }

  // float kick_rand = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand = this->_internal_kick_rand();
  ::uint32_t raw_kick_rand;
  memcpy(&raw_kick_rand, &tmp_kick_rand, sizeof(tmp_kick_rand));
  if (raw_kick_rand != 0) {
    total_size += 6;
  }

  // float player_rand_factor_l = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand_factor_l = this->_internal_player_rand_factor_l();
  ::uint32_t raw_player_rand_factor_l;
  memcpy(&raw_player_rand_factor_l, &tmp_player_rand_factor_l, sizeof(tmp_player_rand_factor_l));
  if (raw_player_rand_factor_l != 0) {
    total_size += 6;
  }

  // float player_rand_factor_r = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand_factor_r = this->_internal_player_rand_factor_r();
  ::uint32_t raw_player_rand_factor_r;
  memcpy(&raw_player_rand_factor_r, &tmp_player_rand_factor_r, sizeof(tmp_player_rand_factor_r));
  if (raw_player_rand_factor_r != 0) {
    total_size += 6;
  }

  // float kick_rand_factor_l = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_factor_l = this->_internal_kick_rand_factor_l();
  ::uint32_t raw_kick_rand_factor_l;
  memcpy(&raw_kick_rand_factor_l, &tmp_kick_rand_factor_l, sizeof(tmp_kick_rand_factor_l));
  if (raw_kick_rand_factor_l != 0) {
    total_size += 6;
  }

  // float kick_rand_factor_r = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_factor_r = this->_internal_kick_rand_factor_r();
  ::uint32_t raw_kick_rand_factor_r;
  memcpy(&raw_kick_rand_factor_r, &tmp_kick_rand_factor_r, sizeof(tmp_kick_rand_factor_r));
  if (raw_kick_rand_factor_r != 0) {
    total_size += 6;
  }

  // float ball_size = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_size = this->_internal_ball_size();
  ::uint32_t raw_ball_size;
  memcpy(&raw_ball_size, &tmp_ball_size, sizeof(tmp_ball_size));
  if (raw_ball_size != 0) {
    total_size += 6;
  }

  // float ball_decay = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_decay = this->_internal_ball_decay();
  ::uint32_t raw_ball_decay;
  memcpy(&raw_ball_decay, &tmp_ball_decay, sizeof(tmp_ball_decay));
  if (raw_ball_decay != 0) {
    total_size += 6;
  }

  // float ball_rand = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_rand = this->_internal_ball_rand();
  ::uint32_t raw_ball_rand;
  memcpy(&raw_ball_rand, &tmp_ball_rand, sizeof(tmp_ball_rand));
  if (raw_ball_rand != 0) {
    total_size += 6;
  }

  // float ball_weight = 30;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_weight = this->_internal_ball_weight();
  ::uint32_t raw_ball_weight;
  memcpy(&raw_ball_weight, &tmp_ball_weight, sizeof(tmp_ball_weight));
  if (raw_ball_weight != 0) {
    total_size += 6;
  }

  // float ball_speed_max = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_speed_max = this->_internal_ball_speed_max();
  ::uint32_t raw_ball_speed_max;
  memcpy(&raw_ball_speed_max, &tmp_ball_speed_max, sizeof(tmp_ball_speed_max));
  if (raw_ball_speed_max != 0) {
    total_size += 6;
  }

  // float ball_accel_max = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_accel_max = this->_internal_ball_accel_max();
  ::uint32_t raw_ball_accel_max;
  memcpy(&raw_ball_accel_max, &tmp_ball_accel_max, sizeof(tmp_ball_accel_max));
  if (raw_ball_accel_max != 0) {
    total_size += 6;
  }

  // float dash_power_rate = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate = this->_internal_dash_power_rate();
  ::uint32_t raw_dash_power_rate;
  memcpy(&raw_dash_power_rate, &tmp_dash_power_rate, sizeof(tmp_dash_power_rate));
  if (raw_dash_power_rate != 0) {
    total_size += 6;
  }

  // float kick_power_rate = 34;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate = this->_internal_kick_power_rate();
  ::uint32_t raw_kick_power_rate;
  memcpy(&raw_kick_power_rate, &tmp_kick_power_rate, sizeof(tmp_kick_power_rate));
  if (raw_kick_power_rate != 0) {
    total_size += 6;
  }

  // float kickable_margin = 35;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin = this->_internal_kickable_margin();
  ::uint32_t raw_kickable_margin;
  memcpy(&raw_kickable_margin, &tmp_kickable_margin, sizeof(tmp_kickable_margin));
  if (raw_kickable_margin != 0) {
    total_size += 6;
  }

  // float control_radius = 36;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_control_radius = this->_internal_control_radius();
  ::uint32_t raw_control_radius;
  memcpy(&raw_control_radius, &tmp_control_radius, sizeof(tmp_control_radius));
  if (raw_control_radius != 0) {
    total_size += 6;
  }

  // float control_radius_width = 37;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_control_radius_width = this->_internal_control_radius_width();
  ::uint32_t raw_control_radius_width;
  memcpy(&raw_control_radius_width, &tmp_control_radius_width, sizeof(tmp_control_radius_width));
  if (raw_control_radius_width != 0) {
    total_size += 6;
  }

  // float max_power = 38;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_power = this->_internal_max_power();
  ::uint32_t raw_max_power;
  memcpy(&raw_max_power, &tmp_max_power, sizeof(tmp_max_power));
  if (raw_max_power != 0) {
    total_size += 6;
  }

  // float min_power = 39;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_power = this->_internal_min_power();
  ::uint32_t raw_min_power;
  memcpy(&raw_min_power, &tmp_min_power, sizeof(tmp_min_power));
  if (raw_min_power != 0) {
    total_size += 6;
  }

  // float max_moment = 40;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_moment = this->_internal_max_moment();
  ::uint32_t raw_max_moment;
  memcpy(&raw_max_moment, &tmp_max_moment, sizeof(tmp_max_moment));
  if (raw_max_moment != 0) {
    total_size += 6;
  }

  // float min_moment = 41;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_moment = this->_internal_min_moment();
  ::uint32_t raw_min_moment;
  memcpy(&raw_min_moment, &tmp_min_moment, sizeof(tmp_min_moment));
  if (raw_min_moment != 0) {
    total_size += 6;
  }

  // float max_neck_moment = 42;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_neck_moment = this->_internal_max_neck_moment();
  ::uint32_t raw_max_neck_moment;
  memcpy(&raw_max_neck_moment, &tmp_max_neck_moment, sizeof(tmp_max_neck_moment));
  if (raw_max_neck_moment != 0) {
    total_size += 6;
  }

  // float min_neck_moment = 43;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_neck_moment = this->_internal_min_neck_moment();
  ::uint32_t raw_min_neck_moment;
  memcpy(&raw_min_neck_moment, &tmp_min_neck_moment, sizeof(tmp_min_neck_moment));
  if (raw_min_neck_moment != 0) {
    total_size += 6;
  }

  // float max_neck_angle = 44;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_neck_angle = this->_internal_max_neck_angle();
  ::uint32_t raw_max_neck_angle;
  memcpy(&raw_max_neck_angle, &tmp_max_neck_angle, sizeof(tmp_max_neck_angle));
  if (raw_max_neck_angle != 0) {
    total_size += 6;
  }

  // float min_neck_angle = 45;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_neck_angle = this->_internal_min_neck_angle();
  ::uint32_t raw_min_neck_angle;
  memcpy(&raw_min_neck_angle, &tmp_min_neck_angle, sizeof(tmp_min_neck_angle));
  if (raw_min_neck_angle != 0) {
    total_size += 6;
  }

  // float visible_angle = 46;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_visible_angle = this->_internal_visible_angle();
  ::uint32_t raw_visible_angle;
  memcpy(&raw_visible_angle, &tmp_visible_angle, sizeof(tmp_visible_angle));
  if (raw_visible_angle != 0) {
    total_size += 6;
  }

  // float visible_distance = 47;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_visible_distance = this->_internal_visible_distance();
  ::uint32_t raw_visible_distance;
  memcpy(&raw_visible_distance, &tmp_visible_distance, sizeof(tmp_visible_distance));
  if (raw_visible_distance != 0) {
    total_size += 6;
  }

  // float wind_dir = 48;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_dir = this->_internal_wind_dir();
  ::uint32_t raw_wind_dir;
  memcpy(&raw_wind_dir, &tmp_wind_dir, sizeof(tmp_wind_dir));
  if (raw_wind_dir != 0) {
    total_size += 6;
  }

  // float wind_force = 49;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_force = this->_internal_wind_force();
  ::uint32_t raw_wind_force;
  memcpy(&raw_wind_force, &tmp_wind_force, sizeof(tmp_wind_force));
  if (raw_wind_force != 0) {
    total_size += 6;
  }

  // float wind_angle = 50;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_angle = this->_internal_wind_angle();
  ::uint32_t raw_wind_angle;
  memcpy(&raw_wind_angle, &tmp_wind_angle, sizeof(tmp_wind_angle));
  if (raw_wind_angle != 0) {
    total_size += 6;
  }

  // float wind_rand = 51;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_rand = this->_internal_wind_rand();
  ::uint32_t raw_wind_rand;
  memcpy(&raw_wind_rand, &tmp_wind_rand, sizeof(tmp_wind_rand));
  if (raw_wind_rand != 0) {
    total_size += 6;
  }

  // float kickable_area = 52;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_area = this->_internal_kickable_area();
  ::uint32_t raw_kickable_area;
  memcpy(&raw_kickable_area, &tmp_kickable_area, sizeof(tmp_kickable_area));
  if (raw_kickable_area != 0) {
    total_size += 6;
  }

  // float catch_area_l = 53;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_area_l = this->_internal_catch_area_l();
  ::uint32_t raw_catch_area_l;
  memcpy(&raw_catch_area_l, &tmp_catch_area_l, sizeof(tmp_catch_area_l));
  if (raw_catch_area_l != 0) {
    total_size += 6;
  }

  // float catch_area_w = 54;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_area_w = this->_internal_catch_area_w();
  ::uint32_t raw_catch_area_w;
  memcpy(&raw_catch_area_w, &tmp_catch_area_w, sizeof(tmp_catch_area_w));
  if (raw_catch_area_w != 0) {
    total_size += 6;
  }

  // float catch_probability = 55;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    total_size += 6;
  }

  // bool team_actuator_noise = 22;
  if (this->_internal_team_actuator_noise() != 0) {
    total_size += 3;
  }

  // bool wind_none = 59;
  if (this->_internal_wind_none() != 0) {
    total_size += 3;
  }

  // bool use_wind_random = 60;
  if (this->_internal_use_wind_random() != 0) {
    total_size += 3;
  }

  // bool use_offside = 82;
  if (this->_internal_use_offside() != 0) {
    total_size += 3;
  }

  // int32 goalie_max_moves = 56;
  if (this->_internal_goalie_max_moves() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_goalie_max_moves());
  }

  // float corner_kick_margin = 57;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_corner_kick_margin = this->_internal_corner_kick_margin();
  ::uint32_t raw_corner_kick_margin;
  memcpy(&raw_corner_kick_margin, &tmp_corner_kick_margin, sizeof(tmp_corner_kick_margin));
  if (raw_corner_kick_margin != 0) {
    total_size += 6;
  }

  // float offside_active_area_size = 58;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_active_area_size = this->_internal_offside_active_area_size();
  ::uint32_t raw_offside_active_area_size;
  memcpy(&raw_offside_active_area_size, &tmp_offside_active_area_size, sizeof(tmp_offside_active_area_size));
  if (raw_offside_active_area_size != 0) {
    total_size += 6;
  }

  // int32 coach_say_count_max = 61;
  if (this->_internal_coach_say_count_max() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_coach_say_count_max());
  }

  // int32 coach_say_msg_size = 62;
  if (this->_internal_coach_say_msg_size() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_coach_say_msg_size());
  }

  // int32 clang_win_size = 63;
  if (this->_internal_clang_win_size() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_win_size());
  }

  // int32 clang_define_win = 64;
  if (this->_internal_clang_define_win() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_define_win());
  }

  // int32 clang_meta_win = 65;
  if (this->_internal_clang_meta_win() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_meta_win());
  }

  // int32 clang_advice_win = 66;
  if (this->_internal_clang_advice_win() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_advice_win());
  }

  // int32 clang_info_win = 67;
  if (this->_internal_clang_info_win() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_info_win());
  }

  // int32 clang_mess_delay = 68;
  if (this->_internal_clang_mess_delay() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_mess_delay());
  }

  // int32 clang_mess_per_cycle = 69;
  if (this->_internal_clang_mess_per_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_mess_per_cycle());
  }

  // int32 half_time = 70;
  if (this->_internal_half_time() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_half_time());
  }

  // int32 simulator_step = 71;
  if (this->_internal_simulator_step() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_simulator_step());
  }

  // int32 send_step = 72;
  if (this->_internal_send_step() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_send_step());
  }

  // int32 recv_step = 73;
  if (this->_internal_recv_step() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_recv_step());
  }

  // int32 sense_body_step = 74;
  if (this->_internal_sense_body_step() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_sense_body_step());
  }

  // int32 lcm_step = 75;
  if (this->_internal_lcm_step() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_lcm_step());
  }

  // int32 player_say_msg_size = 76;
  if (this->_internal_player_say_msg_size() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_player_say_msg_size());
  }

  // int32 player_hear_max = 77;
  if (this->_internal_player_hear_max() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_player_hear_max());
  }

  // int32 player_hear_inc = 78;
  if (this->_internal_player_hear_inc() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_player_hear_inc());
  }

  // int32 player_hear_decay = 79;
  if (this->_internal_player_hear_decay() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_player_hear_decay());
  }

  // int32 catch_ban_cycle = 80;
  if (this->_internal_catch_ban_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_catch_ban_cycle());
  }

  // int32 slow_down_factor = 81;
  if (this->_internal_slow_down_factor() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_slow_down_factor());
  }

  // float offside_kick_margin = 84;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_kick_margin = this->_internal_offside_kick_margin();
  ::uint32_t raw_offside_kick_margin;
  memcpy(&raw_offside_kick_margin, &tmp_offside_kick_margin, sizeof(tmp_offside_kick_margin));
  if (raw_offside_kick_margin != 0) {
    total_size += 6;
  }

  // float audio_cut_dist = 85;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_audio_cut_dist = this->_internal_audio_cut_dist();
  ::uint32_t raw_audio_cut_dist;
  memcpy(&raw_audio_cut_dist, &tmp_audio_cut_dist, sizeof(tmp_audio_cut_dist));
  if (raw_audio_cut_dist != 0) {
    total_size += 6;
  }

  // float dist_quantize_step = 86;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step = this->_internal_dist_quantize_step();
  ::uint32_t raw_dist_quantize_step;
  memcpy(&raw_dist_quantize_step, &tmp_dist_quantize_step, sizeof(tmp_dist_quantize_step));
  if (raw_dist_quantize_step != 0) {
    total_size += 6;
  }

  // float landmark_dist_quantize_step = 87;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step = this->_internal_landmark_dist_quantize_step();
  ::uint32_t raw_landmark_dist_quantize_step;
  memcpy(&raw_landmark_dist_quantize_step, &tmp_landmark_dist_quantize_step, sizeof(tmp_landmark_dist_quantize_step));
  if (raw_landmark_dist_quantize_step != 0) {
    total_size += 6;
  }

  // float dir_quantize_step = 88;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step = this->_internal_dir_quantize_step();
  ::uint32_t raw_dir_quantize_step;
  memcpy(&raw_dir_quantize_step, &tmp_dir_quantize_step, sizeof(tmp_dir_quantize_step));
  if (raw_dir_quantize_step != 0) {
    total_size += 6;
  }

  // float dist_quantize_step_l = 89;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step_l = this->_internal_dist_quantize_step_l();
  ::uint32_t raw_dist_quantize_step_l;
  memcpy(&raw_dist_quantize_step_l, &tmp_dist_quantize_step_l, sizeof(tmp_dist_quantize_step_l));
  if (raw_dist_quantize_step_l != 0) {
    total_size += 6;
  }

  // float dist_quantize_step_r = 90;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step_r = this->_internal_dist_quantize_step_r();
  ::uint32_t raw_dist_quantize_step_r;
  memcpy(&raw_dist_quantize_step_r, &tmp_dist_quantize_step_r, sizeof(tmp_dist_quantize_step_r));
  if (raw_dist_quantize_step_r != 0) {
    total_size += 6;
  }

  // float landmark_dist_quantize_step_l = 91;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step_l = this->_internal_landmark_dist_quantize_step_l();
  ::uint32_t raw_landmark_dist_quantize_step_l;
  memcpy(&raw_landmark_dist_quantize_step_l, &tmp_landmark_dist_quantize_step_l, sizeof(tmp_landmark_dist_quantize_step_l));
  if (raw_landmark_dist_quantize_step_l != 0) {
    total_size += 6;
  }

  // float landmark_dist_quantize_step_r = 92;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step_r = this->_internal_landmark_dist_quantize_step_r();
  ::uint32_t raw_landmark_dist_quantize_step_r;
  memcpy(&raw_landmark_dist_quantize_step_r, &tmp_landmark_dist_quantize_step_r, sizeof(tmp_landmark_dist_quantize_step_r));
  if (raw_landmark_dist_quantize_step_r != 0) {
    total_size += 6;
  }

  // bool kickoff_offside = 83;
  if (this->_internal_kickoff_offside() != 0) {
    total_size += 3;
  }

  // bool coach_mode = 95;
  if (this->_internal_coach_mode() != 0) {
    total_size += 3;
  }

  // bool coach_with_referee_mode = 96;
  if (this->_internal_coach_with_referee_mode() != 0) {
    total_size += 3;
  }

  // bool use_old_coach_hear = 97;
  if (this->_internal_use_old_coach_hear() != 0) {
    total_size += 3;
  }

  // float dir_quantize_step_l = 93;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step_l = this->_internal_dir_quantize_step_l();
  ::uint32_t raw_dir_quantize_step_l;
  memcpy(&raw_dir_quantize_step_l, &tmp_dir_quantize_step_l, sizeof(tmp_dir_quantize_step_l));
  if (raw_dir_quantize_step_l != 0) {
    total_size += 6;
  }

  // float dir_quantize_step_r = 94;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step_r = this->_internal_dir_quantize_step_r();
  ::uint32_t raw_dir_quantize_step_r;
  memcpy(&raw_dir_quantize_step_r, &tmp_dir_quantize_step_r, sizeof(tmp_dir_quantize_step_r));
  if (raw_dir_quantize_step_r != 0) {
    total_size += 6;
  }

  // float slowness_on_top_for_left_team = 98;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slowness_on_top_for_left_team = this->_internal_slowness_on_top_for_left_team();
  ::uint32_t raw_slowness_on_top_for_left_team;
  memcpy(&raw_slowness_on_top_for_left_team, &tmp_slowness_on_top_for_left_team, sizeof(tmp_slowness_on_top_for_left_team));
  if (raw_slowness_on_top_for_left_team != 0) {
    total_size += 6;
  }

  // float slowness_on_top_for_right_team = 99;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slowness_on_top_for_right_team = this->_internal_slowness_on_top_for_right_team();
  ::uint32_t raw_slowness_on_top_for_right_team;
  memcpy(&raw_slowness_on_top_for_right_team, &tmp_slowness_on_top_for_right_team, sizeof(tmp_slowness_on_top_for_right_team));
  if (raw_slowness_on_top_for_right_team != 0) {
    total_size += 6;
  }

  // int32 start_goal_l = 100;
  if (this->_internal_start_goal_l() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_start_goal_l());
  }

  // int32 start_goal_r = 101;
  if (this->_internal_start_goal_r() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_start_goal_r());
  }

  // int32 drop_ball_time = 104;
  if (this->_internal_drop_ball_time() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_drop_ball_time());
  }

  // bool fullstate_l = 102;
  if (this->_internal_fullstate_l() != 0) {
    total_size += 3;
  }

  // bool fullstate_r = 103;
  if (this->_internal_fullstate_r() != 0) {
    total_size += 3;
  }

  // bool synch_mode = 105;
  if (this->_internal_synch_mode() != 0) {
    total_size += 3;
  }

  // bool verbose_mode = 113;
  if (this->_internal_verbose_mode() != 0) {
    total_size += 3;
  }

  // int32 synch_offset = 106;
  if (this->_internal_synch_offset() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_synch_offset());
  }

  // int32 synch_micro_sleep = 107;
  if (this->_internal_synch_micro_sleep() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_synch_micro_sleep());
  }

  // int32 point_to_ban = 108;
  if (this->_internal_point_to_ban() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_ban());
  }

  // int32 point_to_duration = 109;
  if (this->_internal_point_to_duration() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_duration());
  }

  // int32 player_port = 110;
  if (this->_internal_player_port() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_player_port());
  }

  // int32 trainer_port = 111;
  if (this->_internal_trainer_port() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_trainer_port());
  }

  // int32 online_coach_port = 112;
  if (this->_internal_online_coach_port() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_online_coach_port());
  }

  // int32 coach_send_vi_step = 114;
  if (this->_internal_coach_send_vi_step() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_coach_send_vi_step());
  }

  // bool send_comms = 117;
  if (this->_internal_send_comms() != 0) {
    total_size += 3;
  }

  // bool text_logging = 118;
  if (this->_internal_text_logging() != 0) {
    total_size += 3;
  }

  // bool game_logging = 119;
  if (this->_internal_game_logging() != 0) {
    total_size += 3;
  }

  // bool use_text_log_fixed = 125;
  if (this->_internal_use_text_log_fixed() != 0) {
    total_size += 3;
  }

  // int32 game_log_version = 120;
  if (this->_internal_game_log_version() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_game_log_version());
  }

  // bool use_game_log_fixed = 126;
  if (this->_internal_use_game_log_fixed() != 0) {
    total_size += 3;
  }

  // bool use_text_log_dated = 127;
  if (this->_internal_use_text_log_dated() != 0) {
    total_size += 3;
  }

  // bool use_game_log_dated = 128;
  if (this->_internal_use_game_log_dated() != 0) {
    total_size += 3;
  }

  // bool log_times = 130;
  if (this->_internal_log_times() != 0) {
    total_size += 3;
  }

  // int32 text_log_compression = 132;
  if (this->_internal_text_log_compression() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_text_log_compression());
  }

  // int32 game_log_compression = 133;
  if (this->_internal_game_log_compression() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_game_log_compression());
  }

  // float tackle_dist = 135;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_dist = this->_internal_tackle_dist();
  ::uint32_t raw_tackle_dist;
  memcpy(&raw_tackle_dist, &tmp_tackle_dist, sizeof(tmp_tackle_dist));
  if (raw_tackle_dist != 0) {
    total_size += 6;
  }

  // float tackle_back_dist = 136;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_back_dist = this->_internal_tackle_back_dist();
  ::uint32_t raw_tackle_back_dist;
  memcpy(&raw_tackle_back_dist, &tmp_tackle_back_dist, sizeof(tmp_tackle_back_dist));
  if (raw_tackle_back_dist != 0) {
    total_size += 6;
  }

  // float tackle_width = 137;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_width = this->_internal_tackle_width();
  ::uint32_t raw_tackle_width;
  memcpy(&raw_tackle_width, &tmp_tackle_width, sizeof(tmp_tackle_width));
  if (raw_tackle_width != 0) {
    total_size += 6;
  }

  // float tackle_exponent = 138;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_exponent = this->_internal_tackle_exponent();
  ::uint32_t raw_tackle_exponent;
  memcpy(&raw_tackle_exponent, &tmp_tackle_exponent, sizeof(tmp_tackle_exponent));
  if (raw_tackle_exponent != 0) {
    total_size += 6;
  }

  // bool record_message = 131;
  if (this->_internal_record_message() != 0) {
    total_size += 3;
  }

  // bool use_profile = 134;
  if (this->_internal_use_profile() != 0) {
    total_size += 3;
  }

  // bool free_kick_faults = 143;
  if (this->_internal_free_kick_faults() != 0) {
    total_size += 3;
  }

  // bool back_passes = 144;
  if (this->_internal_back_passes() != 0) {
    total_size += 3;
  }

  // int32 tackle_cycles = 139;
  if (this->_internal_tackle_cycles() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_tackle_cycles());
  }

  // float tackle_power_rate = 140;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_power_rate = this->_internal_tackle_power_rate();
  ::uint32_t raw_tackle_power_rate;
  memcpy(&raw_tackle_power_rate, &tmp_tackle_power_rate, sizeof(tmp_tackle_power_rate));
  if (raw_tackle_power_rate != 0) {
    total_size += 6;
  }

  // int32 freeform_wait_period = 141;
  if (this->_internal_freeform_wait_period() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_freeform_wait_period());
  }

  // int32 freeform_send_period = 142;
  if (this->_internal_freeform_send_period() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_freeform_send_period());
  }

  // float stopped_ball_vel = 146;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stopped_ball_vel = this->_internal_stopped_ball_vel();
  ::uint32_t raw_stopped_ball_vel;
  memcpy(&raw_stopped_ball_vel, &tmp_stopped_ball_vel, sizeof(tmp_stopped_ball_vel));
  if (raw_stopped_ball_vel != 0) {
    total_size += 6;
  }

  // int32 max_goal_kicks = 147;
  if (this->_internal_max_goal_kicks() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_max_goal_kicks());
  }

  // int32 clang_del_win = 148;
  if (this->_internal_clang_del_win() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_del_win());
  }

  // int32 clang_rule_win = 149;
  if (this->_internal_clang_rule_win() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_clang_rule_win());
  }

  // int32 kick_off_wait = 151;
  if (this->_internal_kick_off_wait() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_kick_off_wait());
  }

  // int32 connect_wait = 152;
  if (this->_internal_connect_wait() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_connect_wait());
  }

  // bool proper_goal_kicks = 145;
  if (this->_internal_proper_goal_kicks() != 0) {
    total_size += 3;
  }

  // bool auto_mode = 150;
  if (this->_internal_auto_mode() != 0) {
    total_size += 3;
  }

  // bool keepaway_mode = 156;
  if (this->_internal_keepaway_mode() != 0) {
    total_size += 3;
  }

  // bool keepaway_logging = 159;
  if (this->_internal_keepaway_logging() != 0) {
    total_size += 3;
  }

  // int32 game_over_wait = 153;
  if (this->_internal_game_over_wait() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_game_over_wait());
  }

  // float keepaway_length = 157;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_keepaway_length = this->_internal_keepaway_length();
  ::uint32_t raw_keepaway_length;
  memcpy(&raw_keepaway_length, &tmp_keepaway_length, sizeof(tmp_keepaway_length));
  if (raw_keepaway_length != 0) {
    total_size += 6;
  }

  // float keepaway_width = 158;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_keepaway_width = this->_internal_keepaway_width();
  ::uint32_t raw_keepaway_width;
  memcpy(&raw_keepaway_width, &tmp_keepaway_width, sizeof(tmp_keepaway_width));
  if (raw_keepaway_width != 0) {
    total_size += 6;
  }

  // int32 keepaway_start = 164;
  if (this->_internal_keepaway_start() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_keepaway_start());
  }

  // int32 nr_normal_halfs = 165;
  if (this->_internal_nr_normal_halfs() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_nr_normal_halfs());
  }

  // int32 nr_extra_halfs = 166;
  if (this->_internal_nr_extra_halfs() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_nr_extra_halfs());
  }

  // bool keepaway_log_fixed = 162;
  if (this->_internal_keepaway_log_fixed() != 0) {
    total_size += 3;
  }

  // bool keepaway_log_dated = 163;
  if (this->_internal_keepaway_log_dated() != 0) {
    total_size += 3;
  }

  // bool penalty_shoot_outs = 167;
  if (this->_internal_penalty_shoot_outs() != 0) {
    total_size += 3;
  }

  // bool pen_random_winner = 175;
  if (this->_internal_pen_random_winner() != 0) {
    total_size += 3;
  }

  // int32 pen_before_setup_wait = 168;
  if (this->_internal_pen_before_setup_wait() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_pen_before_setup_wait());
  }

  // int32 pen_setup_wait = 169;
  if (this->_internal_pen_setup_wait() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_pen_setup_wait());
  }

  // int32 pen_ready_wait = 170;
  if (this->_internal_pen_ready_wait() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_pen_ready_wait());
  }

  // int32 pen_taken_wait = 171;
  if (this->_internal_pen_taken_wait() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_pen_taken_wait());
  }

  // int32 pen_nr_kicks = 172;
  if (this->_internal_pen_nr_kicks() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_pen_nr_kicks());
  }

  // int32 pen_max_extra_kicks = 173;
  if (this->_internal_pen_max_extra_kicks() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_pen_max_extra_kicks());
  }

  // float pen_dist_x = 174;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pen_dist_x = this->_internal_pen_dist_x();
  ::uint32_t raw_pen_dist_x;
  memcpy(&raw_pen_dist_x, &tmp_pen_dist_x, sizeof(tmp_pen_dist_x));
  if (raw_pen_dist_x != 0) {
    total_size += 6;
  }

  // float pen_max_goalie_dist_x = 177;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pen_max_goalie_dist_x = this->_internal_pen_max_goalie_dist_x();
  ::uint32_t raw_pen_max_goalie_dist_x;
  memcpy(&raw_pen_max_goalie_dist_x, &tmp_pen_max_goalie_dist_x, sizeof(tmp_pen_max_goalie_dist_x));
  if (raw_pen_max_goalie_dist_x != 0) {
    total_size += 6;
  }

  // float ball_stuck_area = 180;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_stuck_area = this->_internal_ball_stuck_area();
  ::uint32_t raw_ball_stuck_area;
  memcpy(&raw_ball_stuck_area, &tmp_ball_stuck_area, sizeof(tmp_ball_stuck_area));
  if (raw_ball_stuck_area != 0) {
    total_size += 6;
  }

  // float max_tackle_power = 182;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_tackle_power = this->_internal_max_tackle_power();
  ::uint32_t raw_max_tackle_power;
  memcpy(&raw_max_tackle_power, &tmp_max_tackle_power, sizeof(tmp_max_tackle_power));
  if (raw_max_tackle_power != 0) {
    total_size += 6;
  }

  // float max_back_tackle_power = 183;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_back_tackle_power = this->_internal_max_back_tackle_power();
  ::uint32_t raw_max_back_tackle_power;
  memcpy(&raw_max_back_tackle_power, &tmp_max_back_tackle_power, sizeof(tmp_max_back_tackle_power));
  if (raw_max_back_tackle_power != 0) {
    total_size += 6;
  }

  // float player_speed_max_min = 184;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_min = this->_internal_player_speed_max_min();
  ::uint32_t raw_player_speed_max_min;
  memcpy(&raw_player_speed_max_min, &tmp_player_speed_max_min, sizeof(tmp_player_speed_max_min));
  if (raw_player_speed_max_min != 0) {
    total_size += 6;
  }

  // bool pen_allow_mult_kicks = 176;
  if (this->_internal_pen_allow_mult_kicks() != 0) {
    total_size += 3;
  }

  // bool pen_coach_moves_players = 178;
  if (this->_internal_pen_coach_moves_players() != 0) {
    total_size += 3;
  }

  // bool golden_goal = 200;
  if (this->_internal_golden_goal() != 0) {
    total_size += 3;
  }

  // float extra_stamina = 185;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina = this->_internal_extra_stamina();
  ::uint32_t raw_extra_stamina;
  memcpy(&raw_extra_stamina, &tmp_extra_stamina, sizeof(tmp_extra_stamina));
  if (raw_extra_stamina != 0) {
    total_size += 6;
  }

  // int32 synch_see_offset = 186;
  if (this->_internal_synch_see_offset() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_synch_see_offset());
  }

  // int32 extra_half_time = 187;
  if (this->_internal_extra_half_time() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_extra_half_time());
  }

  // float stamina_capacity = 188;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = this->_internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    total_size += 6;
  }

  // float max_dash_angle = 189;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_angle = this->_internal_max_dash_angle();
  ::uint32_t raw_max_dash_angle;
  memcpy(&raw_max_dash_angle, &tmp_max_dash_angle, sizeof(tmp_max_dash_angle));
  if (raw_max_dash_angle != 0) {
    total_size += 6;
  }

  // float min_dash_angle = 190;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_dash_angle = this->_internal_min_dash_angle();
  ::uint32_t raw_min_dash_angle;
  memcpy(&raw_min_dash_angle, &tmp_min_dash_angle, sizeof(tmp_min_dash_angle));
  if (raw_min_dash_angle != 0) {
    total_size += 6;
  }

  // float dash_angle_step = 191;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_angle_step = this->_internal_dash_angle_step();
  ::uint32_t raw_dash_angle_step;
  memcpy(&raw_dash_angle_step, &tmp_dash_angle_step, sizeof(tmp_dash_angle_step));
  if (raw_dash_angle_step != 0) {
    total_size += 6;
  }

  // float side_dash_rate = 192;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_side_dash_rate = this->_internal_side_dash_rate();
  ::uint32_t raw_side_dash_rate;
  memcpy(&raw_side_dash_rate, &tmp_side_dash_rate, sizeof(tmp_side_dash_rate));
  if (raw_side_dash_rate != 0) {
    total_size += 6;
  }

  // float back_dash_rate = 193;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_back_dash_rate = this->_internal_back_dash_rate();
  ::uint32_t raw_back_dash_rate;
  memcpy(&raw_back_dash_rate, &tmp_back_dash_rate, sizeof(tmp_back_dash_rate));
  if (raw_back_dash_rate != 0) {
    total_size += 6;
  }

  // float max_dash_power = 194;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = this->_internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    total_size += 6;
  }

  // float min_dash_power = 195;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_dash_power = this->_internal_min_dash_power();
  ::uint32_t raw_min_dash_power;
  memcpy(&raw_min_dash_power, &tmp_min_dash_power, sizeof(tmp_min_dash_power));
  if (raw_min_dash_power != 0) {
    total_size += 6;
  }

  // float tackle_rand_factor = 196;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_rand_factor = this->_internal_tackle_rand_factor();
  ::uint32_t raw_tackle_rand_factor;
  memcpy(&raw_tackle_rand_factor, &tmp_tackle_rand_factor, sizeof(tmp_tackle_rand_factor));
  if (raw_tackle_rand_factor != 0) {
    total_size += 6;
  }

  // float foul_detect_probability = 197;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability = this->_internal_foul_detect_probability();
  ::uint32_t raw_foul_detect_probability;
  memcpy(&raw_foul_detect_probability, &tmp_foul_detect_probability, sizeof(tmp_foul_detect_probability));
  if (raw_foul_detect_probability != 0) {
    total_size += 6;
  }

  // float foul_exponent = 198;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_exponent = this->_internal_foul_exponent();
  ::uint32_t raw_foul_exponent;
  memcpy(&raw_foul_exponent, &tmp_foul_exponent, sizeof(tmp_foul_exponent));
  if (raw_foul_exponent != 0) {
    total_size += 6;
  }

  // int32 foul_cycles = 199;
  if (this->_internal_foul_cycles() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_foul_cycles());
  }

  // float red_card_probability = 201;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_red_card_probability = this->_internal_red_card_probability();
  ::uint32_t raw_red_card_probability;
  memcpy(&raw_red_card_probability, &tmp_red_card_probability, sizeof(tmp_red_card_probability));
  if (raw_red_card_probability != 0) {
    total_size += 6;
  }

  // int32 illegal_defense_duration = 202;
  if (this->_internal_illegal_defense_duration() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_illegal_defense_duration());
  }

  // int32 illegal_defense_number = 203;
  if (this->_internal_illegal_defense_number() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_illegal_defense_number());
  }

  // float illegal_defense_dist_x = 204;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_illegal_defense_dist_x = this->_internal_illegal_defense_dist_x();
  ::uint32_t raw_illegal_defense_dist_x;
  memcpy(&raw_illegal_defense_dist_x, &tmp_illegal_defense_dist_x, sizeof(tmp_illegal_defense_dist_x));
  if (raw_illegal_defense_dist_x != 0) {
    total_size += 6;
  }

  // float illegal_defense_width = 205;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_illegal_defense_width = this->_internal_illegal_defense_width();
  ::uint32_t raw_illegal_defense_width;
  memcpy(&raw_illegal_defense_width, &tmp_illegal_defense_width, sizeof(tmp_illegal_defense_width));
  if (raw_illegal_defense_width != 0) {
    total_size += 6;
  }

  // float max_catch_angle = 208;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_catch_angle = this->_internal_max_catch_angle();
  ::uint32_t raw_max_catch_angle;
  memcpy(&raw_max_catch_angle, &tmp_max_catch_angle, sizeof(tmp_max_catch_angle));
  if (raw_max_catch_angle != 0) {
    total_size += 6;
  }

  // float min_catch_angle = 209;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_catch_angle = this->_internal_min_catch_angle();
  ::uint32_t raw_min_catch_angle;
  memcpy(&raw_min_catch_angle, &tmp_min_catch_angle, sizeof(tmp_min_catch_angle));
  if (raw_min_catch_angle != 0) {
    total_size += 6;
  }

  // int32 random_seed = 210;
  if (this->_internal_random_seed() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_random_seed());
  }

  // float long_kick_power_factor = 211;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_long_kick_power_factor = this->_internal_long_kick_power_factor();
  ::uint32_t raw_long_kick_power_factor;
  memcpy(&raw_long_kick_power_factor, &tmp_long_kick_power_factor, sizeof(tmp_long_kick_power_factor));
  if (raw_long_kick_power_factor != 0) {
    total_size += 6;
  }

  // int32 long_kick_delay = 212;
  if (this->_internal_long_kick_delay() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_long_kick_delay());
  }

  // int32 max_monitors = 213;
  if (this->_internal_max_monitors() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_max_monitors());
  }

  // float catchable_area = 214;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area = this->_internal_catchable_area();
  ::uint32_t raw_catchable_area;
  memcpy(&raw_catchable_area, &tmp_catchable_area, sizeof(tmp_catchable_area));
  if (raw_catchable_area != 0) {
    total_size += 6;
  }

  // float real_speed_max = 215;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max = this->_internal_real_speed_max();
  ::uint32_t raw_real_speed_max;
  memcpy(&raw_real_speed_max, &tmp_real_speed_max, sizeof(tmp_real_speed_max));
  if (raw_real_speed_max != 0) {
    total_size += 6;
  }

  // float pitch_half_length = 216;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pitch_half_length = this->_internal_pitch_half_length();
  ::uint32_t raw_pitch_half_length;
  memcpy(&raw_pitch_half_length, &tmp_pitch_half_length, sizeof(tmp_pitch_half_length));
  if (raw_pitch_half_length != 0) {
    total_size += 6;
  }

  // float pitch_half_width = 217;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pitch_half_width = this->_internal_pitch_half_width();
  ::uint32_t raw_pitch_half_width;
  memcpy(&raw_pitch_half_width, &tmp_pitch_half_width, sizeof(tmp_pitch_half_width));
  if (raw_pitch_half_width != 0) {
    total_size += 6;
  }

  // float our_penalty_area_line_x = 218;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_our_penalty_area_line_x = this->_internal_our_penalty_area_line_x();
  ::uint32_t raw_our_penalty_area_line_x;
  memcpy(&raw_our_penalty_area_line_x, &tmp_our_penalty_area_line_x, sizeof(tmp_our_penalty_area_line_x));
  if (raw_our_penalty_area_line_x != 0) {
    total_size += 6;
  }

  // float their_penalty_area_line_x = 219;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_their_penalty_area_line_x = this->_internal_their_penalty_area_line_x();
  ::uint32_t raw_their_penalty_area_line_x;
  memcpy(&raw_their_penalty_area_line_x, &tmp_their_penalty_area_line_x, sizeof(tmp_their_penalty_area_line_x));
  if (raw_their_penalty_area_line_x != 0) {
    total_size += 6;
  }

  // float penalty_area_half_width = 220;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_penalty_area_half_width = this->_internal_penalty_area_half_width();
  ::uint32_t raw_penalty_area_half_width;
  memcpy(&raw_penalty_area_half_width, &tmp_penalty_area_half_width, sizeof(tmp_penalty_area_half_width));
  if (raw_penalty_area_half_width != 0) {
    total_size += 6;
  }

  // float penalty_area_length = 221;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_penalty_area_length = this->_internal_penalty_area_length();
  ::uint32_t raw_penalty_area_length;
  memcpy(&raw_penalty_area_length, &tmp_penalty_area_length, sizeof(tmp_penalty_area_length));
  if (raw_penalty_area_length != 0) {
    total_size += 6;
  }

  // float goal_width = 222;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goal_width = this->_internal_goal_width();
  ::uint32_t raw_goal_width;
  memcpy(&raw_goal_width, &tmp_goal_width, sizeof(tmp_goal_width));
  if (raw_goal_width != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerParam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServerParam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerParam::GetClassData() const { return &_class_data_; }


void ServerParam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServerParam*>(&to_msg);
  auto& from = static_cast<const ServerParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.ServerParam)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_replay_file().empty()) {
    _this->_internal_set_replay_file(from._internal_replay_file());
  }
  if (!from._internal_landmark_file().empty()) {
    _this->_internal_set_landmark_file(from._internal_landmark_file());
  }
  if (!from._internal_text_log_dir().empty()) {
    _this->_internal_set_text_log_dir(from._internal_text_log_dir());
  }
  if (!from._internal_game_log_dir().empty()) {
    _this->_internal_set_game_log_dir(from._internal_game_log_dir());
  }
  if (!from._internal_text_log_fixed_name().empty()) {
    _this->_internal_set_text_log_fixed_name(from._internal_text_log_fixed_name());
  }
  if (!from._internal_game_log_fixed_name().empty()) {
    _this->_internal_set_game_log_fixed_name(from._internal_game_log_fixed_name());
  }
  if (!from._internal_log_date_format().empty()) {
    _this->_internal_set_log_date_format(from._internal_log_date_format());
  }
  if (!from._internal_team_l_start().empty()) {
    _this->_internal_set_team_l_start(from._internal_team_l_start());
  }
  if (!from._internal_team_r_start().empty()) {
    _this->_internal_set_team_r_start(from._internal_team_r_start());
  }
  if (!from._internal_keepaway_log_dir().empty()) {
    _this->_internal_set_keepaway_log_dir(from._internal_keepaway_log_dir());
  }
  if (!from._internal_keepaway_log_fixed_name().empty()) {
    _this->_internal_set_keepaway_log_fixed_name(from._internal_keepaway_log_fixed_name());
  }
  if (!from._internal_module_dir().empty()) {
    _this->_internal_set_module_dir(from._internal_module_dir());
  }
  if (!from._internal_coach_msg_file().empty()) {
    _this->_internal_set_coach_msg_file(from._internal_coach_msg_file());
  }
  if (!from._internal_fixed_teamname_l().empty()) {
    _this->_internal_set_fixed_teamname_l(from._internal_fixed_teamname_l());
  }
  if (!from._internal_fixed_teamname_r().empty()) {
    _this->_internal_set_fixed_teamname_r(from._internal_fixed_teamname_r());
  }
  if (from._internal_agent_type() != 0) {
    _this->_internal_set_agent_type(from._internal_agent_type());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment = from._internal_inertia_moment();
  ::uint32_t raw_inertia_moment;
  memcpy(&raw_inertia_moment, &tmp_inertia_moment, sizeof(tmp_inertia_moment));
  if (raw_inertia_moment != 0) {
    _this->_internal_set_inertia_moment(from._internal_inertia_moment());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size = from._internal_player_size();
  ::uint32_t raw_player_size;
  memcpy(&raw_player_size, &tmp_player_size, sizeof(tmp_player_size));
  if (raw_player_size != 0) {
    _this->_internal_set_player_size(from._internal_player_size());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay = from._internal_player_decay();
  ::uint32_t raw_player_decay;
  memcpy(&raw_player_decay, &tmp_player_decay, sizeof(tmp_player_decay));
  if (raw_player_decay != 0) {
    _this->_internal_set_player_decay(from._internal_player_decay());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand = from._internal_player_rand();
  ::uint32_t raw_player_rand;
  memcpy(&raw_player_rand, &tmp_player_rand, sizeof(tmp_player_rand));
  if (raw_player_rand != 0) {
    _this->_internal_set_player_rand(from._internal_player_rand());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_weight = from._internal_player_weight();
  ::uint32_t raw_player_weight;
  memcpy(&raw_player_weight, &tmp_player_weight, sizeof(tmp_player_weight));
  if (raw_player_weight != 0) {
    _this->_internal_set_player_weight(from._internal_player_weight());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max = from._internal_player_speed_max();
  ::uint32_t raw_player_speed_max;
  memcpy(&raw_player_speed_max, &tmp_player_speed_max, sizeof(tmp_player_speed_max));
  if (raw_player_speed_max != 0) {
    _this->_internal_set_player_speed_max(from._internal_player_speed_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_accel_max = from._internal_player_accel_max();
  ::uint32_t raw_player_accel_max;
  memcpy(&raw_player_accel_max, &tmp_player_accel_max, sizeof(tmp_player_accel_max));
  if (raw_player_accel_max != 0) {
    _this->_internal_set_player_accel_max(from._internal_player_accel_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_max = from._internal_stamina_max();
  ::uint32_t raw_stamina_max;
  memcpy(&raw_stamina_max, &tmp_stamina_max, sizeof(tmp_stamina_max));
  if (raw_stamina_max != 0) {
    _this->_internal_set_stamina_max(from._internal_stamina_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max = from._internal_stamina_inc_max();
  ::uint32_t raw_stamina_inc_max;
  memcpy(&raw_stamina_inc_max, &tmp_stamina_inc_max, sizeof(tmp_stamina_inc_max));
  if (raw_stamina_inc_max != 0) {
    _this->_internal_set_stamina_inc_max(from._internal_stamina_inc_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_init = from._internal_recover_init();
  ::uint32_t raw_recover_init;
  memcpy(&raw_recover_init, &tmp_recover_init, sizeof(tmp_recover_init));
  if (raw_recover_init != 0) {
    _this->_internal_set_recover_init(from._internal_recover_init());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_dec_thr = from._internal_recover_dec_thr();
  ::uint32_t raw_recover_dec_thr;
  memcpy(&raw_recover_dec_thr, &tmp_recover_dec_thr, sizeof(tmp_recover_dec_thr));
  if (raw_recover_dec_thr != 0) {
    _this->_internal_set_recover_dec_thr(from._internal_recover_dec_thr());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_min = from._internal_recover_min();
  ::uint32_t raw_recover_min;
  memcpy(&raw_recover_min, &tmp_recover_min, sizeof(tmp_recover_min));
  if (raw_recover_min != 0) {
    _this->_internal_set_recover_min(from._internal_recover_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recover_dec = from._internal_recover_dec();
  ::uint32_t raw_recover_dec;
  memcpy(&raw_recover_dec, &tmp_recover_dec, sizeof(tmp_recover_dec));
  if (raw_recover_dec != 0) {
    _this->_internal_set_recover_dec(from._internal_recover_dec());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_init = from._internal_effort_init();
  ::uint32_t raw_effort_init;
  memcpy(&raw_effort_init, &tmp_effort_init, sizeof(tmp_effort_init));
  if (raw_effort_init != 0) {
    _this->_internal_set_effort_init(from._internal_effort_init());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_dec_thr = from._internal_effort_dec_thr();
  ::uint32_t raw_effort_dec_thr;
  memcpy(&raw_effort_dec_thr, &tmp_effort_dec_thr, sizeof(tmp_effort_dec_thr));
  if (raw_effort_dec_thr != 0) {
    _this->_internal_set_effort_dec_thr(from._internal_effort_dec_thr());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min = from._internal_effort_min();
  ::uint32_t raw_effort_min;
  memcpy(&raw_effort_min, &tmp_effort_min, sizeof(tmp_effort_min));
  if (raw_effort_min != 0) {
    _this->_internal_set_effort_min(from._internal_effort_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_dec = from._internal_effort_dec();
  ::uint32_t raw_effort_dec;
  memcpy(&raw_effort_dec, &tmp_effort_dec, sizeof(tmp_effort_dec));
  if (raw_effort_dec != 0) {
    _this->_internal_set_effort_dec(from._internal_effort_dec());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_inc_thr = from._internal_effort_inc_thr();
  ::uint32_t raw_effort_inc_thr;
  memcpy(&raw_effort_inc_thr, &tmp_effort_inc_thr, sizeof(tmp_effort_inc_thr));
  if (raw_effort_inc_thr != 0) {
    _this->_internal_set_effort_inc_thr(from._internal_effort_inc_thr());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_inc = from._internal_effort_inc();
  ::uint32_t raw_effort_inc;
  memcpy(&raw_effort_inc, &tmp_effort_inc, sizeof(tmp_effort_inc));
  if (raw_effort_inc != 0) {
    _this->_internal_set_effort_inc(from._internal_effort_inc());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand = from._internal_kick_rand();
  ::uint32_t raw_kick_rand;
  memcpy(&raw_kick_rand, &tmp_kick_rand, sizeof(tmp_kick_rand));
  if (raw_kick_rand != 0) {
    _this->_internal_set_kick_rand(from._internal_kick_rand());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand_factor_l = from._internal_player_rand_factor_l();
  ::uint32_t raw_player_rand_factor_l;
  memcpy(&raw_player_rand_factor_l, &tmp_player_rand_factor_l, sizeof(tmp_player_rand_factor_l));
  if (raw_player_rand_factor_l != 0) {
    _this->_internal_set_player_rand_factor_l(from._internal_player_rand_factor_l());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_rand_factor_r = from._internal_player_rand_factor_r();
  ::uint32_t raw_player_rand_factor_r;
  memcpy(&raw_player_rand_factor_r, &tmp_player_rand_factor_r, sizeof(tmp_player_rand_factor_r));
  if (raw_player_rand_factor_r != 0) {
    _this->_internal_set_player_rand_factor_r(from._internal_player_rand_factor_r());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_factor_l = from._internal_kick_rand_factor_l();
  ::uint32_t raw_kick_rand_factor_l;
  memcpy(&raw_kick_rand_factor_l, &tmp_kick_rand_factor_l, sizeof(tmp_kick_rand_factor_l));
  if (raw_kick_rand_factor_l != 0) {
    _this->_internal_set_kick_rand_factor_l(from._internal_kick_rand_factor_l());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_factor_r = from._internal_kick_rand_factor_r();
  ::uint32_t raw_kick_rand_factor_r;
  memcpy(&raw_kick_rand_factor_r, &tmp_kick_rand_factor_r, sizeof(tmp_kick_rand_factor_r));
  if (raw_kick_rand_factor_r != 0) {
    _this->_internal_set_kick_rand_factor_r(from._internal_kick_rand_factor_r());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_size = from._internal_ball_size();
  ::uint32_t raw_ball_size;
  memcpy(&raw_ball_size, &tmp_ball_size, sizeof(tmp_ball_size));
  if (raw_ball_size != 0) {
    _this->_internal_set_ball_size(from._internal_ball_size());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_decay = from._internal_ball_decay();
  ::uint32_t raw_ball_decay;
  memcpy(&raw_ball_decay, &tmp_ball_decay, sizeof(tmp_ball_decay));
  if (raw_ball_decay != 0) {
    _this->_internal_set_ball_decay(from._internal_ball_decay());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_rand = from._internal_ball_rand();
  ::uint32_t raw_ball_rand;
  memcpy(&raw_ball_rand, &tmp_ball_rand, sizeof(tmp_ball_rand));
  if (raw_ball_rand != 0) {
    _this->_internal_set_ball_rand(from._internal_ball_rand());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_weight = from._internal_ball_weight();
  ::uint32_t raw_ball_weight;
  memcpy(&raw_ball_weight, &tmp_ball_weight, sizeof(tmp_ball_weight));
  if (raw_ball_weight != 0) {
    _this->_internal_set_ball_weight(from._internal_ball_weight());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_speed_max = from._internal_ball_speed_max();
  ::uint32_t raw_ball_speed_max;
  memcpy(&raw_ball_speed_max, &tmp_ball_speed_max, sizeof(tmp_ball_speed_max));
  if (raw_ball_speed_max != 0) {
    _this->_internal_set_ball_speed_max(from._internal_ball_speed_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_accel_max = from._internal_ball_accel_max();
  ::uint32_t raw_ball_accel_max;
  memcpy(&raw_ball_accel_max, &tmp_ball_accel_max, sizeof(tmp_ball_accel_max));
  if (raw_ball_accel_max != 0) {
    _this->_internal_set_ball_accel_max(from._internal_ball_accel_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate = from._internal_dash_power_rate();
  ::uint32_t raw_dash_power_rate;
  memcpy(&raw_dash_power_rate, &tmp_dash_power_rate, sizeof(tmp_dash_power_rate));
  if (raw_dash_power_rate != 0) {
    _this->_internal_set_dash_power_rate(from._internal_dash_power_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate = from._internal_kick_power_rate();
  ::uint32_t raw_kick_power_rate;
  memcpy(&raw_kick_power_rate, &tmp_kick_power_rate, sizeof(tmp_kick_power_rate));
  if (raw_kick_power_rate != 0) {
    _this->_internal_set_kick_power_rate(from._internal_kick_power_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin = from._internal_kickable_margin();
  ::uint32_t raw_kickable_margin;
  memcpy(&raw_kickable_margin, &tmp_kickable_margin, sizeof(tmp_kickable_margin));
  if (raw_kickable_margin != 0) {
    _this->_internal_set_kickable_margin(from._internal_kickable_margin());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_control_radius = from._internal_control_radius();
  ::uint32_t raw_control_radius;
  memcpy(&raw_control_radius, &tmp_control_radius, sizeof(tmp_control_radius));
  if (raw_control_radius != 0) {
    _this->_internal_set_control_radius(from._internal_control_radius());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_control_radius_width = from._internal_control_radius_width();
  ::uint32_t raw_control_radius_width;
  memcpy(&raw_control_radius_width, &tmp_control_radius_width, sizeof(tmp_control_radius_width));
  if (raw_control_radius_width != 0) {
    _this->_internal_set_control_radius_width(from._internal_control_radius_width());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_power = from._internal_max_power();
  ::uint32_t raw_max_power;
  memcpy(&raw_max_power, &tmp_max_power, sizeof(tmp_max_power));
  if (raw_max_power != 0) {
    _this->_internal_set_max_power(from._internal_max_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_power = from._internal_min_power();
  ::uint32_t raw_min_power;
  memcpy(&raw_min_power, &tmp_min_power, sizeof(tmp_min_power));
  if (raw_min_power != 0) {
    _this->_internal_set_min_power(from._internal_min_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_moment = from._internal_max_moment();
  ::uint32_t raw_max_moment;
  memcpy(&raw_max_moment, &tmp_max_moment, sizeof(tmp_max_moment));
  if (raw_max_moment != 0) {
    _this->_internal_set_max_moment(from._internal_max_moment());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_moment = from._internal_min_moment();
  ::uint32_t raw_min_moment;
  memcpy(&raw_min_moment, &tmp_min_moment, sizeof(tmp_min_moment));
  if (raw_min_moment != 0) {
    _this->_internal_set_min_moment(from._internal_min_moment());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_neck_moment = from._internal_max_neck_moment();
  ::uint32_t raw_max_neck_moment;
  memcpy(&raw_max_neck_moment, &tmp_max_neck_moment, sizeof(tmp_max_neck_moment));
  if (raw_max_neck_moment != 0) {
    _this->_internal_set_max_neck_moment(from._internal_max_neck_moment());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_neck_moment = from._internal_min_neck_moment();
  ::uint32_t raw_min_neck_moment;
  memcpy(&raw_min_neck_moment, &tmp_min_neck_moment, sizeof(tmp_min_neck_moment));
  if (raw_min_neck_moment != 0) {
    _this->_internal_set_min_neck_moment(from._internal_min_neck_moment());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_neck_angle = from._internal_max_neck_angle();
  ::uint32_t raw_max_neck_angle;
  memcpy(&raw_max_neck_angle, &tmp_max_neck_angle, sizeof(tmp_max_neck_angle));
  if (raw_max_neck_angle != 0) {
    _this->_internal_set_max_neck_angle(from._internal_max_neck_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_neck_angle = from._internal_min_neck_angle();
  ::uint32_t raw_min_neck_angle;
  memcpy(&raw_min_neck_angle, &tmp_min_neck_angle, sizeof(tmp_min_neck_angle));
  if (raw_min_neck_angle != 0) {
    _this->_internal_set_min_neck_angle(from._internal_min_neck_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_visible_angle = from._internal_visible_angle();
  ::uint32_t raw_visible_angle;
  memcpy(&raw_visible_angle, &tmp_visible_angle, sizeof(tmp_visible_angle));
  if (raw_visible_angle != 0) {
    _this->_internal_set_visible_angle(from._internal_visible_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_visible_distance = from._internal_visible_distance();
  ::uint32_t raw_visible_distance;
  memcpy(&raw_visible_distance, &tmp_visible_distance, sizeof(tmp_visible_distance));
  if (raw_visible_distance != 0) {
    _this->_internal_set_visible_distance(from._internal_visible_distance());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_dir = from._internal_wind_dir();
  ::uint32_t raw_wind_dir;
  memcpy(&raw_wind_dir, &tmp_wind_dir, sizeof(tmp_wind_dir));
  if (raw_wind_dir != 0) {
    _this->_internal_set_wind_dir(from._internal_wind_dir());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_force = from._internal_wind_force();
  ::uint32_t raw_wind_force;
  memcpy(&raw_wind_force, &tmp_wind_force, sizeof(tmp_wind_force));
  if (raw_wind_force != 0) {
    _this->_internal_set_wind_force(from._internal_wind_force());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_angle = from._internal_wind_angle();
  ::uint32_t raw_wind_angle;
  memcpy(&raw_wind_angle, &tmp_wind_angle, sizeof(tmp_wind_angle));
  if (raw_wind_angle != 0) {
    _this->_internal_set_wind_angle(from._internal_wind_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wind_rand = from._internal_wind_rand();
  ::uint32_t raw_wind_rand;
  memcpy(&raw_wind_rand, &tmp_wind_rand, sizeof(tmp_wind_rand));
  if (raw_wind_rand != 0) {
    _this->_internal_set_wind_rand(from._internal_wind_rand());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_area = from._internal_kickable_area();
  ::uint32_t raw_kickable_area;
  memcpy(&raw_kickable_area, &tmp_kickable_area, sizeof(tmp_kickable_area));
  if (raw_kickable_area != 0) {
    _this->_internal_set_kickable_area(from._internal_kickable_area());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_area_l = from._internal_catch_area_l();
  ::uint32_t raw_catch_area_l;
  memcpy(&raw_catch_area_l, &tmp_catch_area_l, sizeof(tmp_catch_area_l));
  if (raw_catch_area_l != 0) {
    _this->_internal_set_catch_area_l(from._internal_catch_area_l());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_area_w = from._internal_catch_area_w();
  ::uint32_t raw_catch_area_w;
  memcpy(&raw_catch_area_w, &tmp_catch_area_w, sizeof(tmp_catch_area_w));
  if (raw_catch_area_w != 0) {
    _this->_internal_set_catch_area_w(from._internal_catch_area_w());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = from._internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    _this->_internal_set_catch_probability(from._internal_catch_probability());
  }
  if (from._internal_team_actuator_noise() != 0) {
    _this->_internal_set_team_actuator_noise(from._internal_team_actuator_noise());
  }
  if (from._internal_wind_none() != 0) {
    _this->_internal_set_wind_none(from._internal_wind_none());
  }
  if (from._internal_use_wind_random() != 0) {
    _this->_internal_set_use_wind_random(from._internal_use_wind_random());
  }
  if (from._internal_use_offside() != 0) {
    _this->_internal_set_use_offside(from._internal_use_offside());
  }
  if (from._internal_goalie_max_moves() != 0) {
    _this->_internal_set_goalie_max_moves(from._internal_goalie_max_moves());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_corner_kick_margin = from._internal_corner_kick_margin();
  ::uint32_t raw_corner_kick_margin;
  memcpy(&raw_corner_kick_margin, &tmp_corner_kick_margin, sizeof(tmp_corner_kick_margin));
  if (raw_corner_kick_margin != 0) {
    _this->_internal_set_corner_kick_margin(from._internal_corner_kick_margin());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_active_area_size = from._internal_offside_active_area_size();
  ::uint32_t raw_offside_active_area_size;
  memcpy(&raw_offside_active_area_size, &tmp_offside_active_area_size, sizeof(tmp_offside_active_area_size));
  if (raw_offside_active_area_size != 0) {
    _this->_internal_set_offside_active_area_size(from._internal_offside_active_area_size());
  }
  if (from._internal_coach_say_count_max() != 0) {
    _this->_internal_set_coach_say_count_max(from._internal_coach_say_count_max());
  }
  if (from._internal_coach_say_msg_size() != 0) {
    _this->_internal_set_coach_say_msg_size(from._internal_coach_say_msg_size());
  }
  if (from._internal_clang_win_size() != 0) {
    _this->_internal_set_clang_win_size(from._internal_clang_win_size());
  }
  if (from._internal_clang_define_win() != 0) {
    _this->_internal_set_clang_define_win(from._internal_clang_define_win());
  }
  if (from._internal_clang_meta_win() != 0) {
    _this->_internal_set_clang_meta_win(from._internal_clang_meta_win());
  }
  if (from._internal_clang_advice_win() != 0) {
    _this->_internal_set_clang_advice_win(from._internal_clang_advice_win());
  }
  if (from._internal_clang_info_win() != 0) {
    _this->_internal_set_clang_info_win(from._internal_clang_info_win());
  }
  if (from._internal_clang_mess_delay() != 0) {
    _this->_internal_set_clang_mess_delay(from._internal_clang_mess_delay());
  }
  if (from._internal_clang_mess_per_cycle() != 0) {
    _this->_internal_set_clang_mess_per_cycle(from._internal_clang_mess_per_cycle());
  }
  if (from._internal_half_time() != 0) {
    _this->_internal_set_half_time(from._internal_half_time());
  }
  if (from._internal_simulator_step() != 0) {
    _this->_internal_set_simulator_step(from._internal_simulator_step());
  }
  if (from._internal_send_step() != 0) {
    _this->_internal_set_send_step(from._internal_send_step());
  }
  if (from._internal_recv_step() != 0) {
    _this->_internal_set_recv_step(from._internal_recv_step());
  }
  if (from._internal_sense_body_step() != 0) {
    _this->_internal_set_sense_body_step(from._internal_sense_body_step());
  }
  if (from._internal_lcm_step() != 0) {
    _this->_internal_set_lcm_step(from._internal_lcm_step());
  }
  if (from._internal_player_say_msg_size() != 0) {
    _this->_internal_set_player_say_msg_size(from._internal_player_say_msg_size());
  }
  if (from._internal_player_hear_max() != 0) {
    _this->_internal_set_player_hear_max(from._internal_player_hear_max());
  }
  if (from._internal_player_hear_inc() != 0) {
    _this->_internal_set_player_hear_inc(from._internal_player_hear_inc());
  }
  if (from._internal_player_hear_decay() != 0) {
    _this->_internal_set_player_hear_decay(from._internal_player_hear_decay());
  }
  if (from._internal_catch_ban_cycle() != 0) {
    _this->_internal_set_catch_ban_cycle(from._internal_catch_ban_cycle());
  }
  if (from._internal_slow_down_factor() != 0) {
    _this->_internal_set_slow_down_factor(from._internal_slow_down_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_kick_margin = from._internal_offside_kick_margin();
  ::uint32_t raw_offside_kick_margin;
  memcpy(&raw_offside_kick_margin, &tmp_offside_kick_margin, sizeof(tmp_offside_kick_margin));
  if (raw_offside_kick_margin != 0) {
    _this->_internal_set_offside_kick_margin(from._internal_offside_kick_margin());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_audio_cut_dist = from._internal_audio_cut_dist();
  ::uint32_t raw_audio_cut_dist;
  memcpy(&raw_audio_cut_dist, &tmp_audio_cut_dist, sizeof(tmp_audio_cut_dist));
  if (raw_audio_cut_dist != 0) {
    _this->_internal_set_audio_cut_dist(from._internal_audio_cut_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step = from._internal_dist_quantize_step();
  ::uint32_t raw_dist_quantize_step;
  memcpy(&raw_dist_quantize_step, &tmp_dist_quantize_step, sizeof(tmp_dist_quantize_step));
  if (raw_dist_quantize_step != 0) {
    _this->_internal_set_dist_quantize_step(from._internal_dist_quantize_step());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step = from._internal_landmark_dist_quantize_step();
  ::uint32_t raw_landmark_dist_quantize_step;
  memcpy(&raw_landmark_dist_quantize_step, &tmp_landmark_dist_quantize_step, sizeof(tmp_landmark_dist_quantize_step));
  if (raw_landmark_dist_quantize_step != 0) {
    _this->_internal_set_landmark_dist_quantize_step(from._internal_landmark_dist_quantize_step());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step = from._internal_dir_quantize_step();
  ::uint32_t raw_dir_quantize_step;
  memcpy(&raw_dir_quantize_step, &tmp_dir_quantize_step, sizeof(tmp_dir_quantize_step));
  if (raw_dir_quantize_step != 0) {
    _this->_internal_set_dir_quantize_step(from._internal_dir_quantize_step());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step_l = from._internal_dist_quantize_step_l();
  ::uint32_t raw_dist_quantize_step_l;
  memcpy(&raw_dist_quantize_step_l, &tmp_dist_quantize_step_l, sizeof(tmp_dist_quantize_step_l));
  if (raw_dist_quantize_step_l != 0) {
    _this->_internal_set_dist_quantize_step_l(from._internal_dist_quantize_step_l());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_quantize_step_r = from._internal_dist_quantize_step_r();
  ::uint32_t raw_dist_quantize_step_r;
  memcpy(&raw_dist_quantize_step_r, &tmp_dist_quantize_step_r, sizeof(tmp_dist_quantize_step_r));
  if (raw_dist_quantize_step_r != 0) {
    _this->_internal_set_dist_quantize_step_r(from._internal_dist_quantize_step_r());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step_l = from._internal_landmark_dist_quantize_step_l();
  ::uint32_t raw_landmark_dist_quantize_step_l;
  memcpy(&raw_landmark_dist_quantize_step_l, &tmp_landmark_dist_quantize_step_l, sizeof(tmp_landmark_dist_quantize_step_l));
  if (raw_landmark_dist_quantize_step_l != 0) {
    _this->_internal_set_landmark_dist_quantize_step_l(from._internal_landmark_dist_quantize_step_l());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_landmark_dist_quantize_step_r = from._internal_landmark_dist_quantize_step_r();
  ::uint32_t raw_landmark_dist_quantize_step_r;
  memcpy(&raw_landmark_dist_quantize_step_r, &tmp_landmark_dist_quantize_step_r, sizeof(tmp_landmark_dist_quantize_step_r));
  if (raw_landmark_dist_quantize_step_r != 0) {
    _this->_internal_set_landmark_dist_quantize_step_r(from._internal_landmark_dist_quantize_step_r());
  }
  if (from._internal_kickoff_offside() != 0) {
    _this->_internal_set_kickoff_offside(from._internal_kickoff_offside());
  }
  if (from._internal_coach_mode() != 0) {
    _this->_internal_set_coach_mode(from._internal_coach_mode());
  }
  if (from._internal_coach_with_referee_mode() != 0) {
    _this->_internal_set_coach_with_referee_mode(from._internal_coach_with_referee_mode());
  }
  if (from._internal_use_old_coach_hear() != 0) {
    _this->_internal_set_use_old_coach_hear(from._internal_use_old_coach_hear());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step_l = from._internal_dir_quantize_step_l();
  ::uint32_t raw_dir_quantize_step_l;
  memcpy(&raw_dir_quantize_step_l, &tmp_dir_quantize_step_l, sizeof(tmp_dir_quantize_step_l));
  if (raw_dir_quantize_step_l != 0) {
    _this->_internal_set_dir_quantize_step_l(from._internal_dir_quantize_step_l());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dir_quantize_step_r = from._internal_dir_quantize_step_r();
  ::uint32_t raw_dir_quantize_step_r;
  memcpy(&raw_dir_quantize_step_r, &tmp_dir_quantize_step_r, sizeof(tmp_dir_quantize_step_r));
  if (raw_dir_quantize_step_r != 0) {
    _this->_internal_set_dir_quantize_step_r(from._internal_dir_quantize_step_r());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slowness_on_top_for_left_team = from._internal_slowness_on_top_for_left_team();
  ::uint32_t raw_slowness_on_top_for_left_team;
  memcpy(&raw_slowness_on_top_for_left_team, &tmp_slowness_on_top_for_left_team, sizeof(tmp_slowness_on_top_for_left_team));
  if (raw_slowness_on_top_for_left_team != 0) {
    _this->_internal_set_slowness_on_top_for_left_team(from._internal_slowness_on_top_for_left_team());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slowness_on_top_for_right_team = from._internal_slowness_on_top_for_right_team();
  ::uint32_t raw_slowness_on_top_for_right_team;
  memcpy(&raw_slowness_on_top_for_right_team, &tmp_slowness_on_top_for_right_team, sizeof(tmp_slowness_on_top_for_right_team));
  if (raw_slowness_on_top_for_right_team != 0) {
    _this->_internal_set_slowness_on_top_for_right_team(from._internal_slowness_on_top_for_right_team());
  }
  if (from._internal_start_goal_l() != 0) {
    _this->_internal_set_start_goal_l(from._internal_start_goal_l());
  }
  if (from._internal_start_goal_r() != 0) {
    _this->_internal_set_start_goal_r(from._internal_start_goal_r());
  }
  if (from._internal_drop_ball_time() != 0) {
    _this->_internal_set_drop_ball_time(from._internal_drop_ball_time());
  }
  if (from._internal_fullstate_l() != 0) {
    _this->_internal_set_fullstate_l(from._internal_fullstate_l());
  }
  if (from._internal_fullstate_r() != 0) {
    _this->_internal_set_fullstate_r(from._internal_fullstate_r());
  }
  if (from._internal_synch_mode() != 0) {
    _this->_internal_set_synch_mode(from._internal_synch_mode());
  }
  if (from._internal_verbose_mode() != 0) {
    _this->_internal_set_verbose_mode(from._internal_verbose_mode());
  }
  if (from._internal_synch_offset() != 0) {
    _this->_internal_set_synch_offset(from._internal_synch_offset());
  }
  if (from._internal_synch_micro_sleep() != 0) {
    _this->_internal_set_synch_micro_sleep(from._internal_synch_micro_sleep());
  }
  if (from._internal_point_to_ban() != 0) {
    _this->_internal_set_point_to_ban(from._internal_point_to_ban());
  }
  if (from._internal_point_to_duration() != 0) {
    _this->_internal_set_point_to_duration(from._internal_point_to_duration());
  }
  if (from._internal_player_port() != 0) {
    _this->_internal_set_player_port(from._internal_player_port());
  }
  if (from._internal_trainer_port() != 0) {
    _this->_internal_set_trainer_port(from._internal_trainer_port());
  }
  if (from._internal_online_coach_port() != 0) {
    _this->_internal_set_online_coach_port(from._internal_online_coach_port());
  }
  if (from._internal_coach_send_vi_step() != 0) {
    _this->_internal_set_coach_send_vi_step(from._internal_coach_send_vi_step());
  }
  if (from._internal_send_comms() != 0) {
    _this->_internal_set_send_comms(from._internal_send_comms());
  }
  if (from._internal_text_logging() != 0) {
    _this->_internal_set_text_logging(from._internal_text_logging());
  }
  if (from._internal_game_logging() != 0) {
    _this->_internal_set_game_logging(from._internal_game_logging());
  }
  if (from._internal_use_text_log_fixed() != 0) {
    _this->_internal_set_use_text_log_fixed(from._internal_use_text_log_fixed());
  }
  if (from._internal_game_log_version() != 0) {
    _this->_internal_set_game_log_version(from._internal_game_log_version());
  }
  if (from._internal_use_game_log_fixed() != 0) {
    _this->_internal_set_use_game_log_fixed(from._internal_use_game_log_fixed());
  }
  if (from._internal_use_text_log_dated() != 0) {
    _this->_internal_set_use_text_log_dated(from._internal_use_text_log_dated());
  }
  if (from._internal_use_game_log_dated() != 0) {
    _this->_internal_set_use_game_log_dated(from._internal_use_game_log_dated());
  }
  if (from._internal_log_times() != 0) {
    _this->_internal_set_log_times(from._internal_log_times());
  }
  if (from._internal_text_log_compression() != 0) {
    _this->_internal_set_text_log_compression(from._internal_text_log_compression());
  }
  if (from._internal_game_log_compression() != 0) {
    _this->_internal_set_game_log_compression(from._internal_game_log_compression());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_dist = from._internal_tackle_dist();
  ::uint32_t raw_tackle_dist;
  memcpy(&raw_tackle_dist, &tmp_tackle_dist, sizeof(tmp_tackle_dist));
  if (raw_tackle_dist != 0) {
    _this->_internal_set_tackle_dist(from._internal_tackle_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_back_dist = from._internal_tackle_back_dist();
  ::uint32_t raw_tackle_back_dist;
  memcpy(&raw_tackle_back_dist, &tmp_tackle_back_dist, sizeof(tmp_tackle_back_dist));
  if (raw_tackle_back_dist != 0) {
    _this->_internal_set_tackle_back_dist(from._internal_tackle_back_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_width = from._internal_tackle_width();
  ::uint32_t raw_tackle_width;
  memcpy(&raw_tackle_width, &tmp_tackle_width, sizeof(tmp_tackle_width));
  if (raw_tackle_width != 0) {
    _this->_internal_set_tackle_width(from._internal_tackle_width());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_exponent = from._internal_tackle_exponent();
  ::uint32_t raw_tackle_exponent;
  memcpy(&raw_tackle_exponent, &tmp_tackle_exponent, sizeof(tmp_tackle_exponent));
  if (raw_tackle_exponent != 0) {
    _this->_internal_set_tackle_exponent(from._internal_tackle_exponent());
  }
  if (from._internal_record_message() != 0) {
    _this->_internal_set_record_message(from._internal_record_message());
  }
  if (from._internal_use_profile() != 0) {
    _this->_internal_set_use_profile(from._internal_use_profile());
  }
  if (from._internal_free_kick_faults() != 0) {
    _this->_internal_set_free_kick_faults(from._internal_free_kick_faults());
  }
  if (from._internal_back_passes() != 0) {
    _this->_internal_set_back_passes(from._internal_back_passes());
  }
  if (from._internal_tackle_cycles() != 0) {
    _this->_internal_set_tackle_cycles(from._internal_tackle_cycles());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_power_rate = from._internal_tackle_power_rate();
  ::uint32_t raw_tackle_power_rate;
  memcpy(&raw_tackle_power_rate, &tmp_tackle_power_rate, sizeof(tmp_tackle_power_rate));
  if (raw_tackle_power_rate != 0) {
    _this->_internal_set_tackle_power_rate(from._internal_tackle_power_rate());
  }
  if (from._internal_freeform_wait_period() != 0) {
    _this->_internal_set_freeform_wait_period(from._internal_freeform_wait_period());
  }
  if (from._internal_freeform_send_period() != 0) {
    _this->_internal_set_freeform_send_period(from._internal_freeform_send_period());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stopped_ball_vel = from._internal_stopped_ball_vel();
  ::uint32_t raw_stopped_ball_vel;
  memcpy(&raw_stopped_ball_vel, &tmp_stopped_ball_vel, sizeof(tmp_stopped_ball_vel));
  if (raw_stopped_ball_vel != 0) {
    _this->_internal_set_stopped_ball_vel(from._internal_stopped_ball_vel());
  }
  if (from._internal_max_goal_kicks() != 0) {
    _this->_internal_set_max_goal_kicks(from._internal_max_goal_kicks());
  }
  if (from._internal_clang_del_win() != 0) {
    _this->_internal_set_clang_del_win(from._internal_clang_del_win());
  }
  if (from._internal_clang_rule_win() != 0) {
    _this->_internal_set_clang_rule_win(from._internal_clang_rule_win());
  }
  if (from._internal_kick_off_wait() != 0) {
    _this->_internal_set_kick_off_wait(from._internal_kick_off_wait());
  }
  if (from._internal_connect_wait() != 0) {
    _this->_internal_set_connect_wait(from._internal_connect_wait());
  }
  if (from._internal_proper_goal_kicks() != 0) {
    _this->_internal_set_proper_goal_kicks(from._internal_proper_goal_kicks());
  }
  if (from._internal_auto_mode() != 0) {
    _this->_internal_set_auto_mode(from._internal_auto_mode());
  }
  if (from._internal_keepaway_mode() != 0) {
    _this->_internal_set_keepaway_mode(from._internal_keepaway_mode());
  }
  if (from._internal_keepaway_logging() != 0) {
    _this->_internal_set_keepaway_logging(from._internal_keepaway_logging());
  }
  if (from._internal_game_over_wait() != 0) {
    _this->_internal_set_game_over_wait(from._internal_game_over_wait());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_keepaway_length = from._internal_keepaway_length();
  ::uint32_t raw_keepaway_length;
  memcpy(&raw_keepaway_length, &tmp_keepaway_length, sizeof(tmp_keepaway_length));
  if (raw_keepaway_length != 0) {
    _this->_internal_set_keepaway_length(from._internal_keepaway_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_keepaway_width = from._internal_keepaway_width();
  ::uint32_t raw_keepaway_width;
  memcpy(&raw_keepaway_width, &tmp_keepaway_width, sizeof(tmp_keepaway_width));
  if (raw_keepaway_width != 0) {
    _this->_internal_set_keepaway_width(from._internal_keepaway_width());
  }
  if (from._internal_keepaway_start() != 0) {
    _this->_internal_set_keepaway_start(from._internal_keepaway_start());
  }
  if (from._internal_nr_normal_halfs() != 0) {
    _this->_internal_set_nr_normal_halfs(from._internal_nr_normal_halfs());
  }
  if (from._internal_nr_extra_halfs() != 0) {
    _this->_internal_set_nr_extra_halfs(from._internal_nr_extra_halfs());
  }
  if (from._internal_keepaway_log_fixed() != 0) {
    _this->_internal_set_keepaway_log_fixed(from._internal_keepaway_log_fixed());
  }
  if (from._internal_keepaway_log_dated() != 0) {
    _this->_internal_set_keepaway_log_dated(from._internal_keepaway_log_dated());
  }
  if (from._internal_penalty_shoot_outs() != 0) {
    _this->_internal_set_penalty_shoot_outs(from._internal_penalty_shoot_outs());
  }
  if (from._internal_pen_random_winner() != 0) {
    _this->_internal_set_pen_random_winner(from._internal_pen_random_winner());
  }
  if (from._internal_pen_before_setup_wait() != 0) {
    _this->_internal_set_pen_before_setup_wait(from._internal_pen_before_setup_wait());
  }
  if (from._internal_pen_setup_wait() != 0) {
    _this->_internal_set_pen_setup_wait(from._internal_pen_setup_wait());
  }
  if (from._internal_pen_ready_wait() != 0) {
    _this->_internal_set_pen_ready_wait(from._internal_pen_ready_wait());
  }
  if (from._internal_pen_taken_wait() != 0) {
    _this->_internal_set_pen_taken_wait(from._internal_pen_taken_wait());
  }
  if (from._internal_pen_nr_kicks() != 0) {
    _this->_internal_set_pen_nr_kicks(from._internal_pen_nr_kicks());
  }
  if (from._internal_pen_max_extra_kicks() != 0) {
    _this->_internal_set_pen_max_extra_kicks(from._internal_pen_max_extra_kicks());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pen_dist_x = from._internal_pen_dist_x();
  ::uint32_t raw_pen_dist_x;
  memcpy(&raw_pen_dist_x, &tmp_pen_dist_x, sizeof(tmp_pen_dist_x));
  if (raw_pen_dist_x != 0) {
    _this->_internal_set_pen_dist_x(from._internal_pen_dist_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pen_max_goalie_dist_x = from._internal_pen_max_goalie_dist_x();
  ::uint32_t raw_pen_max_goalie_dist_x;
  memcpy(&raw_pen_max_goalie_dist_x, &tmp_pen_max_goalie_dist_x, sizeof(tmp_pen_max_goalie_dist_x));
  if (raw_pen_max_goalie_dist_x != 0) {
    _this->_internal_set_pen_max_goalie_dist_x(from._internal_pen_max_goalie_dist_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_stuck_area = from._internal_ball_stuck_area();
  ::uint32_t raw_ball_stuck_area;
  memcpy(&raw_ball_stuck_area, &tmp_ball_stuck_area, sizeof(tmp_ball_stuck_area));
  if (raw_ball_stuck_area != 0) {
    _this->_internal_set_ball_stuck_area(from._internal_ball_stuck_area());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_tackle_power = from._internal_max_tackle_power();
  ::uint32_t raw_max_tackle_power;
  memcpy(&raw_max_tackle_power, &tmp_max_tackle_power, sizeof(tmp_max_tackle_power));
  if (raw_max_tackle_power != 0) {
    _this->_internal_set_max_tackle_power(from._internal_max_tackle_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_back_tackle_power = from._internal_max_back_tackle_power();
  ::uint32_t raw_max_back_tackle_power;
  memcpy(&raw_max_back_tackle_power, &tmp_max_back_tackle_power, sizeof(tmp_max_back_tackle_power));
  if (raw_max_back_tackle_power != 0) {
    _this->_internal_set_max_back_tackle_power(from._internal_max_back_tackle_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_min = from._internal_player_speed_max_min();
  ::uint32_t raw_player_speed_max_min;
  memcpy(&raw_player_speed_max_min, &tmp_player_speed_max_min, sizeof(tmp_player_speed_max_min));
  if (raw_player_speed_max_min != 0) {
    _this->_internal_set_player_speed_max_min(from._internal_player_speed_max_min());
  }
  if (from._internal_pen_allow_mult_kicks() != 0) {
    _this->_internal_set_pen_allow_mult_kicks(from._internal_pen_allow_mult_kicks());
  }
  if (from._internal_pen_coach_moves_players() != 0) {
    _this->_internal_set_pen_coach_moves_players(from._internal_pen_coach_moves_players());
  }
  if (from._internal_golden_goal() != 0) {
    _this->_internal_set_golden_goal(from._internal_golden_goal());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina = from._internal_extra_stamina();
  ::uint32_t raw_extra_stamina;
  memcpy(&raw_extra_stamina, &tmp_extra_stamina, sizeof(tmp_extra_stamina));
  if (raw_extra_stamina != 0) {
    _this->_internal_set_extra_stamina(from._internal_extra_stamina());
  }
  if (from._internal_synch_see_offset() != 0) {
    _this->_internal_set_synch_see_offset(from._internal_synch_see_offset());
  }
  if (from._internal_extra_half_time() != 0) {
    _this->_internal_set_extra_half_time(from._internal_extra_half_time());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = from._internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    _this->_internal_set_stamina_capacity(from._internal_stamina_capacity());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_angle = from._internal_max_dash_angle();
  ::uint32_t raw_max_dash_angle;
  memcpy(&raw_max_dash_angle, &tmp_max_dash_angle, sizeof(tmp_max_dash_angle));
  if (raw_max_dash_angle != 0) {
    _this->_internal_set_max_dash_angle(from._internal_max_dash_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_dash_angle = from._internal_min_dash_angle();
  ::uint32_t raw_min_dash_angle;
  memcpy(&raw_min_dash_angle, &tmp_min_dash_angle, sizeof(tmp_min_dash_angle));
  if (raw_min_dash_angle != 0) {
    _this->_internal_set_min_dash_angle(from._internal_min_dash_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_angle_step = from._internal_dash_angle_step();
  ::uint32_t raw_dash_angle_step;
  memcpy(&raw_dash_angle_step, &tmp_dash_angle_step, sizeof(tmp_dash_angle_step));
  if (raw_dash_angle_step != 0) {
    _this->_internal_set_dash_angle_step(from._internal_dash_angle_step());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_side_dash_rate = from._internal_side_dash_rate();
  ::uint32_t raw_side_dash_rate;
  memcpy(&raw_side_dash_rate, &tmp_side_dash_rate, sizeof(tmp_side_dash_rate));
  if (raw_side_dash_rate != 0) {
    _this->_internal_set_side_dash_rate(from._internal_side_dash_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_back_dash_rate = from._internal_back_dash_rate();
  ::uint32_t raw_back_dash_rate;
  memcpy(&raw_back_dash_rate, &tmp_back_dash_rate, sizeof(tmp_back_dash_rate));
  if (raw_back_dash_rate != 0) {
    _this->_internal_set_back_dash_rate(from._internal_back_dash_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_dash_power = from._internal_max_dash_power();
  ::uint32_t raw_max_dash_power;
  memcpy(&raw_max_dash_power, &tmp_max_dash_power, sizeof(tmp_max_dash_power));
  if (raw_max_dash_power != 0) {
    _this->_internal_set_max_dash_power(from._internal_max_dash_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_dash_power = from._internal_min_dash_power();
  ::uint32_t raw_min_dash_power;
  memcpy(&raw_min_dash_power, &tmp_min_dash_power, sizeof(tmp_min_dash_power));
  if (raw_min_dash_power != 0) {
    _this->_internal_set_min_dash_power(from._internal_min_dash_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_rand_factor = from._internal_tackle_rand_factor();
  ::uint32_t raw_tackle_rand_factor;
  memcpy(&raw_tackle_rand_factor, &tmp_tackle_rand_factor, sizeof(tmp_tackle_rand_factor));
  if (raw_tackle_rand_factor != 0) {
    _this->_internal_set_tackle_rand_factor(from._internal_tackle_rand_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability = from._internal_foul_detect_probability();
  ::uint32_t raw_foul_detect_probability;
  memcpy(&raw_foul_detect_probability, &tmp_foul_detect_probability, sizeof(tmp_foul_detect_probability));
  if (raw_foul_detect_probability != 0) {
    _this->_internal_set_foul_detect_probability(from._internal_foul_detect_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_exponent = from._internal_foul_exponent();
  ::uint32_t raw_foul_exponent;
  memcpy(&raw_foul_exponent, &tmp_foul_exponent, sizeof(tmp_foul_exponent));
  if (raw_foul_exponent != 0) {
    _this->_internal_set_foul_exponent(from._internal_foul_exponent());
  }
  if (from._internal_foul_cycles() != 0) {
    _this->_internal_set_foul_cycles(from._internal_foul_cycles());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_red_card_probability = from._internal_red_card_probability();
  ::uint32_t raw_red_card_probability;
  memcpy(&raw_red_card_probability, &tmp_red_card_probability, sizeof(tmp_red_card_probability));
  if (raw_red_card_probability != 0) {
    _this->_internal_set_red_card_probability(from._internal_red_card_probability());
  }
  if (from._internal_illegal_defense_duration() != 0) {
    _this->_internal_set_illegal_defense_duration(from._internal_illegal_defense_duration());
  }
  if (from._internal_illegal_defense_number() != 0) {
    _this->_internal_set_illegal_defense_number(from._internal_illegal_defense_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_illegal_defense_dist_x = from._internal_illegal_defense_dist_x();
  ::uint32_t raw_illegal_defense_dist_x;
  memcpy(&raw_illegal_defense_dist_x, &tmp_illegal_defense_dist_x, sizeof(tmp_illegal_defense_dist_x));
  if (raw_illegal_defense_dist_x != 0) {
    _this->_internal_set_illegal_defense_dist_x(from._internal_illegal_defense_dist_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_illegal_defense_width = from._internal_illegal_defense_width();
  ::uint32_t raw_illegal_defense_width;
  memcpy(&raw_illegal_defense_width, &tmp_illegal_defense_width, sizeof(tmp_illegal_defense_width));
  if (raw_illegal_defense_width != 0) {
    _this->_internal_set_illegal_defense_width(from._internal_illegal_defense_width());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_catch_angle = from._internal_max_catch_angle();
  ::uint32_t raw_max_catch_angle;
  memcpy(&raw_max_catch_angle, &tmp_max_catch_angle, sizeof(tmp_max_catch_angle));
  if (raw_max_catch_angle != 0) {
    _this->_internal_set_max_catch_angle(from._internal_max_catch_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_catch_angle = from._internal_min_catch_angle();
  ::uint32_t raw_min_catch_angle;
  memcpy(&raw_min_catch_angle, &tmp_min_catch_angle, sizeof(tmp_min_catch_angle));
  if (raw_min_catch_angle != 0) {
    _this->_internal_set_min_catch_angle(from._internal_min_catch_angle());
  }
  if (from._internal_random_seed() != 0) {
    _this->_internal_set_random_seed(from._internal_random_seed());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_long_kick_power_factor = from._internal_long_kick_power_factor();
  ::uint32_t raw_long_kick_power_factor;
  memcpy(&raw_long_kick_power_factor, &tmp_long_kick_power_factor, sizeof(tmp_long_kick_power_factor));
  if (raw_long_kick_power_factor != 0) {
    _this->_internal_set_long_kick_power_factor(from._internal_long_kick_power_factor());
  }
  if (from._internal_long_kick_delay() != 0) {
    _this->_internal_set_long_kick_delay(from._internal_long_kick_delay());
  }
  if (from._internal_max_monitors() != 0) {
    _this->_internal_set_max_monitors(from._internal_max_monitors());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area = from._internal_catchable_area();
  ::uint32_t raw_catchable_area;
  memcpy(&raw_catchable_area, &tmp_catchable_area, sizeof(tmp_catchable_area));
  if (raw_catchable_area != 0) {
    _this->_internal_set_catchable_area(from._internal_catchable_area());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max = from._internal_real_speed_max();
  ::uint32_t raw_real_speed_max;
  memcpy(&raw_real_speed_max, &tmp_real_speed_max, sizeof(tmp_real_speed_max));
  if (raw_real_speed_max != 0) {
    _this->_internal_set_real_speed_max(from._internal_real_speed_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pitch_half_length = from._internal_pitch_half_length();
  ::uint32_t raw_pitch_half_length;
  memcpy(&raw_pitch_half_length, &tmp_pitch_half_length, sizeof(tmp_pitch_half_length));
  if (raw_pitch_half_length != 0) {
    _this->_internal_set_pitch_half_length(from._internal_pitch_half_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pitch_half_width = from._internal_pitch_half_width();
  ::uint32_t raw_pitch_half_width;
  memcpy(&raw_pitch_half_width, &tmp_pitch_half_width, sizeof(tmp_pitch_half_width));
  if (raw_pitch_half_width != 0) {
    _this->_internal_set_pitch_half_width(from._internal_pitch_half_width());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_our_penalty_area_line_x = from._internal_our_penalty_area_line_x();
  ::uint32_t raw_our_penalty_area_line_x;
  memcpy(&raw_our_penalty_area_line_x, &tmp_our_penalty_area_line_x, sizeof(tmp_our_penalty_area_line_x));
  if (raw_our_penalty_area_line_x != 0) {
    _this->_internal_set_our_penalty_area_line_x(from._internal_our_penalty_area_line_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_their_penalty_area_line_x = from._internal_their_penalty_area_line_x();
  ::uint32_t raw_their_penalty_area_line_x;
  memcpy(&raw_their_penalty_area_line_x, &tmp_their_penalty_area_line_x, sizeof(tmp_their_penalty_area_line_x));
  if (raw_their_penalty_area_line_x != 0) {
    _this->_internal_set_their_penalty_area_line_x(from._internal_their_penalty_area_line_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_penalty_area_half_width = from._internal_penalty_area_half_width();
  ::uint32_t raw_penalty_area_half_width;
  memcpy(&raw_penalty_area_half_width, &tmp_penalty_area_half_width, sizeof(tmp_penalty_area_half_width));
  if (raw_penalty_area_half_width != 0) {
    _this->_internal_set_penalty_area_half_width(from._internal_penalty_area_half_width());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_penalty_area_length = from._internal_penalty_area_length();
  ::uint32_t raw_penalty_area_length;
  memcpy(&raw_penalty_area_length, &tmp_penalty_area_length, sizeof(tmp_penalty_area_length));
  if (raw_penalty_area_length != 0) {
    _this->_internal_set_penalty_area_length(from._internal_penalty_area_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goal_width = from._internal_goal_width();
  ::uint32_t raw_goal_width;
  memcpy(&raw_goal_width, &tmp_goal_width, sizeof(tmp_goal_width));
  if (raw_goal_width != 0) {
    _this->_internal_set_goal_width(from._internal_goal_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerParam::CopyFrom(const ServerParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.ServerParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerParam::IsInitialized() const {
  return true;
}

void ServerParam::InternalSwap(ServerParam* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.replay_file_, lhs_arena,
                                       &other->_impl_.replay_file_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.landmark_file_, lhs_arena,
                                       &other->_impl_.landmark_file_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.text_log_dir_, lhs_arena,
                                       &other->_impl_.text_log_dir_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.game_log_dir_, lhs_arena,
                                       &other->_impl_.game_log_dir_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.text_log_fixed_name_, lhs_arena,
                                       &other->_impl_.text_log_fixed_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.game_log_fixed_name_, lhs_arena,
                                       &other->_impl_.game_log_fixed_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.log_date_format_, lhs_arena,
                                       &other->_impl_.log_date_format_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.team_l_start_, lhs_arena,
                                       &other->_impl_.team_l_start_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.team_r_start_, lhs_arena,
                                       &other->_impl_.team_r_start_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.keepaway_log_dir_, lhs_arena,
                                       &other->_impl_.keepaway_log_dir_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.keepaway_log_fixed_name_, lhs_arena,
                                       &other->_impl_.keepaway_log_fixed_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.module_dir_, lhs_arena,
                                       &other->_impl_.module_dir_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.coach_msg_file_, lhs_arena,
                                       &other->_impl_.coach_msg_file_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fixed_teamname_l_, lhs_arena,
                                       &other->_impl_.fixed_teamname_l_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fixed_teamname_r_, lhs_arena,
                                       &other->_impl_.fixed_teamname_r_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerParam, _impl_.goal_width_)
      + sizeof(ServerParam::_impl_.goal_width_)
      - PROTOBUF_FIELD_OFFSET(ServerParam, _impl_.agent_type_)>(
          reinterpret_cast<char*>(&_impl_.agent_type_),
          reinterpret_cast<char*>(&other->_impl_.agent_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[122]);
}
// ===================================================================

class PlayerParam::_Internal {
 public:
};

PlayerParam::PlayerParam(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PlayerParam)
}
PlayerParam::PlayerParam(const PlayerParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PlayerParam)
}

inline void PlayerParam::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.agent_type_) { 0 }

    , decltype(_impl_.player_types_) { 0 }

    , decltype(_impl_.subs_max_) { 0 }

    , decltype(_impl_.pt_max_) { 0 }

    , decltype(_impl_.allow_mult_default_type_) { false }

    , decltype(_impl_.player_speed_max_delta_min_) { 0 }

    , decltype(_impl_.player_speed_max_delta_max_) { 0 }

    , decltype(_impl_.stamina_inc_max_delta_factor_) { 0 }

    , decltype(_impl_.player_decay_delta_min_) { 0 }

    , decltype(_impl_.player_decay_delta_max_) { 0 }

    , decltype(_impl_.inertia_moment_delta_factor_) { 0 }

    , decltype(_impl_.dash_power_rate_delta_min_) { 0 }

    , decltype(_impl_.dash_power_rate_delta_max_) { 0 }

    , decltype(_impl_.player_size_delta_factor_) { 0 }

    , decltype(_impl_.kickable_margin_delta_min_) { 0 }

    , decltype(_impl_.kickable_margin_delta_max_) { 0 }

    , decltype(_impl_.kick_rand_delta_factor_) { 0 }

    , decltype(_impl_.extra_stamina_delta_min_) { 0 }

    , decltype(_impl_.extra_stamina_delta_max_) { 0 }

    , decltype(_impl_.effort_max_delta_factor_) { 0 }

    , decltype(_impl_.effort_min_delta_factor_) { 0 }

    , decltype(_impl_.random_seed_) { 0 }

    , decltype(_impl_.new_dash_power_rate_delta_min_) { 0 }

    , decltype(_impl_.new_dash_power_rate_delta_max_) { 0 }

    , decltype(_impl_.new_stamina_inc_max_delta_factor_) { 0 }

    , decltype(_impl_.kick_power_rate_delta_min_) { 0 }

    , decltype(_impl_.kick_power_rate_delta_max_) { 0 }

    , decltype(_impl_.foul_detect_probability_delta_factor_) { 0 }

    , decltype(_impl_.catchable_area_l_stretch_min_) { 0 }

    , decltype(_impl_.catchable_area_l_stretch_max_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerParam::~PlayerParam() {
  // @@protoc_insertion_point(destructor:protos.PlayerParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerParam::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerParam::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PlayerParam)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.agent_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.catchable_area_l_stretch_max_) -
      reinterpret_cast<char*>(&_impl_.agent_type_)) + sizeof(_impl_.catchable_area_l_stretch_max_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.AgentType agent_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_agent_type(static_cast<::protos::AgentType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.player_types_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 subs_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.subs_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pt_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.pt_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool allow_mult_default_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.allow_mult_default_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_speed_max_delta_min = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.player_speed_max_delta_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_speed_max_delta_max = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _impl_.player_speed_max_delta_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina_inc_max_delta_factor = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.stamina_inc_max_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_decay_delta_min = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.player_decay_delta_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_decay_delta_max = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.player_decay_delta_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float inertia_moment_delta_factor = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 93)) {
          _impl_.inertia_moment_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power_rate_delta_min = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.dash_power_rate_delta_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power_rate_delta_max = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.dash_power_rate_delta_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_size_delta_factor = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 117)) {
          _impl_.player_size_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kickable_margin_delta_min = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _impl_.kickable_margin_delta_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kickable_margin_delta_max = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.kickable_margin_delta_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_rand_delta_factor = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.kick_rand_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float extra_stamina_delta_min = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 149)) {
          _impl_.extra_stamina_delta_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float extra_stamina_delta_max = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.extra_stamina_delta_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_max_delta_factor = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 165)) {
          _impl_.effort_max_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_min_delta_factor = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.effort_min_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 random_seed = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float new_dash_power_rate_delta_min = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.new_dash_power_rate_delta_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float new_dash_power_rate_delta_max = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.new_dash_power_rate_delta_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float new_stamina_inc_max_delta_factor = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.new_stamina_inc_max_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_power_rate_delta_min = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.kick_power_rate_delta_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_power_rate_delta_max = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.kick_power_rate_delta_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float foul_detect_probability_delta_factor = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.foul_detect_probability_delta_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catchable_area_l_stretch_min = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.catchable_area_l_stretch_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catchable_area_l_stretch_max = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 245)) {
          _impl_.catchable_area_l_stretch_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PlayerParam::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PlayerParam)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_agent_type(), target);
  }

  // int32 player_types = 2;
  if (this->_internal_player_types() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_player_types(), target);
  }

  // int32 subs_max = 3;
  if (this->_internal_subs_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_subs_max(), target);
  }

  // int32 pt_max = 4;
  if (this->_internal_pt_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_pt_max(), target);
  }

  // bool allow_mult_default_type = 5;
  if (this->_internal_allow_mult_default_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_allow_mult_default_type(), target);
  }

  // float player_speed_max_delta_min = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_delta_min = this->_internal_player_speed_max_delta_min();
  ::uint32_t raw_player_speed_max_delta_min;
  memcpy(&raw_player_speed_max_delta_min, &tmp_player_speed_max_delta_min, sizeof(tmp_player_speed_max_delta_min));
  if (raw_player_speed_max_delta_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_player_speed_max_delta_min(), target);
  }

  // float player_speed_max_delta_max = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_delta_max = this->_internal_player_speed_max_delta_max();
  ::uint32_t raw_player_speed_max_delta_max;
  memcpy(&raw_player_speed_max_delta_max, &tmp_player_speed_max_delta_max, sizeof(tmp_player_speed_max_delta_max));
  if (raw_player_speed_max_delta_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_player_speed_max_delta_max(), target);
  }

  // float stamina_inc_max_delta_factor = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max_delta_factor = this->_internal_stamina_inc_max_delta_factor();
  ::uint32_t raw_stamina_inc_max_delta_factor;
  memcpy(&raw_stamina_inc_max_delta_factor, &tmp_stamina_inc_max_delta_factor, sizeof(tmp_stamina_inc_max_delta_factor));
  if (raw_stamina_inc_max_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_stamina_inc_max_delta_factor(), target);
  }

  // float player_decay_delta_min = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay_delta_min = this->_internal_player_decay_delta_min();
  ::uint32_t raw_player_decay_delta_min;
  memcpy(&raw_player_decay_delta_min, &tmp_player_decay_delta_min, sizeof(tmp_player_decay_delta_min));
  if (raw_player_decay_delta_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_player_decay_delta_min(), target);
  }

  // float player_decay_delta_max = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay_delta_max = this->_internal_player_decay_delta_max();
  ::uint32_t raw_player_decay_delta_max;
  memcpy(&raw_player_decay_delta_max, &tmp_player_decay_delta_max, sizeof(tmp_player_decay_delta_max));
  if (raw_player_decay_delta_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_player_decay_delta_max(), target);
  }

  // float inertia_moment_delta_factor = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment_delta_factor = this->_internal_inertia_moment_delta_factor();
  ::uint32_t raw_inertia_moment_delta_factor;
  memcpy(&raw_inertia_moment_delta_factor, &tmp_inertia_moment_delta_factor, sizeof(tmp_inertia_moment_delta_factor));
  if (raw_inertia_moment_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_inertia_moment_delta_factor(), target);
  }

  // float dash_power_rate_delta_min = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate_delta_min = this->_internal_dash_power_rate_delta_min();
  ::uint32_t raw_dash_power_rate_delta_min;
  memcpy(&raw_dash_power_rate_delta_min, &tmp_dash_power_rate_delta_min, sizeof(tmp_dash_power_rate_delta_min));
  if (raw_dash_power_rate_delta_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_dash_power_rate_delta_min(), target);
  }

  // float dash_power_rate_delta_max = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate_delta_max = this->_internal_dash_power_rate_delta_max();
  ::uint32_t raw_dash_power_rate_delta_max;
  memcpy(&raw_dash_power_rate_delta_max, &tmp_dash_power_rate_delta_max, sizeof(tmp_dash_power_rate_delta_max));
  if (raw_dash_power_rate_delta_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_dash_power_rate_delta_max(), target);
  }

  // float player_size_delta_factor = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size_delta_factor = this->_internal_player_size_delta_factor();
  ::uint32_t raw_player_size_delta_factor;
  memcpy(&raw_player_size_delta_factor, &tmp_player_size_delta_factor, sizeof(tmp_player_size_delta_factor));
  if (raw_player_size_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_player_size_delta_factor(), target);
  }

  // float kickable_margin_delta_min = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin_delta_min = this->_internal_kickable_margin_delta_min();
  ::uint32_t raw_kickable_margin_delta_min;
  memcpy(&raw_kickable_margin_delta_min, &tmp_kickable_margin_delta_min, sizeof(tmp_kickable_margin_delta_min));
  if (raw_kickable_margin_delta_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_kickable_margin_delta_min(), target);
  }

  // float kickable_margin_delta_max = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin_delta_max = this->_internal_kickable_margin_delta_max();
  ::uint32_t raw_kickable_margin_delta_max;
  memcpy(&raw_kickable_margin_delta_max, &tmp_kickable_margin_delta_max, sizeof(tmp_kickable_margin_delta_max));
  if (raw_kickable_margin_delta_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_kickable_margin_delta_max(), target);
  }

  // float kick_rand_delta_factor = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_delta_factor = this->_internal_kick_rand_delta_factor();
  ::uint32_t raw_kick_rand_delta_factor;
  memcpy(&raw_kick_rand_delta_factor, &tmp_kick_rand_delta_factor, sizeof(tmp_kick_rand_delta_factor));
  if (raw_kick_rand_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_kick_rand_delta_factor(), target);
  }

  // float extra_stamina_delta_min = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina_delta_min = this->_internal_extra_stamina_delta_min();
  ::uint32_t raw_extra_stamina_delta_min;
  memcpy(&raw_extra_stamina_delta_min, &tmp_extra_stamina_delta_min, sizeof(tmp_extra_stamina_delta_min));
  if (raw_extra_stamina_delta_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        18, this->_internal_extra_stamina_delta_min(), target);
  }

  // float extra_stamina_delta_max = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina_delta_max = this->_internal_extra_stamina_delta_max();
  ::uint32_t raw_extra_stamina_delta_max;
  memcpy(&raw_extra_stamina_delta_max, &tmp_extra_stamina_delta_max, sizeof(tmp_extra_stamina_delta_max));
  if (raw_extra_stamina_delta_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_extra_stamina_delta_max(), target);
  }

  // float effort_max_delta_factor = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_max_delta_factor = this->_internal_effort_max_delta_factor();
  ::uint32_t raw_effort_max_delta_factor;
  memcpy(&raw_effort_max_delta_factor, &tmp_effort_max_delta_factor, sizeof(tmp_effort_max_delta_factor));
  if (raw_effort_max_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        20, this->_internal_effort_max_delta_factor(), target);
  }

  // float effort_min_delta_factor = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min_delta_factor = this->_internal_effort_min_delta_factor();
  ::uint32_t raw_effort_min_delta_factor;
  memcpy(&raw_effort_min_delta_factor, &tmp_effort_min_delta_factor, sizeof(tmp_effort_min_delta_factor));
  if (raw_effort_min_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_effort_min_delta_factor(), target);
  }

  // int32 random_seed = 22;
  if (this->_internal_random_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_random_seed(), target);
  }

  // float new_dash_power_rate_delta_min = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_dash_power_rate_delta_min = this->_internal_new_dash_power_rate_delta_min();
  ::uint32_t raw_new_dash_power_rate_delta_min;
  memcpy(&raw_new_dash_power_rate_delta_min, &tmp_new_dash_power_rate_delta_min, sizeof(tmp_new_dash_power_rate_delta_min));
  if (raw_new_dash_power_rate_delta_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        23, this->_internal_new_dash_power_rate_delta_min(), target);
  }

  // float new_dash_power_rate_delta_max = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_dash_power_rate_delta_max = this->_internal_new_dash_power_rate_delta_max();
  ::uint32_t raw_new_dash_power_rate_delta_max;
  memcpy(&raw_new_dash_power_rate_delta_max, &tmp_new_dash_power_rate_delta_max, sizeof(tmp_new_dash_power_rate_delta_max));
  if (raw_new_dash_power_rate_delta_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        24, this->_internal_new_dash_power_rate_delta_max(), target);
  }

  // float new_stamina_inc_max_delta_factor = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_stamina_inc_max_delta_factor = this->_internal_new_stamina_inc_max_delta_factor();
  ::uint32_t raw_new_stamina_inc_max_delta_factor;
  memcpy(&raw_new_stamina_inc_max_delta_factor, &tmp_new_stamina_inc_max_delta_factor, sizeof(tmp_new_stamina_inc_max_delta_factor));
  if (raw_new_stamina_inc_max_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        25, this->_internal_new_stamina_inc_max_delta_factor(), target);
  }

  // float kick_power_rate_delta_min = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate_delta_min = this->_internal_kick_power_rate_delta_min();
  ::uint32_t raw_kick_power_rate_delta_min;
  memcpy(&raw_kick_power_rate_delta_min, &tmp_kick_power_rate_delta_min, sizeof(tmp_kick_power_rate_delta_min));
  if (raw_kick_power_rate_delta_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        26, this->_internal_kick_power_rate_delta_min(), target);
  }

  // float kick_power_rate_delta_max = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate_delta_max = this->_internal_kick_power_rate_delta_max();
  ::uint32_t raw_kick_power_rate_delta_max;
  memcpy(&raw_kick_power_rate_delta_max, &tmp_kick_power_rate_delta_max, sizeof(tmp_kick_power_rate_delta_max));
  if (raw_kick_power_rate_delta_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        27, this->_internal_kick_power_rate_delta_max(), target);
  }

  // float foul_detect_probability_delta_factor = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability_delta_factor = this->_internal_foul_detect_probability_delta_factor();
  ::uint32_t raw_foul_detect_probability_delta_factor;
  memcpy(&raw_foul_detect_probability_delta_factor, &tmp_foul_detect_probability_delta_factor, sizeof(tmp_foul_detect_probability_delta_factor));
  if (raw_foul_detect_probability_delta_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        28, this->_internal_foul_detect_probability_delta_factor(), target);
  }

  // float catchable_area_l_stretch_min = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch_min = this->_internal_catchable_area_l_stretch_min();
  ::uint32_t raw_catchable_area_l_stretch_min;
  memcpy(&raw_catchable_area_l_stretch_min, &tmp_catchable_area_l_stretch_min, sizeof(tmp_catchable_area_l_stretch_min));
  if (raw_catchable_area_l_stretch_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        29, this->_internal_catchable_area_l_stretch_min(), target);
  }

  // float catchable_area_l_stretch_max = 30;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch_max = this->_internal_catchable_area_l_stretch_max();
  ::uint32_t raw_catchable_area_l_stretch_max;
  memcpy(&raw_catchable_area_l_stretch_max, &tmp_catchable_area_l_stretch_max, sizeof(tmp_catchable_area_l_stretch_max));
  if (raw_catchable_area_l_stretch_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        30, this->_internal_catchable_area_l_stretch_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PlayerParam)
  return target;
}

::size_t PlayerParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PlayerParam)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_agent_type());
  }

  // int32 player_types = 2;
  if (this->_internal_player_types() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_player_types());
  }

  // int32 subs_max = 3;
  if (this->_internal_subs_max() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_subs_max());
  }

  // int32 pt_max = 4;
  if (this->_internal_pt_max() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pt_max());
  }

  // bool allow_mult_default_type = 5;
  if (this->_internal_allow_mult_default_type() != 0) {
    total_size += 2;
  }

  // float player_speed_max_delta_min = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_delta_min = this->_internal_player_speed_max_delta_min();
  ::uint32_t raw_player_speed_max_delta_min;
  memcpy(&raw_player_speed_max_delta_min, &tmp_player_speed_max_delta_min, sizeof(tmp_player_speed_max_delta_min));
  if (raw_player_speed_max_delta_min != 0) {
    total_size += 5;
  }

  // float player_speed_max_delta_max = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_delta_max = this->_internal_player_speed_max_delta_max();
  ::uint32_t raw_player_speed_max_delta_max;
  memcpy(&raw_player_speed_max_delta_max, &tmp_player_speed_max_delta_max, sizeof(tmp_player_speed_max_delta_max));
  if (raw_player_speed_max_delta_max != 0) {
    total_size += 5;
  }

  // float stamina_inc_max_delta_factor = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max_delta_factor = this->_internal_stamina_inc_max_delta_factor();
  ::uint32_t raw_stamina_inc_max_delta_factor;
  memcpy(&raw_stamina_inc_max_delta_factor, &tmp_stamina_inc_max_delta_factor, sizeof(tmp_stamina_inc_max_delta_factor));
  if (raw_stamina_inc_max_delta_factor != 0) {
    total_size += 5;
  }

  // float player_decay_delta_min = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay_delta_min = this->_internal_player_decay_delta_min();
  ::uint32_t raw_player_decay_delta_min;
  memcpy(&raw_player_decay_delta_min, &tmp_player_decay_delta_min, sizeof(tmp_player_decay_delta_min));
  if (raw_player_decay_delta_min != 0) {
    total_size += 5;
  }

  // float player_decay_delta_max = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay_delta_max = this->_internal_player_decay_delta_max();
  ::uint32_t raw_player_decay_delta_max;
  memcpy(&raw_player_decay_delta_max, &tmp_player_decay_delta_max, sizeof(tmp_player_decay_delta_max));
  if (raw_player_decay_delta_max != 0) {
    total_size += 5;
  }

  // float inertia_moment_delta_factor = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment_delta_factor = this->_internal_inertia_moment_delta_factor();
  ::uint32_t raw_inertia_moment_delta_factor;
  memcpy(&raw_inertia_moment_delta_factor, &tmp_inertia_moment_delta_factor, sizeof(tmp_inertia_moment_delta_factor));
  if (raw_inertia_moment_delta_factor != 0) {
    total_size += 5;
  }

  // float dash_power_rate_delta_min = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate_delta_min = this->_internal_dash_power_rate_delta_min();
  ::uint32_t raw_dash_power_rate_delta_min;
  memcpy(&raw_dash_power_rate_delta_min, &tmp_dash_power_rate_delta_min, sizeof(tmp_dash_power_rate_delta_min));
  if (raw_dash_power_rate_delta_min != 0) {
    total_size += 5;
  }

  // float dash_power_rate_delta_max = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate_delta_max = this->_internal_dash_power_rate_delta_max();
  ::uint32_t raw_dash_power_rate_delta_max;
  memcpy(&raw_dash_power_rate_delta_max, &tmp_dash_power_rate_delta_max, sizeof(tmp_dash_power_rate_delta_max));
  if (raw_dash_power_rate_delta_max != 0) {
    total_size += 5;
  }

  // float player_size_delta_factor = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size_delta_factor = this->_internal_player_size_delta_factor();
  ::uint32_t raw_player_size_delta_factor;
  memcpy(&raw_player_size_delta_factor, &tmp_player_size_delta_factor, sizeof(tmp_player_size_delta_factor));
  if (raw_player_size_delta_factor != 0) {
    total_size += 5;
  }

  // float kickable_margin_delta_min = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin_delta_min = this->_internal_kickable_margin_delta_min();
  ::uint32_t raw_kickable_margin_delta_min;
  memcpy(&raw_kickable_margin_delta_min, &tmp_kickable_margin_delta_min, sizeof(tmp_kickable_margin_delta_min));
  if (raw_kickable_margin_delta_min != 0) {
    total_size += 5;
  }

  // float kickable_margin_delta_max = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin_delta_max = this->_internal_kickable_margin_delta_max();
  ::uint32_t raw_kickable_margin_delta_max;
  memcpy(&raw_kickable_margin_delta_max, &tmp_kickable_margin_delta_max, sizeof(tmp_kickable_margin_delta_max));
  if (raw_kickable_margin_delta_max != 0) {
    total_size += 6;
  }

  // float kick_rand_delta_factor = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_delta_factor = this->_internal_kick_rand_delta_factor();
  ::uint32_t raw_kick_rand_delta_factor;
  memcpy(&raw_kick_rand_delta_factor, &tmp_kick_rand_delta_factor, sizeof(tmp_kick_rand_delta_factor));
  if (raw_kick_rand_delta_factor != 0) {
    total_size += 6;
  }

  // float extra_stamina_delta_min = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina_delta_min = this->_internal_extra_stamina_delta_min();
  ::uint32_t raw_extra_stamina_delta_min;
  memcpy(&raw_extra_stamina_delta_min, &tmp_extra_stamina_delta_min, sizeof(tmp_extra_stamina_delta_min));
  if (raw_extra_stamina_delta_min != 0) {
    total_size += 6;
  }

  // float extra_stamina_delta_max = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina_delta_max = this->_internal_extra_stamina_delta_max();
  ::uint32_t raw_extra_stamina_delta_max;
  memcpy(&raw_extra_stamina_delta_max, &tmp_extra_stamina_delta_max, sizeof(tmp_extra_stamina_delta_max));
  if (raw_extra_stamina_delta_max != 0) {
    total_size += 6;
  }

  // float effort_max_delta_factor = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_max_delta_factor = this->_internal_effort_max_delta_factor();
  ::uint32_t raw_effort_max_delta_factor;
  memcpy(&raw_effort_max_delta_factor, &tmp_effort_max_delta_factor, sizeof(tmp_effort_max_delta_factor));
  if (raw_effort_max_delta_factor != 0) {
    total_size += 6;
  }

  // float effort_min_delta_factor = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min_delta_factor = this->_internal_effort_min_delta_factor();
  ::uint32_t raw_effort_min_delta_factor;
  memcpy(&raw_effort_min_delta_factor, &tmp_effort_min_delta_factor, sizeof(tmp_effort_min_delta_factor));
  if (raw_effort_min_delta_factor != 0) {
    total_size += 6;
  }

  // int32 random_seed = 22;
  if (this->_internal_random_seed() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_random_seed());
  }

  // float new_dash_power_rate_delta_min = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_dash_power_rate_delta_min = this->_internal_new_dash_power_rate_delta_min();
  ::uint32_t raw_new_dash_power_rate_delta_min;
  memcpy(&raw_new_dash_power_rate_delta_min, &tmp_new_dash_power_rate_delta_min, sizeof(tmp_new_dash_power_rate_delta_min));
  if (raw_new_dash_power_rate_delta_min != 0) {
    total_size += 6;
  }

  // float new_dash_power_rate_delta_max = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_dash_power_rate_delta_max = this->_internal_new_dash_power_rate_delta_max();
  ::uint32_t raw_new_dash_power_rate_delta_max;
  memcpy(&raw_new_dash_power_rate_delta_max, &tmp_new_dash_power_rate_delta_max, sizeof(tmp_new_dash_power_rate_delta_max));
  if (raw_new_dash_power_rate_delta_max != 0) {
    total_size += 6;
  }

  // float new_stamina_inc_max_delta_factor = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_stamina_inc_max_delta_factor = this->_internal_new_stamina_inc_max_delta_factor();
  ::uint32_t raw_new_stamina_inc_max_delta_factor;
  memcpy(&raw_new_stamina_inc_max_delta_factor, &tmp_new_stamina_inc_max_delta_factor, sizeof(tmp_new_stamina_inc_max_delta_factor));
  if (raw_new_stamina_inc_max_delta_factor != 0) {
    total_size += 6;
  }

  // float kick_power_rate_delta_min = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate_delta_min = this->_internal_kick_power_rate_delta_min();
  ::uint32_t raw_kick_power_rate_delta_min;
  memcpy(&raw_kick_power_rate_delta_min, &tmp_kick_power_rate_delta_min, sizeof(tmp_kick_power_rate_delta_min));
  if (raw_kick_power_rate_delta_min != 0) {
    total_size += 6;
  }

  // float kick_power_rate_delta_max = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate_delta_max = this->_internal_kick_power_rate_delta_max();
  ::uint32_t raw_kick_power_rate_delta_max;
  memcpy(&raw_kick_power_rate_delta_max, &tmp_kick_power_rate_delta_max, sizeof(tmp_kick_power_rate_delta_max));
  if (raw_kick_power_rate_delta_max != 0) {
    total_size += 6;
  }

  // float foul_detect_probability_delta_factor = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability_delta_factor = this->_internal_foul_detect_probability_delta_factor();
  ::uint32_t raw_foul_detect_probability_delta_factor;
  memcpy(&raw_foul_detect_probability_delta_factor, &tmp_foul_detect_probability_delta_factor, sizeof(tmp_foul_detect_probability_delta_factor));
  if (raw_foul_detect_probability_delta_factor != 0) {
    total_size += 6;
  }

  // float catchable_area_l_stretch_min = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch_min = this->_internal_catchable_area_l_stretch_min();
  ::uint32_t raw_catchable_area_l_stretch_min;
  memcpy(&raw_catchable_area_l_stretch_min, &tmp_catchable_area_l_stretch_min, sizeof(tmp_catchable_area_l_stretch_min));
  if (raw_catchable_area_l_stretch_min != 0) {
    total_size += 6;
  }

  // float catchable_area_l_stretch_max = 30;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch_max = this->_internal_catchable_area_l_stretch_max();
  ::uint32_t raw_catchable_area_l_stretch_max;
  memcpy(&raw_catchable_area_l_stretch_max, &tmp_catchable_area_l_stretch_max, sizeof(tmp_catchable_area_l_stretch_max));
  if (raw_catchable_area_l_stretch_max != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerParam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerParam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerParam::GetClassData() const { return &_class_data_; }


void PlayerParam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerParam*>(&to_msg);
  auto& from = static_cast<const PlayerParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PlayerParam)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_agent_type() != 0) {
    _this->_internal_set_agent_type(from._internal_agent_type());
  }
  if (from._internal_player_types() != 0) {
    _this->_internal_set_player_types(from._internal_player_types());
  }
  if (from._internal_subs_max() != 0) {
    _this->_internal_set_subs_max(from._internal_subs_max());
  }
  if (from._internal_pt_max() != 0) {
    _this->_internal_set_pt_max(from._internal_pt_max());
  }
  if (from._internal_allow_mult_default_type() != 0) {
    _this->_internal_set_allow_mult_default_type(from._internal_allow_mult_default_type());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_delta_min = from._internal_player_speed_max_delta_min();
  ::uint32_t raw_player_speed_max_delta_min;
  memcpy(&raw_player_speed_max_delta_min, &tmp_player_speed_max_delta_min, sizeof(tmp_player_speed_max_delta_min));
  if (raw_player_speed_max_delta_min != 0) {
    _this->_internal_set_player_speed_max_delta_min(from._internal_player_speed_max_delta_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max_delta_max = from._internal_player_speed_max_delta_max();
  ::uint32_t raw_player_speed_max_delta_max;
  memcpy(&raw_player_speed_max_delta_max, &tmp_player_speed_max_delta_max, sizeof(tmp_player_speed_max_delta_max));
  if (raw_player_speed_max_delta_max != 0) {
    _this->_internal_set_player_speed_max_delta_max(from._internal_player_speed_max_delta_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max_delta_factor = from._internal_stamina_inc_max_delta_factor();
  ::uint32_t raw_stamina_inc_max_delta_factor;
  memcpy(&raw_stamina_inc_max_delta_factor, &tmp_stamina_inc_max_delta_factor, sizeof(tmp_stamina_inc_max_delta_factor));
  if (raw_stamina_inc_max_delta_factor != 0) {
    _this->_internal_set_stamina_inc_max_delta_factor(from._internal_stamina_inc_max_delta_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay_delta_min = from._internal_player_decay_delta_min();
  ::uint32_t raw_player_decay_delta_min;
  memcpy(&raw_player_decay_delta_min, &tmp_player_decay_delta_min, sizeof(tmp_player_decay_delta_min));
  if (raw_player_decay_delta_min != 0) {
    _this->_internal_set_player_decay_delta_min(from._internal_player_decay_delta_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay_delta_max = from._internal_player_decay_delta_max();
  ::uint32_t raw_player_decay_delta_max;
  memcpy(&raw_player_decay_delta_max, &tmp_player_decay_delta_max, sizeof(tmp_player_decay_delta_max));
  if (raw_player_decay_delta_max != 0) {
    _this->_internal_set_player_decay_delta_max(from._internal_player_decay_delta_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment_delta_factor = from._internal_inertia_moment_delta_factor();
  ::uint32_t raw_inertia_moment_delta_factor;
  memcpy(&raw_inertia_moment_delta_factor, &tmp_inertia_moment_delta_factor, sizeof(tmp_inertia_moment_delta_factor));
  if (raw_inertia_moment_delta_factor != 0) {
    _this->_internal_set_inertia_moment_delta_factor(from._internal_inertia_moment_delta_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate_delta_min = from._internal_dash_power_rate_delta_min();
  ::uint32_t raw_dash_power_rate_delta_min;
  memcpy(&raw_dash_power_rate_delta_min, &tmp_dash_power_rate_delta_min, sizeof(tmp_dash_power_rate_delta_min));
  if (raw_dash_power_rate_delta_min != 0) {
    _this->_internal_set_dash_power_rate_delta_min(from._internal_dash_power_rate_delta_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate_delta_max = from._internal_dash_power_rate_delta_max();
  ::uint32_t raw_dash_power_rate_delta_max;
  memcpy(&raw_dash_power_rate_delta_max, &tmp_dash_power_rate_delta_max, sizeof(tmp_dash_power_rate_delta_max));
  if (raw_dash_power_rate_delta_max != 0) {
    _this->_internal_set_dash_power_rate_delta_max(from._internal_dash_power_rate_delta_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size_delta_factor = from._internal_player_size_delta_factor();
  ::uint32_t raw_player_size_delta_factor;
  memcpy(&raw_player_size_delta_factor, &tmp_player_size_delta_factor, sizeof(tmp_player_size_delta_factor));
  if (raw_player_size_delta_factor != 0) {
    _this->_internal_set_player_size_delta_factor(from._internal_player_size_delta_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin_delta_min = from._internal_kickable_margin_delta_min();
  ::uint32_t raw_kickable_margin_delta_min;
  memcpy(&raw_kickable_margin_delta_min, &tmp_kickable_margin_delta_min, sizeof(tmp_kickable_margin_delta_min));
  if (raw_kickable_margin_delta_min != 0) {
    _this->_internal_set_kickable_margin_delta_min(from._internal_kickable_margin_delta_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin_delta_max = from._internal_kickable_margin_delta_max();
  ::uint32_t raw_kickable_margin_delta_max;
  memcpy(&raw_kickable_margin_delta_max, &tmp_kickable_margin_delta_max, sizeof(tmp_kickable_margin_delta_max));
  if (raw_kickable_margin_delta_max != 0) {
    _this->_internal_set_kickable_margin_delta_max(from._internal_kickable_margin_delta_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand_delta_factor = from._internal_kick_rand_delta_factor();
  ::uint32_t raw_kick_rand_delta_factor;
  memcpy(&raw_kick_rand_delta_factor, &tmp_kick_rand_delta_factor, sizeof(tmp_kick_rand_delta_factor));
  if (raw_kick_rand_delta_factor != 0) {
    _this->_internal_set_kick_rand_delta_factor(from._internal_kick_rand_delta_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina_delta_min = from._internal_extra_stamina_delta_min();
  ::uint32_t raw_extra_stamina_delta_min;
  memcpy(&raw_extra_stamina_delta_min, &tmp_extra_stamina_delta_min, sizeof(tmp_extra_stamina_delta_min));
  if (raw_extra_stamina_delta_min != 0) {
    _this->_internal_set_extra_stamina_delta_min(from._internal_extra_stamina_delta_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina_delta_max = from._internal_extra_stamina_delta_max();
  ::uint32_t raw_extra_stamina_delta_max;
  memcpy(&raw_extra_stamina_delta_max, &tmp_extra_stamina_delta_max, sizeof(tmp_extra_stamina_delta_max));
  if (raw_extra_stamina_delta_max != 0) {
    _this->_internal_set_extra_stamina_delta_max(from._internal_extra_stamina_delta_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_max_delta_factor = from._internal_effort_max_delta_factor();
  ::uint32_t raw_effort_max_delta_factor;
  memcpy(&raw_effort_max_delta_factor, &tmp_effort_max_delta_factor, sizeof(tmp_effort_max_delta_factor));
  if (raw_effort_max_delta_factor != 0) {
    _this->_internal_set_effort_max_delta_factor(from._internal_effort_max_delta_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min_delta_factor = from._internal_effort_min_delta_factor();
  ::uint32_t raw_effort_min_delta_factor;
  memcpy(&raw_effort_min_delta_factor, &tmp_effort_min_delta_factor, sizeof(tmp_effort_min_delta_factor));
  if (raw_effort_min_delta_factor != 0) {
    _this->_internal_set_effort_min_delta_factor(from._internal_effort_min_delta_factor());
  }
  if (from._internal_random_seed() != 0) {
    _this->_internal_set_random_seed(from._internal_random_seed());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_dash_power_rate_delta_min = from._internal_new_dash_power_rate_delta_min();
  ::uint32_t raw_new_dash_power_rate_delta_min;
  memcpy(&raw_new_dash_power_rate_delta_min, &tmp_new_dash_power_rate_delta_min, sizeof(tmp_new_dash_power_rate_delta_min));
  if (raw_new_dash_power_rate_delta_min != 0) {
    _this->_internal_set_new_dash_power_rate_delta_min(from._internal_new_dash_power_rate_delta_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_dash_power_rate_delta_max = from._internal_new_dash_power_rate_delta_max();
  ::uint32_t raw_new_dash_power_rate_delta_max;
  memcpy(&raw_new_dash_power_rate_delta_max, &tmp_new_dash_power_rate_delta_max, sizeof(tmp_new_dash_power_rate_delta_max));
  if (raw_new_dash_power_rate_delta_max != 0) {
    _this->_internal_set_new_dash_power_rate_delta_max(from._internal_new_dash_power_rate_delta_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_new_stamina_inc_max_delta_factor = from._internal_new_stamina_inc_max_delta_factor();
  ::uint32_t raw_new_stamina_inc_max_delta_factor;
  memcpy(&raw_new_stamina_inc_max_delta_factor, &tmp_new_stamina_inc_max_delta_factor, sizeof(tmp_new_stamina_inc_max_delta_factor));
  if (raw_new_stamina_inc_max_delta_factor != 0) {
    _this->_internal_set_new_stamina_inc_max_delta_factor(from._internal_new_stamina_inc_max_delta_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate_delta_min = from._internal_kick_power_rate_delta_min();
  ::uint32_t raw_kick_power_rate_delta_min;
  memcpy(&raw_kick_power_rate_delta_min, &tmp_kick_power_rate_delta_min, sizeof(tmp_kick_power_rate_delta_min));
  if (raw_kick_power_rate_delta_min != 0) {
    _this->_internal_set_kick_power_rate_delta_min(from._internal_kick_power_rate_delta_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate_delta_max = from._internal_kick_power_rate_delta_max();
  ::uint32_t raw_kick_power_rate_delta_max;
  memcpy(&raw_kick_power_rate_delta_max, &tmp_kick_power_rate_delta_max, sizeof(tmp_kick_power_rate_delta_max));
  if (raw_kick_power_rate_delta_max != 0) {
    _this->_internal_set_kick_power_rate_delta_max(from._internal_kick_power_rate_delta_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability_delta_factor = from._internal_foul_detect_probability_delta_factor();
  ::uint32_t raw_foul_detect_probability_delta_factor;
  memcpy(&raw_foul_detect_probability_delta_factor, &tmp_foul_detect_probability_delta_factor, sizeof(tmp_foul_detect_probability_delta_factor));
  if (raw_foul_detect_probability_delta_factor != 0) {
    _this->_internal_set_foul_detect_probability_delta_factor(from._internal_foul_detect_probability_delta_factor());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch_min = from._internal_catchable_area_l_stretch_min();
  ::uint32_t raw_catchable_area_l_stretch_min;
  memcpy(&raw_catchable_area_l_stretch_min, &tmp_catchable_area_l_stretch_min, sizeof(tmp_catchable_area_l_stretch_min));
  if (raw_catchable_area_l_stretch_min != 0) {
    _this->_internal_set_catchable_area_l_stretch_min(from._internal_catchable_area_l_stretch_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch_max = from._internal_catchable_area_l_stretch_max();
  ::uint32_t raw_catchable_area_l_stretch_max;
  memcpy(&raw_catchable_area_l_stretch_max, &tmp_catchable_area_l_stretch_max, sizeof(tmp_catchable_area_l_stretch_max));
  if (raw_catchable_area_l_stretch_max != 0) {
    _this->_internal_set_catchable_area_l_stretch_max(from._internal_catchable_area_l_stretch_max());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerParam::CopyFrom(const PlayerParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PlayerParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerParam::IsInitialized() const {
  return true;
}

void PlayerParam::InternalSwap(PlayerParam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerParam, _impl_.catchable_area_l_stretch_max_)
      + sizeof(PlayerParam::_impl_.catchable_area_l_stretch_max_)
      - PROTOBUF_FIELD_OFFSET(PlayerParam, _impl_.agent_type_)>(
          reinterpret_cast<char*>(&_impl_.agent_type_),
          reinterpret_cast<char*>(&other->_impl_.agent_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[123]);
}
// ===================================================================

class PlayerType::_Internal {
 public:
};

PlayerType::PlayerType(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PlayerType)
}
PlayerType::PlayerType(const PlayerType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PlayerType)
}

inline void PlayerType::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.agent_type_) { 0 }

    , decltype(_impl_.id_) { 0 }

    , decltype(_impl_.stamina_inc_max_) { 0 }

    , decltype(_impl_.player_decay_) { 0 }

    , decltype(_impl_.inertia_moment_) { 0 }

    , decltype(_impl_.dash_power_rate_) { 0 }

    , decltype(_impl_.player_size_) { 0 }

    , decltype(_impl_.kickable_margin_) { 0 }

    , decltype(_impl_.kick_rand_) { 0 }

    , decltype(_impl_.extra_stamina_) { 0 }

    , decltype(_impl_.effort_max_) { 0 }

    , decltype(_impl_.effort_min_) { 0 }

    , decltype(_impl_.kick_power_rate_) { 0 }

    , decltype(_impl_.foul_detect_probability_) { 0 }

    , decltype(_impl_.catchable_area_l_stretch_) { 0 }

    , decltype(_impl_.unum_far_length_) { 0 }

    , decltype(_impl_.unum_too_far_length_) { 0 }

    , decltype(_impl_.team_far_length_) { 0 }

    , decltype(_impl_.team_too_far_length_) { 0 }

    , decltype(_impl_.player_max_observation_length_) { 0 }

    , decltype(_impl_.ball_vel_far_length_) { 0 }

    , decltype(_impl_.ball_vel_too_far_length_) { 0 }

    , decltype(_impl_.ball_max_observation_length_) { 0 }

    , decltype(_impl_.flag_chg_far_length_) { 0 }

    , decltype(_impl_.flag_chg_too_far_length_) { 0 }

    , decltype(_impl_.flag_max_observation_length_) { 0 }

    , decltype(_impl_.kickable_area_) { 0 }

    , decltype(_impl_.reliable_catchable_dist_) { 0 }

    , decltype(_impl_.max_catchable_dist_) { 0 }

    , decltype(_impl_.real_speed_max_) { 0 }

    , decltype(_impl_.player_speed_max2_) { 0 }

    , decltype(_impl_.real_speed_max2_) { 0 }

    , decltype(_impl_.cycles_to_reach_max_speed_) { 0 }

    , decltype(_impl_.player_speed_max_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerType::~PlayerType() {
  // @@protoc_insertion_point(destructor:protos.PlayerType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerType::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerType::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PlayerType)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.agent_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.player_speed_max_) -
      reinterpret_cast<char*>(&_impl_.agent_type_)) + sizeof(_impl_.player_speed_max_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.AgentType agent_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_agent_type(static_cast<::protos::AgentType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina_inc_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.stamina_inc_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_decay = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.player_decay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float inertia_moment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.inertia_moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power_rate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.dash_power_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _impl_.player_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kickable_margin = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.kickable_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_rand = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.kick_rand_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float extra_stamina = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.extra_stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_max = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 93)) {
          _impl_.effort_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float effort_min = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.effort_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kick_power_rate = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.kick_power_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float foul_detect_probability = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 117)) {
          _impl_.foul_detect_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catchable_area_l_stretch = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _impl_.catchable_area_l_stretch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float unum_far_length = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.unum_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float unum_too_far_length = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.unum_too_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float team_far_length = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 149)) {
          _impl_.team_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float team_too_far_length = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.team_too_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_max_observation_length = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 165)) {
          _impl_.player_max_observation_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_vel_far_length = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.ball_vel_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_vel_too_far_length = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 181)) {
          _impl_.ball_vel_too_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float ball_max_observation_length = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.ball_max_observation_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float flag_chg_far_length = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.flag_chg_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float flag_chg_too_far_length = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.flag_chg_too_far_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float flag_max_observation_length = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.flag_max_observation_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float kickable_area = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.kickable_area_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float reliable_catchable_dist = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.reliable_catchable_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_catchable_dist = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.max_catchable_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float real_speed_max = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 245)) {
          _impl_.real_speed_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_speed_max2 = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 253)) {
          _impl_.player_speed_max2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float real_speed_max2 = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 5)) {
          _impl_.real_speed_max2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 cycles_to_reach_max_speed = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.cycles_to_reach_max_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float player_speed_max = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.player_speed_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PlayerType::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PlayerType)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_agent_type(), target);
  }

  // int32 id = 2;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_id(), target);
  }

  // float stamina_inc_max = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max = this->_internal_stamina_inc_max();
  ::uint32_t raw_stamina_inc_max;
  memcpy(&raw_stamina_inc_max, &tmp_stamina_inc_max, sizeof(tmp_stamina_inc_max));
  if (raw_stamina_inc_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_stamina_inc_max(), target);
  }

  // float player_decay = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay = this->_internal_player_decay();
  ::uint32_t raw_player_decay;
  memcpy(&raw_player_decay, &tmp_player_decay, sizeof(tmp_player_decay));
  if (raw_player_decay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_player_decay(), target);
  }

  // float inertia_moment = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment = this->_internal_inertia_moment();
  ::uint32_t raw_inertia_moment;
  memcpy(&raw_inertia_moment, &tmp_inertia_moment, sizeof(tmp_inertia_moment));
  if (raw_inertia_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_inertia_moment(), target);
  }

  // float dash_power_rate = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate = this->_internal_dash_power_rate();
  ::uint32_t raw_dash_power_rate;
  memcpy(&raw_dash_power_rate, &tmp_dash_power_rate, sizeof(tmp_dash_power_rate));
  if (raw_dash_power_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_dash_power_rate(), target);
  }

  // float player_size = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size = this->_internal_player_size();
  ::uint32_t raw_player_size;
  memcpy(&raw_player_size, &tmp_player_size, sizeof(tmp_player_size));
  if (raw_player_size != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_player_size(), target);
  }

  // float kickable_margin = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin = this->_internal_kickable_margin();
  ::uint32_t raw_kickable_margin;
  memcpy(&raw_kickable_margin, &tmp_kickable_margin, sizeof(tmp_kickable_margin));
  if (raw_kickable_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_kickable_margin(), target);
  }

  // float kick_rand = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand = this->_internal_kick_rand();
  ::uint32_t raw_kick_rand;
  memcpy(&raw_kick_rand, &tmp_kick_rand, sizeof(tmp_kick_rand));
  if (raw_kick_rand != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_kick_rand(), target);
  }

  // float extra_stamina = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina = this->_internal_extra_stamina();
  ::uint32_t raw_extra_stamina;
  memcpy(&raw_extra_stamina, &tmp_extra_stamina, sizeof(tmp_extra_stamina));
  if (raw_extra_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_extra_stamina(), target);
  }

  // float effort_max = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_max = this->_internal_effort_max();
  ::uint32_t raw_effort_max;
  memcpy(&raw_effort_max, &tmp_effort_max, sizeof(tmp_effort_max));
  if (raw_effort_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_effort_max(), target);
  }

  // float effort_min = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min = this->_internal_effort_min();
  ::uint32_t raw_effort_min;
  memcpy(&raw_effort_min, &tmp_effort_min, sizeof(tmp_effort_min));
  if (raw_effort_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_effort_min(), target);
  }

  // float kick_power_rate = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate = this->_internal_kick_power_rate();
  ::uint32_t raw_kick_power_rate;
  memcpy(&raw_kick_power_rate, &tmp_kick_power_rate, sizeof(tmp_kick_power_rate));
  if (raw_kick_power_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_kick_power_rate(), target);
  }

  // float foul_detect_probability = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability = this->_internal_foul_detect_probability();
  ::uint32_t raw_foul_detect_probability;
  memcpy(&raw_foul_detect_probability, &tmp_foul_detect_probability, sizeof(tmp_foul_detect_probability));
  if (raw_foul_detect_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_foul_detect_probability(), target);
  }

  // float catchable_area_l_stretch = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch = this->_internal_catchable_area_l_stretch();
  ::uint32_t raw_catchable_area_l_stretch;
  memcpy(&raw_catchable_area_l_stretch, &tmp_catchable_area_l_stretch, sizeof(tmp_catchable_area_l_stretch));
  if (raw_catchable_area_l_stretch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_catchable_area_l_stretch(), target);
  }

  // float unum_far_length = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_unum_far_length = this->_internal_unum_far_length();
  ::uint32_t raw_unum_far_length;
  memcpy(&raw_unum_far_length, &tmp_unum_far_length, sizeof(tmp_unum_far_length));
  if (raw_unum_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_unum_far_length(), target);
  }

  // float unum_too_far_length = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_unum_too_far_length = this->_internal_unum_too_far_length();
  ::uint32_t raw_unum_too_far_length;
  memcpy(&raw_unum_too_far_length, &tmp_unum_too_far_length, sizeof(tmp_unum_too_far_length));
  if (raw_unum_too_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_unum_too_far_length(), target);
  }

  // float team_far_length = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_team_far_length = this->_internal_team_far_length();
  ::uint32_t raw_team_far_length;
  memcpy(&raw_team_far_length, &tmp_team_far_length, sizeof(tmp_team_far_length));
  if (raw_team_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        18, this->_internal_team_far_length(), target);
  }

  // float team_too_far_length = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_team_too_far_length = this->_internal_team_too_far_length();
  ::uint32_t raw_team_too_far_length;
  memcpy(&raw_team_too_far_length, &tmp_team_too_far_length, sizeof(tmp_team_too_far_length));
  if (raw_team_too_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_team_too_far_length(), target);
  }

  // float player_max_observation_length = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_max_observation_length = this->_internal_player_max_observation_length();
  ::uint32_t raw_player_max_observation_length;
  memcpy(&raw_player_max_observation_length, &tmp_player_max_observation_length, sizeof(tmp_player_max_observation_length));
  if (raw_player_max_observation_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        20, this->_internal_player_max_observation_length(), target);
  }

  // float ball_vel_far_length = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_vel_far_length = this->_internal_ball_vel_far_length();
  ::uint32_t raw_ball_vel_far_length;
  memcpy(&raw_ball_vel_far_length, &tmp_ball_vel_far_length, sizeof(tmp_ball_vel_far_length));
  if (raw_ball_vel_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_ball_vel_far_length(), target);
  }

  // float ball_vel_too_far_length = 22;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_vel_too_far_length = this->_internal_ball_vel_too_far_length();
  ::uint32_t raw_ball_vel_too_far_length;
  memcpy(&raw_ball_vel_too_far_length, &tmp_ball_vel_too_far_length, sizeof(tmp_ball_vel_too_far_length));
  if (raw_ball_vel_too_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        22, this->_internal_ball_vel_too_far_length(), target);
  }

  // float ball_max_observation_length = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_max_observation_length = this->_internal_ball_max_observation_length();
  ::uint32_t raw_ball_max_observation_length;
  memcpy(&raw_ball_max_observation_length, &tmp_ball_max_observation_length, sizeof(tmp_ball_max_observation_length));
  if (raw_ball_max_observation_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        23, this->_internal_ball_max_observation_length(), target);
  }

  // float flag_chg_far_length = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_chg_far_length = this->_internal_flag_chg_far_length();
  ::uint32_t raw_flag_chg_far_length;
  memcpy(&raw_flag_chg_far_length, &tmp_flag_chg_far_length, sizeof(tmp_flag_chg_far_length));
  if (raw_flag_chg_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        24, this->_internal_flag_chg_far_length(), target);
  }

  // float flag_chg_too_far_length = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_chg_too_far_length = this->_internal_flag_chg_too_far_length();
  ::uint32_t raw_flag_chg_too_far_length;
  memcpy(&raw_flag_chg_too_far_length, &tmp_flag_chg_too_far_length, sizeof(tmp_flag_chg_too_far_length));
  if (raw_flag_chg_too_far_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        25, this->_internal_flag_chg_too_far_length(), target);
  }

  // float flag_max_observation_length = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_max_observation_length = this->_internal_flag_max_observation_length();
  ::uint32_t raw_flag_max_observation_length;
  memcpy(&raw_flag_max_observation_length, &tmp_flag_max_observation_length, sizeof(tmp_flag_max_observation_length));
  if (raw_flag_max_observation_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        26, this->_internal_flag_max_observation_length(), target);
  }

  // float kickable_area = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_area = this->_internal_kickable_area();
  ::uint32_t raw_kickable_area;
  memcpy(&raw_kickable_area, &tmp_kickable_area, sizeof(tmp_kickable_area));
  if (raw_kickable_area != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        27, this->_internal_kickable_area(), target);
  }

  // float reliable_catchable_dist = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_reliable_catchable_dist = this->_internal_reliable_catchable_dist();
  ::uint32_t raw_reliable_catchable_dist;
  memcpy(&raw_reliable_catchable_dist, &tmp_reliable_catchable_dist, sizeof(tmp_reliable_catchable_dist));
  if (raw_reliable_catchable_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        28, this->_internal_reliable_catchable_dist(), target);
  }

  // float max_catchable_dist = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_catchable_dist = this->_internal_max_catchable_dist();
  ::uint32_t raw_max_catchable_dist;
  memcpy(&raw_max_catchable_dist, &tmp_max_catchable_dist, sizeof(tmp_max_catchable_dist));
  if (raw_max_catchable_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        29, this->_internal_max_catchable_dist(), target);
  }

  // float real_speed_max = 30;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max = this->_internal_real_speed_max();
  ::uint32_t raw_real_speed_max;
  memcpy(&raw_real_speed_max, &tmp_real_speed_max, sizeof(tmp_real_speed_max));
  if (raw_real_speed_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        30, this->_internal_real_speed_max(), target);
  }

  // float player_speed_max2 = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max2 = this->_internal_player_speed_max2();
  ::uint32_t raw_player_speed_max2;
  memcpy(&raw_player_speed_max2, &tmp_player_speed_max2, sizeof(tmp_player_speed_max2));
  if (raw_player_speed_max2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        31, this->_internal_player_speed_max2(), target);
  }

  // float real_speed_max2 = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max2 = this->_internal_real_speed_max2();
  ::uint32_t raw_real_speed_max2;
  memcpy(&raw_real_speed_max2, &tmp_real_speed_max2, sizeof(tmp_real_speed_max2));
  if (raw_real_speed_max2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        32, this->_internal_real_speed_max2(), target);
  }

  // int32 cycles_to_reach_max_speed = 33;
  if (this->_internal_cycles_to_reach_max_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        33, this->_internal_cycles_to_reach_max_speed(), target);
  }

  // float player_speed_max = 34;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max = this->_internal_player_speed_max();
  ::uint32_t raw_player_speed_max;
  memcpy(&raw_player_speed_max, &tmp_player_speed_max, sizeof(tmp_player_speed_max));
  if (raw_player_speed_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        34, this->_internal_player_speed_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PlayerType)
  return target;
}

::size_t PlayerType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PlayerType)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.AgentType agent_type = 1;
  if (this->_internal_agent_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_agent_type());
  }

  // int32 id = 2;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // float stamina_inc_max = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max = this->_internal_stamina_inc_max();
  ::uint32_t raw_stamina_inc_max;
  memcpy(&raw_stamina_inc_max, &tmp_stamina_inc_max, sizeof(tmp_stamina_inc_max));
  if (raw_stamina_inc_max != 0) {
    total_size += 5;
  }

  // float player_decay = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay = this->_internal_player_decay();
  ::uint32_t raw_player_decay;
  memcpy(&raw_player_decay, &tmp_player_decay, sizeof(tmp_player_decay));
  if (raw_player_decay != 0) {
    total_size += 5;
  }

  // float inertia_moment = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment = this->_internal_inertia_moment();
  ::uint32_t raw_inertia_moment;
  memcpy(&raw_inertia_moment, &tmp_inertia_moment, sizeof(tmp_inertia_moment));
  if (raw_inertia_moment != 0) {
    total_size += 5;
  }

  // float dash_power_rate = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate = this->_internal_dash_power_rate();
  ::uint32_t raw_dash_power_rate;
  memcpy(&raw_dash_power_rate, &tmp_dash_power_rate, sizeof(tmp_dash_power_rate));
  if (raw_dash_power_rate != 0) {
    total_size += 5;
  }

  // float player_size = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size = this->_internal_player_size();
  ::uint32_t raw_player_size;
  memcpy(&raw_player_size, &tmp_player_size, sizeof(tmp_player_size));
  if (raw_player_size != 0) {
    total_size += 5;
  }

  // float kickable_margin = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin = this->_internal_kickable_margin();
  ::uint32_t raw_kickable_margin;
  memcpy(&raw_kickable_margin, &tmp_kickable_margin, sizeof(tmp_kickable_margin));
  if (raw_kickable_margin != 0) {
    total_size += 5;
  }

  // float kick_rand = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand = this->_internal_kick_rand();
  ::uint32_t raw_kick_rand;
  memcpy(&raw_kick_rand, &tmp_kick_rand, sizeof(tmp_kick_rand));
  if (raw_kick_rand != 0) {
    total_size += 5;
  }

  // float extra_stamina = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina = this->_internal_extra_stamina();
  ::uint32_t raw_extra_stamina;
  memcpy(&raw_extra_stamina, &tmp_extra_stamina, sizeof(tmp_extra_stamina));
  if (raw_extra_stamina != 0) {
    total_size += 5;
  }

  // float effort_max = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_max = this->_internal_effort_max();
  ::uint32_t raw_effort_max;
  memcpy(&raw_effort_max, &tmp_effort_max, sizeof(tmp_effort_max));
  if (raw_effort_max != 0) {
    total_size += 5;
  }

  // float effort_min = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min = this->_internal_effort_min();
  ::uint32_t raw_effort_min;
  memcpy(&raw_effort_min, &tmp_effort_min, sizeof(tmp_effort_min));
  if (raw_effort_min != 0) {
    total_size += 5;
  }

  // float kick_power_rate = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate = this->_internal_kick_power_rate();
  ::uint32_t raw_kick_power_rate;
  memcpy(&raw_kick_power_rate, &tmp_kick_power_rate, sizeof(tmp_kick_power_rate));
  if (raw_kick_power_rate != 0) {
    total_size += 5;
  }

  // float foul_detect_probability = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability = this->_internal_foul_detect_probability();
  ::uint32_t raw_foul_detect_probability;
  memcpy(&raw_foul_detect_probability, &tmp_foul_detect_probability, sizeof(tmp_foul_detect_probability));
  if (raw_foul_detect_probability != 0) {
    total_size += 5;
  }

  // float catchable_area_l_stretch = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch = this->_internal_catchable_area_l_stretch();
  ::uint32_t raw_catchable_area_l_stretch;
  memcpy(&raw_catchable_area_l_stretch, &tmp_catchable_area_l_stretch, sizeof(tmp_catchable_area_l_stretch));
  if (raw_catchable_area_l_stretch != 0) {
    total_size += 5;
  }

  // float unum_far_length = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_unum_far_length = this->_internal_unum_far_length();
  ::uint32_t raw_unum_far_length;
  memcpy(&raw_unum_far_length, &tmp_unum_far_length, sizeof(tmp_unum_far_length));
  if (raw_unum_far_length != 0) {
    total_size += 6;
  }

  // float unum_too_far_length = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_unum_too_far_length = this->_internal_unum_too_far_length();
  ::uint32_t raw_unum_too_far_length;
  memcpy(&raw_unum_too_far_length, &tmp_unum_too_far_length, sizeof(tmp_unum_too_far_length));
  if (raw_unum_too_far_length != 0) {
    total_size += 6;
  }

  // float team_far_length = 18;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_team_far_length = this->_internal_team_far_length();
  ::uint32_t raw_team_far_length;
  memcpy(&raw_team_far_length, &tmp_team_far_length, sizeof(tmp_team_far_length));
  if (raw_team_far_length != 0) {
    total_size += 6;
  }

  // float team_too_far_length = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_team_too_far_length = this->_internal_team_too_far_length();
  ::uint32_t raw_team_too_far_length;
  memcpy(&raw_team_too_far_length, &tmp_team_too_far_length, sizeof(tmp_team_too_far_length));
  if (raw_team_too_far_length != 0) {
    total_size += 6;
  }

  // float player_max_observation_length = 20;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_max_observation_length = this->_internal_player_max_observation_length();
  ::uint32_t raw_player_max_observation_length;
  memcpy(&raw_player_max_observation_length, &tmp_player_max_observation_length, sizeof(tmp_player_max_observation_length));
  if (raw_player_max_observation_length != 0) {
    total_size += 6;
  }

  // float ball_vel_far_length = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_vel_far_length = this->_internal_ball_vel_far_length();
  ::uint32_t raw_ball_vel_far_length;
  memcpy(&raw_ball_vel_far_length, &tmp_ball_vel_far_length, sizeof(tmp_ball_vel_far_length));
  if (raw_ball_vel_far_length != 0) {
    total_size += 6;
  }

  // float ball_vel_too_far_length = 22;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_vel_too_far_length = this->_internal_ball_vel_too_far_length();
  ::uint32_t raw_ball_vel_too_far_length;
  memcpy(&raw_ball_vel_too_far_length, &tmp_ball_vel_too_far_length, sizeof(tmp_ball_vel_too_far_length));
  if (raw_ball_vel_too_far_length != 0) {
    total_size += 6;
  }

  // float ball_max_observation_length = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_max_observation_length = this->_internal_ball_max_observation_length();
  ::uint32_t raw_ball_max_observation_length;
  memcpy(&raw_ball_max_observation_length, &tmp_ball_max_observation_length, sizeof(tmp_ball_max_observation_length));
  if (raw_ball_max_observation_length != 0) {
    total_size += 6;
  }

  // float flag_chg_far_length = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_chg_far_length = this->_internal_flag_chg_far_length();
  ::uint32_t raw_flag_chg_far_length;
  memcpy(&raw_flag_chg_far_length, &tmp_flag_chg_far_length, sizeof(tmp_flag_chg_far_length));
  if (raw_flag_chg_far_length != 0) {
    total_size += 6;
  }

  // float flag_chg_too_far_length = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_chg_too_far_length = this->_internal_flag_chg_too_far_length();
  ::uint32_t raw_flag_chg_too_far_length;
  memcpy(&raw_flag_chg_too_far_length, &tmp_flag_chg_too_far_length, sizeof(tmp_flag_chg_too_far_length));
  if (raw_flag_chg_too_far_length != 0) {
    total_size += 6;
  }

  // float flag_max_observation_length = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_max_observation_length = this->_internal_flag_max_observation_length();
  ::uint32_t raw_flag_max_observation_length;
  memcpy(&raw_flag_max_observation_length, &tmp_flag_max_observation_length, sizeof(tmp_flag_max_observation_length));
  if (raw_flag_max_observation_length != 0) {
    total_size += 6;
  }

  // float kickable_area = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_area = this->_internal_kickable_area();
  ::uint32_t raw_kickable_area;
  memcpy(&raw_kickable_area, &tmp_kickable_area, sizeof(tmp_kickable_area));
  if (raw_kickable_area != 0) {
    total_size += 6;
  }

  // float reliable_catchable_dist = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_reliable_catchable_dist = this->_internal_reliable_catchable_dist();
  ::uint32_t raw_reliable_catchable_dist;
  memcpy(&raw_reliable_catchable_dist, &tmp_reliable_catchable_dist, sizeof(tmp_reliable_catchable_dist));
  if (raw_reliable_catchable_dist != 0) {
    total_size += 6;
  }

  // float max_catchable_dist = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_catchable_dist = this->_internal_max_catchable_dist();
  ::uint32_t raw_max_catchable_dist;
  memcpy(&raw_max_catchable_dist, &tmp_max_catchable_dist, sizeof(tmp_max_catchable_dist));
  if (raw_max_catchable_dist != 0) {
    total_size += 6;
  }

  // float real_speed_max = 30;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max = this->_internal_real_speed_max();
  ::uint32_t raw_real_speed_max;
  memcpy(&raw_real_speed_max, &tmp_real_speed_max, sizeof(tmp_real_speed_max));
  if (raw_real_speed_max != 0) {
    total_size += 6;
  }

  // float player_speed_max2 = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max2 = this->_internal_player_speed_max2();
  ::uint32_t raw_player_speed_max2;
  memcpy(&raw_player_speed_max2, &tmp_player_speed_max2, sizeof(tmp_player_speed_max2));
  if (raw_player_speed_max2 != 0) {
    total_size += 6;
  }

  // float real_speed_max2 = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max2 = this->_internal_real_speed_max2();
  ::uint32_t raw_real_speed_max2;
  memcpy(&raw_real_speed_max2, &tmp_real_speed_max2, sizeof(tmp_real_speed_max2));
  if (raw_real_speed_max2 != 0) {
    total_size += 6;
  }

  // int32 cycles_to_reach_max_speed = 33;
  if (this->_internal_cycles_to_reach_max_speed() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_cycles_to_reach_max_speed());
  }

  // float player_speed_max = 34;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max = this->_internal_player_speed_max();
  ::uint32_t raw_player_speed_max;
  memcpy(&raw_player_speed_max, &tmp_player_speed_max, sizeof(tmp_player_speed_max));
  if (raw_player_speed_max != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerType::GetClassData() const { return &_class_data_; }


void PlayerType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerType*>(&to_msg);
  auto& from = static_cast<const PlayerType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PlayerType)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_agent_type() != 0) {
    _this->_internal_set_agent_type(from._internal_agent_type());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_inc_max = from._internal_stamina_inc_max();
  ::uint32_t raw_stamina_inc_max;
  memcpy(&raw_stamina_inc_max, &tmp_stamina_inc_max, sizeof(tmp_stamina_inc_max));
  if (raw_stamina_inc_max != 0) {
    _this->_internal_set_stamina_inc_max(from._internal_stamina_inc_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_decay = from._internal_player_decay();
  ::uint32_t raw_player_decay;
  memcpy(&raw_player_decay, &tmp_player_decay, sizeof(tmp_player_decay));
  if (raw_player_decay != 0) {
    _this->_internal_set_player_decay(from._internal_player_decay());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_inertia_moment = from._internal_inertia_moment();
  ::uint32_t raw_inertia_moment;
  memcpy(&raw_inertia_moment, &tmp_inertia_moment, sizeof(tmp_inertia_moment));
  if (raw_inertia_moment != 0) {
    _this->_internal_set_inertia_moment(from._internal_inertia_moment());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power_rate = from._internal_dash_power_rate();
  ::uint32_t raw_dash_power_rate;
  memcpy(&raw_dash_power_rate, &tmp_dash_power_rate, sizeof(tmp_dash_power_rate));
  if (raw_dash_power_rate != 0) {
    _this->_internal_set_dash_power_rate(from._internal_dash_power_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_size = from._internal_player_size();
  ::uint32_t raw_player_size;
  memcpy(&raw_player_size, &tmp_player_size, sizeof(tmp_player_size));
  if (raw_player_size != 0) {
    _this->_internal_set_player_size(from._internal_player_size());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_margin = from._internal_kickable_margin();
  ::uint32_t raw_kickable_margin;
  memcpy(&raw_kickable_margin, &tmp_kickable_margin, sizeof(tmp_kickable_margin));
  if (raw_kickable_margin != 0) {
    _this->_internal_set_kickable_margin(from._internal_kickable_margin());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_rand = from._internal_kick_rand();
  ::uint32_t raw_kick_rand;
  memcpy(&raw_kick_rand, &tmp_kick_rand, sizeof(tmp_kick_rand));
  if (raw_kick_rand != 0) {
    _this->_internal_set_kick_rand(from._internal_kick_rand());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_extra_stamina = from._internal_extra_stamina();
  ::uint32_t raw_extra_stamina;
  memcpy(&raw_extra_stamina, &tmp_extra_stamina, sizeof(tmp_extra_stamina));
  if (raw_extra_stamina != 0) {
    _this->_internal_set_extra_stamina(from._internal_extra_stamina());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_max = from._internal_effort_max();
  ::uint32_t raw_effort_max;
  memcpy(&raw_effort_max, &tmp_effort_max, sizeof(tmp_effort_max));
  if (raw_effort_max != 0) {
    _this->_internal_set_effort_max(from._internal_effort_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_effort_min = from._internal_effort_min();
  ::uint32_t raw_effort_min;
  memcpy(&raw_effort_min, &tmp_effort_min, sizeof(tmp_effort_min));
  if (raw_effort_min != 0) {
    _this->_internal_set_effort_min(from._internal_effort_min());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kick_power_rate = from._internal_kick_power_rate();
  ::uint32_t raw_kick_power_rate;
  memcpy(&raw_kick_power_rate, &tmp_kick_power_rate, sizeof(tmp_kick_power_rate));
  if (raw_kick_power_rate != 0) {
    _this->_internal_set_kick_power_rate(from._internal_kick_power_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_detect_probability = from._internal_foul_detect_probability();
  ::uint32_t raw_foul_detect_probability;
  memcpy(&raw_foul_detect_probability, &tmp_foul_detect_probability, sizeof(tmp_foul_detect_probability));
  if (raw_foul_detect_probability != 0) {
    _this->_internal_set_foul_detect_probability(from._internal_foul_detect_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catchable_area_l_stretch = from._internal_catchable_area_l_stretch();
  ::uint32_t raw_catchable_area_l_stretch;
  memcpy(&raw_catchable_area_l_stretch, &tmp_catchable_area_l_stretch, sizeof(tmp_catchable_area_l_stretch));
  if (raw_catchable_area_l_stretch != 0) {
    _this->_internal_set_catchable_area_l_stretch(from._internal_catchable_area_l_stretch());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_unum_far_length = from._internal_unum_far_length();
  ::uint32_t raw_unum_far_length;
  memcpy(&raw_unum_far_length, &tmp_unum_far_length, sizeof(tmp_unum_far_length));
  if (raw_unum_far_length != 0) {
    _this->_internal_set_unum_far_length(from._internal_unum_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_unum_too_far_length = from._internal_unum_too_far_length();
  ::uint32_t raw_unum_too_far_length;
  memcpy(&raw_unum_too_far_length, &tmp_unum_too_far_length, sizeof(tmp_unum_too_far_length));
  if (raw_unum_too_far_length != 0) {
    _this->_internal_set_unum_too_far_length(from._internal_unum_too_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_team_far_length = from._internal_team_far_length();
  ::uint32_t raw_team_far_length;
  memcpy(&raw_team_far_length, &tmp_team_far_length, sizeof(tmp_team_far_length));
  if (raw_team_far_length != 0) {
    _this->_internal_set_team_far_length(from._internal_team_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_team_too_far_length = from._internal_team_too_far_length();
  ::uint32_t raw_team_too_far_length;
  memcpy(&raw_team_too_far_length, &tmp_team_too_far_length, sizeof(tmp_team_too_far_length));
  if (raw_team_too_far_length != 0) {
    _this->_internal_set_team_too_far_length(from._internal_team_too_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_max_observation_length = from._internal_player_max_observation_length();
  ::uint32_t raw_player_max_observation_length;
  memcpy(&raw_player_max_observation_length, &tmp_player_max_observation_length, sizeof(tmp_player_max_observation_length));
  if (raw_player_max_observation_length != 0) {
    _this->_internal_set_player_max_observation_length(from._internal_player_max_observation_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_vel_far_length = from._internal_ball_vel_far_length();
  ::uint32_t raw_ball_vel_far_length;
  memcpy(&raw_ball_vel_far_length, &tmp_ball_vel_far_length, sizeof(tmp_ball_vel_far_length));
  if (raw_ball_vel_far_length != 0) {
    _this->_internal_set_ball_vel_far_length(from._internal_ball_vel_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_vel_too_far_length = from._internal_ball_vel_too_far_length();
  ::uint32_t raw_ball_vel_too_far_length;
  memcpy(&raw_ball_vel_too_far_length, &tmp_ball_vel_too_far_length, sizeof(tmp_ball_vel_too_far_length));
  if (raw_ball_vel_too_far_length != 0) {
    _this->_internal_set_ball_vel_too_far_length(from._internal_ball_vel_too_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ball_max_observation_length = from._internal_ball_max_observation_length();
  ::uint32_t raw_ball_max_observation_length;
  memcpy(&raw_ball_max_observation_length, &tmp_ball_max_observation_length, sizeof(tmp_ball_max_observation_length));
  if (raw_ball_max_observation_length != 0) {
    _this->_internal_set_ball_max_observation_length(from._internal_ball_max_observation_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_chg_far_length = from._internal_flag_chg_far_length();
  ::uint32_t raw_flag_chg_far_length;
  memcpy(&raw_flag_chg_far_length, &tmp_flag_chg_far_length, sizeof(tmp_flag_chg_far_length));
  if (raw_flag_chg_far_length != 0) {
    _this->_internal_set_flag_chg_far_length(from._internal_flag_chg_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_chg_too_far_length = from._internal_flag_chg_too_far_length();
  ::uint32_t raw_flag_chg_too_far_length;
  memcpy(&raw_flag_chg_too_far_length, &tmp_flag_chg_too_far_length, sizeof(tmp_flag_chg_too_far_length));
  if (raw_flag_chg_too_far_length != 0) {
    _this->_internal_set_flag_chg_too_far_length(from._internal_flag_chg_too_far_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_flag_max_observation_length = from._internal_flag_max_observation_length();
  ::uint32_t raw_flag_max_observation_length;
  memcpy(&raw_flag_max_observation_length, &tmp_flag_max_observation_length, sizeof(tmp_flag_max_observation_length));
  if (raw_flag_max_observation_length != 0) {
    _this->_internal_set_flag_max_observation_length(from._internal_flag_max_observation_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_kickable_area = from._internal_kickable_area();
  ::uint32_t raw_kickable_area;
  memcpy(&raw_kickable_area, &tmp_kickable_area, sizeof(tmp_kickable_area));
  if (raw_kickable_area != 0) {
    _this->_internal_set_kickable_area(from._internal_kickable_area());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_reliable_catchable_dist = from._internal_reliable_catchable_dist();
  ::uint32_t raw_reliable_catchable_dist;
  memcpy(&raw_reliable_catchable_dist, &tmp_reliable_catchable_dist, sizeof(tmp_reliable_catchable_dist));
  if (raw_reliable_catchable_dist != 0) {
    _this->_internal_set_reliable_catchable_dist(from._internal_reliable_catchable_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_catchable_dist = from._internal_max_catchable_dist();
  ::uint32_t raw_max_catchable_dist;
  memcpy(&raw_max_catchable_dist, &tmp_max_catchable_dist, sizeof(tmp_max_catchable_dist));
  if (raw_max_catchable_dist != 0) {
    _this->_internal_set_max_catchable_dist(from._internal_max_catchable_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max = from._internal_real_speed_max();
  ::uint32_t raw_real_speed_max;
  memcpy(&raw_real_speed_max, &tmp_real_speed_max, sizeof(tmp_real_speed_max));
  if (raw_real_speed_max != 0) {
    _this->_internal_set_real_speed_max(from._internal_real_speed_max());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max2 = from._internal_player_speed_max2();
  ::uint32_t raw_player_speed_max2;
  memcpy(&raw_player_speed_max2, &tmp_player_speed_max2, sizeof(tmp_player_speed_max2));
  if (raw_player_speed_max2 != 0) {
    _this->_internal_set_player_speed_max2(from._internal_player_speed_max2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_real_speed_max2 = from._internal_real_speed_max2();
  ::uint32_t raw_real_speed_max2;
  memcpy(&raw_real_speed_max2, &tmp_real_speed_max2, sizeof(tmp_real_speed_max2));
  if (raw_real_speed_max2 != 0) {
    _this->_internal_set_real_speed_max2(from._internal_real_speed_max2());
  }
  if (from._internal_cycles_to_reach_max_speed() != 0) {
    _this->_internal_set_cycles_to_reach_max_speed(from._internal_cycles_to_reach_max_speed());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_player_speed_max = from._internal_player_speed_max();
  ::uint32_t raw_player_speed_max;
  memcpy(&raw_player_speed_max, &tmp_player_speed_max, sizeof(tmp_player_speed_max));
  if (raw_player_speed_max != 0) {
    _this->_internal_set_player_speed_max(from._internal_player_speed_max());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerType::CopyFrom(const PlayerType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PlayerType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerType::IsInitialized() const {
  return true;
}

void PlayerType::InternalSwap(PlayerType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerType, _impl_.player_speed_max_)
      + sizeof(PlayerType::_impl_.player_speed_max_)
      - PROTOBUF_FIELD_OFFSET(PlayerType, _impl_.agent_type_)>(
          reinterpret_cast<char*>(&_impl_.agent_type_),
          reinterpret_cast<char*>(&other->_impl_.agent_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[124]);
}
// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Empty* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Empty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Empty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Empty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Empty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[125]);
}
// ===================================================================

class InitMessageFromServer::_Internal {
 public:
};

InitMessageFromServer::InitMessageFromServer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.InitMessageFromServer)
}
InitMessageFromServer::InitMessageFromServer(const InitMessageFromServer& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  InitMessageFromServer* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.InitMessageFromServer)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InitMessageFromServer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InitMessageFromServer::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata InitMessageFromServer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[126]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protos::Vector2D*
Arena::CreateMaybeMessage< ::protos::Vector2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Vector2D >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Ball*
Arena::CreateMaybeMessage< ::protos::Ball >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Ball >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Player*
Arena::CreateMaybeMessage< ::protos::Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Self*
Arena::CreateMaybeMessage< ::protos::Self >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Self >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptInfo*
Arena::CreateMaybeMessage< ::protos::InterceptInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptTable*
Arena::CreateMaybeMessage< ::protos::InterceptTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptTable >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel_OurPlayersDictEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protos::WorldModel_OurPlayersDictEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel_OurPlayersDictEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel_HeliosHomePositionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel*
Arena::CreateMaybeMessage< ::protos::WorldModel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::State*
Arena::CreateMaybeMessage< ::protos::State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::State >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InitMessage*
Arena::CreateMaybeMessage< ::protos::InitMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InitMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Dash*
Arena::CreateMaybeMessage< ::protos::Dash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Dash >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Turn*
Arena::CreateMaybeMessage< ::protos::Turn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Turn >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Kick*
Arena::CreateMaybeMessage< ::protos::Kick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Kick >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Tackle*
Arena::CreateMaybeMessage< ::protos::Tackle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Tackle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Catch*
Arena::CreateMaybeMessage< ::protos::Catch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Catch >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Move*
Arena::CreateMaybeMessage< ::protos::Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Move >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TurnNeck*
Arena::CreateMaybeMessage< ::protos::TurnNeck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TurnNeck >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::ChangeView*
Arena::CreateMaybeMessage< ::protos::ChangeView >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::ChangeView >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::BallMessage*
Arena::CreateMaybeMessage< ::protos::BallMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::BallMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PassMessage*
Arena::CreateMaybeMessage< ::protos::PassMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PassMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptMessage*
Arena::CreateMaybeMessage< ::protos::InterceptMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::GoalieMessage*
Arena::CreateMaybeMessage< ::protos::GoalieMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::GoalieMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::GoalieAndPlayerMessage*
Arena::CreateMaybeMessage< ::protos::GoalieAndPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::GoalieAndPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::OffsideLineMessage*
Arena::CreateMaybeMessage< ::protos::OffsideLineMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::OffsideLineMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DefenseLineMessage*
Arena::CreateMaybeMessage< ::protos::DefenseLineMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DefenseLineMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WaitRequestMessage*
Arena::CreateMaybeMessage< ::protos::WaitRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WaitRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::SetplayMessage*
Arena::CreateMaybeMessage< ::protos::SetplayMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::SetplayMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PassRequestMessage*
Arena::CreateMaybeMessage< ::protos::PassRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PassRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::StaminaMessage*
Arena::CreateMaybeMessage< ::protos::StaminaMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::StaminaMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::RecoveryMessage*
Arena::CreateMaybeMessage< ::protos::RecoveryMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::RecoveryMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::StaminaCapacityMessage*
Arena::CreateMaybeMessage< ::protos::StaminaCapacityMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::StaminaCapacityMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DribbleMessage*
Arena::CreateMaybeMessage< ::protos::DribbleMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DribbleMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::BallGoalieMessage*
Arena::CreateMaybeMessage< ::protos::BallGoalieMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::BallGoalieMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::OnePlayerMessage*
Arena::CreateMaybeMessage< ::protos::OnePlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::OnePlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TwoPlayerMessage*
Arena::CreateMaybeMessage< ::protos::TwoPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TwoPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::ThreePlayerMessage*
Arena::CreateMaybeMessage< ::protos::ThreePlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::ThreePlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::SelfMessage*
Arena::CreateMaybeMessage< ::protos::SelfMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::SelfMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TeammateMessage*
Arena::CreateMaybeMessage< ::protos::TeammateMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TeammateMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::OpponentMessage*
Arena::CreateMaybeMessage< ::protos::OpponentMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::OpponentMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::BallPlayerMessage*
Arena::CreateMaybeMessage< ::protos::BallPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::BallPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Say*
Arena::CreateMaybeMessage< ::protos::Say >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Say >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PointTo*
Arena::CreateMaybeMessage< ::protos::PointTo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PointTo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PointToOf*
Arena::CreateMaybeMessage< ::protos::PointToOf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PointToOf >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AttentionTo*
Arena::CreateMaybeMessage< ::protos::AttentionTo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AttentionTo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AttentionToOf*
Arena::CreateMaybeMessage< ::protos::AttentionToOf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AttentionToOf >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddText*
Arena::CreateMaybeMessage< ::protos::AddText >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddText >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddPoint*
Arena::CreateMaybeMessage< ::protos::AddPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddLine*
Arena::CreateMaybeMessage< ::protos::AddLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddLine >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddArc*
Arena::CreateMaybeMessage< ::protos::AddArc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddArc >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddCircle*
Arena::CreateMaybeMessage< ::protos::AddCircle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddCircle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddTriangle*
Arena::CreateMaybeMessage< ::protos::AddTriangle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddTriangle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddRectangle*
Arena::CreateMaybeMessage< ::protos::AddRectangle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddRectangle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddSector*
Arena::CreateMaybeMessage< ::protos::AddSector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddSector >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddMessage*
Arena::CreateMaybeMessage< ::protos::AddMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Log*
Arena::CreateMaybeMessage< ::protos::Log >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Log >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DebugClient*
Arena::CreateMaybeMessage< ::protos::DebugClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DebugClient >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_GoToPoint*
Arena::CreateMaybeMessage< ::protos::Body_GoToPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_GoToPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_SmartKick*
Arena::CreateMaybeMessage< ::protos::Body_SmartKick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_SmartKick >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_BeforeKickOff*
Arena::CreateMaybeMessage< ::protos::Bhv_BeforeKickOff >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_BeforeKickOff >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_BodyNeckToBall*
Arena::CreateMaybeMessage< ::protos::Bhv_BodyNeckToBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_BodyNeckToBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_BodyNeckToPoint*
Arena::CreateMaybeMessage< ::protos::Bhv_BodyNeckToPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_BodyNeckToPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_Emergency*
Arena::CreateMaybeMessage< ::protos::Bhv_Emergency >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_Emergency >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_GoToPointLookBall*
Arena::CreateMaybeMessage< ::protos::Bhv_GoToPointLookBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_GoToPointLookBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_NeckBodyToBall*
Arena::CreateMaybeMessage< ::protos::Bhv_NeckBodyToBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_NeckBodyToBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_NeckBodyToPoint*
Arena::CreateMaybeMessage< ::protos::Bhv_NeckBodyToPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_NeckBodyToPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Bhv_ScanField*
Arena::CreateMaybeMessage< ::protos::Bhv_ScanField >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Bhv_ScanField >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_AdvanceBall*
Arena::CreateMaybeMessage< ::protos::Body_AdvanceBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_AdvanceBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_ClearBall*
Arena::CreateMaybeMessage< ::protos::Body_ClearBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_ClearBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_Dribble*
Arena::CreateMaybeMessage< ::protos::Body_Dribble >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_Dribble >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_GoToPointDodge*
Arena::CreateMaybeMessage< ::protos::Body_GoToPointDodge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_GoToPointDodge >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_HoldBall*
Arena::CreateMaybeMessage< ::protos::Body_HoldBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_HoldBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_Intercept*
Arena::CreateMaybeMessage< ::protos::Body_Intercept >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_Intercept >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_KickOneStep*
Arena::CreateMaybeMessage< ::protos::Body_KickOneStep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_KickOneStep >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_StopBall*
Arena::CreateMaybeMessage< ::protos::Body_StopBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_StopBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_StopDash*
Arena::CreateMaybeMessage< ::protos::Body_StopDash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_StopDash >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_TackleToPoint*
Arena::CreateMaybeMessage< ::protos::Body_TackleToPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_TackleToPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_TurnToAngle*
Arena::CreateMaybeMessage< ::protos::Body_TurnToAngle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_TurnToAngle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_TurnToBall*
Arena::CreateMaybeMessage< ::protos::Body_TurnToBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_TurnToBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Body_TurnToPoint*
Arena::CreateMaybeMessage< ::protos::Body_TurnToPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Body_TurnToPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Focus_MoveToPoint*
Arena::CreateMaybeMessage< ::protos::Focus_MoveToPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Focus_MoveToPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Focus_Reset*
Arena::CreateMaybeMessage< ::protos::Focus_Reset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Focus_Reset >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_ScanField*
Arena::CreateMaybeMessage< ::protos::Neck_ScanField >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_ScanField >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_ScanPlayers*
Arena::CreateMaybeMessage< ::protos::Neck_ScanPlayers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_ScanPlayers >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToBallAndPlayer*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToBallAndPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToBallAndPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToBallOrScan*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToBallOrScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToBallOrScan >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToBall*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToGoalieOrScan*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToGoalieOrScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToGoalieOrScan >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToLowConfTeammate*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToLowConfTeammate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToLowConfTeammate >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToPlayerOrScan*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToPlayerOrScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToPlayerOrScan >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToPoint*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Neck_TurnToRelative*
Arena::CreateMaybeMessage< ::protos::Neck_TurnToRelative >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Neck_TurnToRelative >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::View_ChangeWidth*
Arena::CreateMaybeMessage< ::protos::View_ChangeWidth >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::View_ChangeWidth >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::View_Normal*
Arena::CreateMaybeMessage< ::protos::View_Normal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::View_Normal >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::View_Synch*
Arena::CreateMaybeMessage< ::protos::View_Synch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::View_Synch >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::View_Wide*
Arena::CreateMaybeMessage< ::protos::View_Wide >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::View_Wide >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosGoalie*
Arena::CreateMaybeMessage< ::protos::HeliosGoalie >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosGoalie >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosGoalieMove*
Arena::CreateMaybeMessage< ::protos::HeliosGoalieMove >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosGoalieMove >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosGoalieKick*
Arena::CreateMaybeMessage< ::protos::HeliosGoalieKick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosGoalieKick >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosShoot*
Arena::CreateMaybeMessage< ::protos::HeliosShoot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosShoot >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosChainAction*
Arena::CreateMaybeMessage< ::protos::HeliosChainAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosChainAction >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosBasicOffensive*
Arena::CreateMaybeMessage< ::protos::HeliosBasicOffensive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosBasicOffensive >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosBasicMove*
Arena::CreateMaybeMessage< ::protos::HeliosBasicMove >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosBasicMove >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosSetPlay*
Arena::CreateMaybeMessage< ::protos::HeliosSetPlay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosSetPlay >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosPenalty*
Arena::CreateMaybeMessage< ::protos::HeliosPenalty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosPenalty >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::HeliosCommunicaion*
Arena::CreateMaybeMessage< ::protos::HeliosCommunicaion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::HeliosCommunicaion >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PlayerAction*
Arena::CreateMaybeMessage< ::protos::PlayerAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PlayerAction >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PlayerActions*
Arena::CreateMaybeMessage< ::protos::PlayerActions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PlayerActions >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::ChangePlayerType*
Arena::CreateMaybeMessage< ::protos::ChangePlayerType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::ChangePlayerType >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoHeliosSubstitute*
Arena::CreateMaybeMessage< ::protos::DoHeliosSubstitute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoHeliosSubstitute >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoHeliosSayPlayerTypes*
Arena::CreateMaybeMessage< ::protos::DoHeliosSayPlayerTypes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoHeliosSayPlayerTypes >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::CoachAction*
Arena::CreateMaybeMessage< ::protos::CoachAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::CoachAction >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::CoachActions*
Arena::CreateMaybeMessage< ::protos::CoachActions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::CoachActions >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoKickOff*
Arena::CreateMaybeMessage< ::protos::DoKickOff >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoKickOff >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoMoveBall*
Arena::CreateMaybeMessage< ::protos::DoMoveBall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoMoveBall >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoMovePlayer*
Arena::CreateMaybeMessage< ::protos::DoMovePlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoMovePlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoRecover*
Arena::CreateMaybeMessage< ::protos::DoRecover >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoRecover >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoChangeMode*
Arena::CreateMaybeMessage< ::protos::DoChangeMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoChangeMode >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DoChangePlayerType*
Arena::CreateMaybeMessage< ::protos::DoChangePlayerType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DoChangePlayerType >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TrainerAction*
Arena::CreateMaybeMessage< ::protos::TrainerAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TrainerAction >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TrainerActions*
Arena::CreateMaybeMessage< ::protos::TrainerActions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TrainerActions >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::ServerParam*
Arena::CreateMaybeMessage< ::protos::ServerParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::ServerParam >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PlayerParam*
Arena::CreateMaybeMessage< ::protos::PlayerParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PlayerParam >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PlayerType*
Arena::CreateMaybeMessage< ::protos::PlayerType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PlayerType >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Empty*
Arena::CreateMaybeMessage< ::protos::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InitMessageFromServer*
Arena::CreateMaybeMessage< ::protos::InitMessageFromServer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InitMessageFromServer >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
