/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef soccer_service_TYPES_H
#define soccer_service_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace soccer {

struct ViewWidth {
  enum type {
    NARROW = 0,
    NORMAL = 1,
    WIDE = 2
  };
};

extern const std::map<int, const char*> _ViewWidth_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ViewWidth::type& val);

std::string to_string(const ViewWidth::type& val);

struct AgentType {
  enum type {
    PlayerT = 0,
    CoachT = 1,
    TrainerT = 2
  };
};

extern const std::map<int, const char*> _AgentType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const AgentType::type& val);

std::string to_string(const AgentType::type& val);

struct Side {
  enum type {
    UNKNOWN = 0,
    LEFT = 1,
    RIGHT = 2
  };
};

extern const std::map<int, const char*> _Side_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Side::type& val);

std::string to_string(const Side::type& val);

struct LoggerLevel {
  enum type {
    NoneLevel = 0,
    SYSTEM = 1,
    SENSOR = 2,
    WORLD = 4,
    ACTION = 8,
    INTERCEPT = 16,
    KICK = 32,
    HOLD = 64,
    DRIBBLE = 128,
    PASS = 256,
    CROSS = 512,
    SHOOT = 1024,
    CLEAR = 2048,
    BLOCK = 4096,
    MARK = 8192,
    POSITIONING = 16384,
    ROLE = 32768,
    TEAM = 65536,
    COMMUNICATION = 131072,
    ANALYZER = 262144,
    ACTION_CHAIN = 524288,
    PLAN = 1048576
  };
};

extern const std::map<int, const char*> _LoggerLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const LoggerLevel::type& val);

std::string to_string(const LoggerLevel::type& val);

struct InterceptActionType {
  enum type {
    UNKNOWN_Intercept_Action_Type = 0,
    OMNI_DASH = 1,
    TURN_FORWARD_DASH = 2,
    TURN_BACKWARD_DASH = 3
  };
};

extern const std::map<int, const char*> _InterceptActionType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const InterceptActionType::type& val);

std::string to_string(const InterceptActionType::type& val);

struct GameModeType {
  enum type {
    BeforeKickOff = 0,
    TimeOver = 1,
    PlayOn = 2,
    KickOff_ = 3,
    KickIn_ = 4,
    FreeKick_ = 5,
    CornerKick_ = 6,
    GoalKick_ = 7,
    AfterGoal_ = 8,
    OffSide_ = 9,
    PenaltyKick_ = 10,
    FirstHalfOver = 11,
    Pause = 12,
    Human = 13,
    FoulCharge_ = 14,
    FoulPush_ = 15,
    FoulMultipleAttacker_ = 16,
    FoulBallOut_ = 17,
    BackPass_ = 18,
    FreeKickFault_ = 19,
    CatchFault_ = 20,
    IndFreeKick_ = 21,
    PenaltySetup_ = 22,
    PenaltyReady_ = 23,
    PenaltyTaken_ = 24,
    PenaltyMiss_ = 25,
    PenaltyScore_ = 26,
    IllegalDefense_ = 27,
    PenaltyOnfield_ = 28,
    PenaltyFoul_ = 29,
    GoalieCatch_ = 30,
    ExtendHalf = 31,
    MODE_MAX = 32
  };
};

extern const std::map<int, const char*> _GameModeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const GameModeType::type& val);

std::string to_string(const GameModeType::type& val);

class RpcVector2D;

class Ball;

class Player;

class Self;

class InterceptInfo;

class InterceptTable;

class WorldModel;

class State;

class InitMessage;

class Dash;

class Turn;

class Kick;

class Tackle;

class Catch;

class Move;

class TurnNeck;

class ChangeView;

class BallMessage;

class PassMessage;

class InterceptMessage;

class GoalieMessage;

class GoalieAndPlayerMessage;

class OffsideLineMessage;

class DefenseLineMessage;

class WaitRequestMessage;

class SetplayMessage;

class PassRequestMessage;

class StaminaMessage;

class RecoveryMessage;

class StaminaCapacityMessage;

class DribbleMessage;

class BallGoalieMessage;

class OnePlayerMessage;

class TwoPlayerMessage;

class ThreePlayerMessage;

class SelfMessage;

class TeammateMessage;

class OpponentMessage;

class BallPlayerMessage;

class Say;

class PointTo;

class PointToOf;

class AttentionTo;

class AttentionToOf;

class AddText;

class AddPoint;

class AddLine;

class AddArc;

class AddCircle;

class AddTriangle;

class AddRectangle;

class AddSector;

class AddMessage;

class Log;

class DebugClient;

class Body_GoToPoint;

class Body_SmartKick;

class Bhv_BeforeKickOff;

class Bhv_BodyNeckToBall;

class Bhv_BodyNeckToPoint;

class Bhv_Emergency;

class Bhv_GoToPointLookBall;

class Bhv_NeckBodyToBall;

class Bhv_NeckBodyToPoint;

class Bhv_ScanField;

class Body_AdvanceBall;

class Body_ClearBall;

class Body_Dribble;

class Body_GoToPointDodge;

class Body_HoldBall;

class Body_Intercept;

class Body_KickOneStep;

class Body_StopBall;

class Body_StopDash;

class Body_TackleToPoint;

class Body_TurnToAngle;

class Body_TurnToBall;

class Body_TurnToPoint;

class Focus_MoveToPoint;

class Focus_Reset;

class Neck_ScanField;

class Neck_ScanPlayers;

class Neck_TurnToBallAndPlayer;

class Neck_TurnToBallOrScan;

class Neck_TurnToBall;

class Neck_TurnToGoalieOrScan;

class Neck_TurnToLowConfTeammate;

class Neck_TurnToPlayerOrScan;

class Neck_TurnToPoint;

class Neck_TurnToRelative;

class View_ChangeWidth;

class View_Normal;

class View_Synch;

class View_Wide;

class HeliosGoalie;

class HeliosGoalieMove;

class HeliosGoalieKick;

class HeliosShoot;

class HeliosChainAction;

class HeliosBasicOffensive;

class HeliosBasicMove;

class HeliosSetPlay;

class HeliosPenalty;

class HeliosCommunicaion;

class PlayerAction;

class PlayerActions;

class ChangePlayerType;

class DoHeliosSubstitute;

class DoHeliosSayPlayerTypes;

class CoachAction;

class CoachActions;

class DoKickOff;

class DoMoveBall;

class DoMovePlayer;

class DoRecover;

class DoChangeMode;

class DoChangePlayerType;

class TrainerAction;

class TrainerActions;

class ServerParam;

class PlayerParam;

class PlayerType;

class Empty;

class RegisterRequest;

class RegisterResponse;

typedef struct _RpcVector2D__isset {
  _RpcVector2D__isset() : x(false), y(false), dist(false), angle(false) {}
  bool x :1;
  bool y :1;
  bool dist :1;
  bool angle :1;
} _RpcVector2D__isset;

class RpcVector2D : public virtual ::apache::thrift::TBase {
 public:

  RpcVector2D(const RpcVector2D&) noexcept;
  RpcVector2D& operator=(const RpcVector2D&) noexcept;
  RpcVector2D() noexcept
              : x(0),
                y(0),
                dist(0),
                angle(0) {
  }

  virtual ~RpcVector2D() noexcept;
  double x;
  double y;
  double dist;
  double angle;

  _RpcVector2D__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_dist(const double val);

  void __set_angle(const double val);

  bool operator == (const RpcVector2D & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (!(dist == rhs.dist))
      return false;
    if (!(angle == rhs.angle))
      return false;
    return true;
  }
  bool operator != (const RpcVector2D &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RpcVector2D & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RpcVector2D &a, RpcVector2D &b);

std::ostream& operator<<(std::ostream& out, const RpcVector2D& obj);

typedef struct _Ball__isset {
  _Ball__isset() : position(false), relative_position(false), seen_position(false), heard_position(false), velocity(false), seen_velocity(false), heard_velocity(false), pos_count(false), seen_pos_count(false), heard_pos_count(false), vel_count(false), seen_vel_count(false), heard_vel_count(false), lost_count(false), ghost_count(false), dist_from_self(false), angle_from_self(false) {}
  bool position :1;
  bool relative_position :1;
  bool seen_position :1;
  bool heard_position :1;
  bool velocity :1;
  bool seen_velocity :1;
  bool heard_velocity :1;
  bool pos_count :1;
  bool seen_pos_count :1;
  bool heard_pos_count :1;
  bool vel_count :1;
  bool seen_vel_count :1;
  bool heard_vel_count :1;
  bool lost_count :1;
  bool ghost_count :1;
  bool dist_from_self :1;
  bool angle_from_self :1;
} _Ball__isset;

class Ball : public virtual ::apache::thrift::TBase {
 public:

  Ball(const Ball&) noexcept;
  Ball& operator=(const Ball&) noexcept;
  Ball() noexcept
       : pos_count(0),
         seen_pos_count(0),
         heard_pos_count(0),
         vel_count(0),
         seen_vel_count(0),
         heard_vel_count(0),
         lost_count(0),
         ghost_count(0),
         dist_from_self(0),
         angle_from_self(0) {
  }

  virtual ~Ball() noexcept;
  RpcVector2D position;
  RpcVector2D relative_position;
  RpcVector2D seen_position;
  RpcVector2D heard_position;
  RpcVector2D velocity;
  RpcVector2D seen_velocity;
  RpcVector2D heard_velocity;
  int32_t pos_count;
  int32_t seen_pos_count;
  int32_t heard_pos_count;
  int32_t vel_count;
  int32_t seen_vel_count;
  int32_t heard_vel_count;
  int32_t lost_count;
  int32_t ghost_count;
  double dist_from_self;
  double angle_from_self;

  _Ball__isset __isset;

  void __set_position(const RpcVector2D& val);

  void __set_relative_position(const RpcVector2D& val);

  void __set_seen_position(const RpcVector2D& val);

  void __set_heard_position(const RpcVector2D& val);

  void __set_velocity(const RpcVector2D& val);

  void __set_seen_velocity(const RpcVector2D& val);

  void __set_heard_velocity(const RpcVector2D& val);

  void __set_pos_count(const int32_t val);

  void __set_seen_pos_count(const int32_t val);

  void __set_heard_pos_count(const int32_t val);

  void __set_vel_count(const int32_t val);

  void __set_seen_vel_count(const int32_t val);

  void __set_heard_vel_count(const int32_t val);

  void __set_lost_count(const int32_t val);

  void __set_ghost_count(const int32_t val);

  void __set_dist_from_self(const double val);

  void __set_angle_from_self(const double val);

  bool operator == (const Ball & rhs) const
  {
    if (!(position == rhs.position))
      return false;
    if (!(relative_position == rhs.relative_position))
      return false;
    if (!(seen_position == rhs.seen_position))
      return false;
    if (!(heard_position == rhs.heard_position))
      return false;
    if (!(velocity == rhs.velocity))
      return false;
    if (!(seen_velocity == rhs.seen_velocity))
      return false;
    if (!(heard_velocity == rhs.heard_velocity))
      return false;
    if (!(pos_count == rhs.pos_count))
      return false;
    if (!(seen_pos_count == rhs.seen_pos_count))
      return false;
    if (!(heard_pos_count == rhs.heard_pos_count))
      return false;
    if (!(vel_count == rhs.vel_count))
      return false;
    if (!(seen_vel_count == rhs.seen_vel_count))
      return false;
    if (!(heard_vel_count == rhs.heard_vel_count))
      return false;
    if (!(lost_count == rhs.lost_count))
      return false;
    if (!(ghost_count == rhs.ghost_count))
      return false;
    if (!(dist_from_self == rhs.dist_from_self))
      return false;
    if (!(angle_from_self == rhs.angle_from_self))
      return false;
    return true;
  }
  bool operator != (const Ball &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Ball & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Ball &a, Ball &b);

std::ostream& operator<<(std::ostream& out, const Ball& obj);

typedef struct _Player__isset {
  _Player__isset() : position(false), seen_position(false), heard_position(false), velocity(false), seen_velocity(false), pos_count(false), seen_pos_count(false), heard_pos_count(false), vel_count(false), seen_vel_count(false), ghost_count(false), dist_from_self(false), angle_from_self(false), id(false), side(false), uniform_number(false), uniform_number_count(false), is_goalie(false), body_direction(false), body_direction_count(false), face_direction(false), face_direction_count(false), point_to_direction(false), point_to_direction_count(false), is_kicking(false), dist_from_ball(false), angle_from_ball(false), ball_reach_steps(false), is_tackling(false), type_id(false) {}
  bool position :1;
  bool seen_position :1;
  bool heard_position :1;
  bool velocity :1;
  bool seen_velocity :1;
  bool pos_count :1;
  bool seen_pos_count :1;
  bool heard_pos_count :1;
  bool vel_count :1;
  bool seen_vel_count :1;
  bool ghost_count :1;
  bool dist_from_self :1;
  bool angle_from_self :1;
  bool id :1;
  bool side :1;
  bool uniform_number :1;
  bool uniform_number_count :1;
  bool is_goalie :1;
  bool body_direction :1;
  bool body_direction_count :1;
  bool face_direction :1;
  bool face_direction_count :1;
  bool point_to_direction :1;
  bool point_to_direction_count :1;
  bool is_kicking :1;
  bool dist_from_ball :1;
  bool angle_from_ball :1;
  bool ball_reach_steps :1;
  bool is_tackling :1;
  bool type_id :1;
} _Player__isset;

class Player : public virtual ::apache::thrift::TBase {
 public:

  Player(const Player&) noexcept;
  Player& operator=(const Player&) noexcept;
  Player() noexcept
         : pos_count(0),
           seen_pos_count(0),
           heard_pos_count(0),
           vel_count(0),
           seen_vel_count(0),
           ghost_count(0),
           dist_from_self(0),
           angle_from_self(0),
           id(0),
           side(static_cast<Side::type>(0)),
           uniform_number(0),
           uniform_number_count(0),
           is_goalie(0),
           body_direction(0),
           body_direction_count(0),
           face_direction(0),
           face_direction_count(0),
           point_to_direction(0),
           point_to_direction_count(0),
           is_kicking(0),
           dist_from_ball(0),
           angle_from_ball(0),
           ball_reach_steps(0),
           is_tackling(0),
           type_id(0) {
  }

  virtual ~Player() noexcept;
  RpcVector2D position;
  RpcVector2D seen_position;
  RpcVector2D heard_position;
  RpcVector2D velocity;
  RpcVector2D seen_velocity;
  int32_t pos_count;
  int32_t seen_pos_count;
  int32_t heard_pos_count;
  int32_t vel_count;
  int32_t seen_vel_count;
  int32_t ghost_count;
  double dist_from_self;
  double angle_from_self;
  int32_t id;
  /**
   * 
   * @see Side
   */
  Side::type side;
  int32_t uniform_number;
  int32_t uniform_number_count;
  bool is_goalie;
  double body_direction;
  int32_t body_direction_count;
  double face_direction;
  int32_t face_direction_count;
  double point_to_direction;
  int32_t point_to_direction_count;
  bool is_kicking;
  double dist_from_ball;
  double angle_from_ball;
  int32_t ball_reach_steps;
  bool is_tackling;
  int32_t type_id;

  _Player__isset __isset;

  void __set_position(const RpcVector2D& val);

  void __set_seen_position(const RpcVector2D& val);

  void __set_heard_position(const RpcVector2D& val);

  void __set_velocity(const RpcVector2D& val);

  void __set_seen_velocity(const RpcVector2D& val);

  void __set_pos_count(const int32_t val);

  void __set_seen_pos_count(const int32_t val);

  void __set_heard_pos_count(const int32_t val);

  void __set_vel_count(const int32_t val);

  void __set_seen_vel_count(const int32_t val);

  void __set_ghost_count(const int32_t val);

  void __set_dist_from_self(const double val);

  void __set_angle_from_self(const double val);

  void __set_id(const int32_t val);

  void __set_side(const Side::type val);

  void __set_uniform_number(const int32_t val);

  void __set_uniform_number_count(const int32_t val);

  void __set_is_goalie(const bool val);

  void __set_body_direction(const double val);

  void __set_body_direction_count(const int32_t val);

  void __set_face_direction(const double val);

  void __set_face_direction_count(const int32_t val);

  void __set_point_to_direction(const double val);

  void __set_point_to_direction_count(const int32_t val);

  void __set_is_kicking(const bool val);

  void __set_dist_from_ball(const double val);

  void __set_angle_from_ball(const double val);

  void __set_ball_reach_steps(const int32_t val);

  void __set_is_tackling(const bool val);

  void __set_type_id(const int32_t val);

  bool operator == (const Player & rhs) const
  {
    if (!(position == rhs.position))
      return false;
    if (!(seen_position == rhs.seen_position))
      return false;
    if (!(heard_position == rhs.heard_position))
      return false;
    if (!(velocity == rhs.velocity))
      return false;
    if (!(seen_velocity == rhs.seen_velocity))
      return false;
    if (!(pos_count == rhs.pos_count))
      return false;
    if (!(seen_pos_count == rhs.seen_pos_count))
      return false;
    if (!(heard_pos_count == rhs.heard_pos_count))
      return false;
    if (!(vel_count == rhs.vel_count))
      return false;
    if (!(seen_vel_count == rhs.seen_vel_count))
      return false;
    if (!(ghost_count == rhs.ghost_count))
      return false;
    if (!(dist_from_self == rhs.dist_from_self))
      return false;
    if (!(angle_from_self == rhs.angle_from_self))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(side == rhs.side))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(uniform_number_count == rhs.uniform_number_count))
      return false;
    if (!(is_goalie == rhs.is_goalie))
      return false;
    if (!(body_direction == rhs.body_direction))
      return false;
    if (!(body_direction_count == rhs.body_direction_count))
      return false;
    if (!(face_direction == rhs.face_direction))
      return false;
    if (!(face_direction_count == rhs.face_direction_count))
      return false;
    if (!(point_to_direction == rhs.point_to_direction))
      return false;
    if (!(point_to_direction_count == rhs.point_to_direction_count))
      return false;
    if (!(is_kicking == rhs.is_kicking))
      return false;
    if (!(dist_from_ball == rhs.dist_from_ball))
      return false;
    if (!(angle_from_ball == rhs.angle_from_ball))
      return false;
    if (!(ball_reach_steps == rhs.ball_reach_steps))
      return false;
    if (!(is_tackling == rhs.is_tackling))
      return false;
    if (!(type_id == rhs.type_id))
      return false;
    return true;
  }
  bool operator != (const Player &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Player & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Player &a, Player &b);

std::ostream& operator<<(std::ostream& out, const Player& obj);

typedef struct _Self__isset {
  _Self__isset() : position(false), seen_position(false), heard_position(false), velocity(false), seen_velocity(false), pos_count(false), seen_pos_count(false), heard_pos_count(false), vel_count(false), seen_vel_count(false), ghost_count(false), id(false), side(false), uniform_number(false), uniform_number_count(false), is_goalie(false), body_direction(false), body_direction_count(false), face_direction(false), face_direction_count(false), point_to_direction(false), point_to_direction_count(false), is_kicking(false), dist_from_ball(false), angle_from_ball(false), ball_reach_steps(false), is_tackling(false), relative_neck_direction(false), stamina(false), is_kickable(false), catch_probability(false), tackle_probability(false), foul_probability(false), view_width(false), type_id(false), kick_rate(false) {}
  bool position :1;
  bool seen_position :1;
  bool heard_position :1;
  bool velocity :1;
  bool seen_velocity :1;
  bool pos_count :1;
  bool seen_pos_count :1;
  bool heard_pos_count :1;
  bool vel_count :1;
  bool seen_vel_count :1;
  bool ghost_count :1;
  bool id :1;
  bool side :1;
  bool uniform_number :1;
  bool uniform_number_count :1;
  bool is_goalie :1;
  bool body_direction :1;
  bool body_direction_count :1;
  bool face_direction :1;
  bool face_direction_count :1;
  bool point_to_direction :1;
  bool point_to_direction_count :1;
  bool is_kicking :1;
  bool dist_from_ball :1;
  bool angle_from_ball :1;
  bool ball_reach_steps :1;
  bool is_tackling :1;
  bool relative_neck_direction :1;
  bool stamina :1;
  bool is_kickable :1;
  bool catch_probability :1;
  bool tackle_probability :1;
  bool foul_probability :1;
  bool view_width :1;
  bool type_id :1;
  bool kick_rate :1;
} _Self__isset;

class Self : public virtual ::apache::thrift::TBase {
 public:

  Self(const Self&) noexcept;
  Self& operator=(const Self&) noexcept;
  Self() noexcept
       : pos_count(0),
         seen_pos_count(0),
         heard_pos_count(0),
         vel_count(0),
         seen_vel_count(0),
         ghost_count(0),
         id(0),
         side(static_cast<Side::type>(0)),
         uniform_number(0),
         uniform_number_count(0),
         is_goalie(0),
         body_direction(0),
         body_direction_count(0),
         face_direction(0),
         face_direction_count(0),
         point_to_direction(0),
         point_to_direction_count(0),
         is_kicking(0),
         dist_from_ball(0),
         angle_from_ball(0),
         ball_reach_steps(0),
         is_tackling(0),
         relative_neck_direction(0),
         stamina(0),
         is_kickable(0),
         catch_probability(0),
         tackle_probability(0),
         foul_probability(0),
         view_width(static_cast<ViewWidth::type>(0)),
         type_id(0),
         kick_rate(0) {
  }

  virtual ~Self() noexcept;
  RpcVector2D position;
  RpcVector2D seen_position;
  RpcVector2D heard_position;
  RpcVector2D velocity;
  RpcVector2D seen_velocity;
  int32_t pos_count;
  int32_t seen_pos_count;
  int32_t heard_pos_count;
  int32_t vel_count;
  int32_t seen_vel_count;
  int32_t ghost_count;
  int32_t id;
  /**
   * 
   * @see Side
   */
  Side::type side;
  int32_t uniform_number;
  int32_t uniform_number_count;
  bool is_goalie;
  double body_direction;
  int32_t body_direction_count;
  double face_direction;
  int32_t face_direction_count;
  double point_to_direction;
  int32_t point_to_direction_count;
  bool is_kicking;
  double dist_from_ball;
  double angle_from_ball;
  int32_t ball_reach_steps;
  bool is_tackling;
  double relative_neck_direction;
  double stamina;
  bool is_kickable;
  double catch_probability;
  double tackle_probability;
  double foul_probability;
  /**
   * 
   * @see ViewWidth
   */
  ViewWidth::type view_width;
  int32_t type_id;
  double kick_rate;

  _Self__isset __isset;

  void __set_position(const RpcVector2D& val);

  void __set_seen_position(const RpcVector2D& val);

  void __set_heard_position(const RpcVector2D& val);

  void __set_velocity(const RpcVector2D& val);

  void __set_seen_velocity(const RpcVector2D& val);

  void __set_pos_count(const int32_t val);

  void __set_seen_pos_count(const int32_t val);

  void __set_heard_pos_count(const int32_t val);

  void __set_vel_count(const int32_t val);

  void __set_seen_vel_count(const int32_t val);

  void __set_ghost_count(const int32_t val);

  void __set_id(const int32_t val);

  void __set_side(const Side::type val);

  void __set_uniform_number(const int32_t val);

  void __set_uniform_number_count(const int32_t val);

  void __set_is_goalie(const bool val);

  void __set_body_direction(const double val);

  void __set_body_direction_count(const int32_t val);

  void __set_face_direction(const double val);

  void __set_face_direction_count(const int32_t val);

  void __set_point_to_direction(const double val);

  void __set_point_to_direction_count(const int32_t val);

  void __set_is_kicking(const bool val);

  void __set_dist_from_ball(const double val);

  void __set_angle_from_ball(const double val);

  void __set_ball_reach_steps(const int32_t val);

  void __set_is_tackling(const bool val);

  void __set_relative_neck_direction(const double val);

  void __set_stamina(const double val);

  void __set_is_kickable(const bool val);

  void __set_catch_probability(const double val);

  void __set_tackle_probability(const double val);

  void __set_foul_probability(const double val);

  void __set_view_width(const ViewWidth::type val);

  void __set_type_id(const int32_t val);

  void __set_kick_rate(const double val);

  bool operator == (const Self & rhs) const
  {
    if (!(position == rhs.position))
      return false;
    if (!(seen_position == rhs.seen_position))
      return false;
    if (!(heard_position == rhs.heard_position))
      return false;
    if (!(velocity == rhs.velocity))
      return false;
    if (!(seen_velocity == rhs.seen_velocity))
      return false;
    if (!(pos_count == rhs.pos_count))
      return false;
    if (!(seen_pos_count == rhs.seen_pos_count))
      return false;
    if (!(heard_pos_count == rhs.heard_pos_count))
      return false;
    if (!(vel_count == rhs.vel_count))
      return false;
    if (!(seen_vel_count == rhs.seen_vel_count))
      return false;
    if (!(ghost_count == rhs.ghost_count))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(side == rhs.side))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(uniform_number_count == rhs.uniform_number_count))
      return false;
    if (!(is_goalie == rhs.is_goalie))
      return false;
    if (!(body_direction == rhs.body_direction))
      return false;
    if (!(body_direction_count == rhs.body_direction_count))
      return false;
    if (!(face_direction == rhs.face_direction))
      return false;
    if (!(face_direction_count == rhs.face_direction_count))
      return false;
    if (!(point_to_direction == rhs.point_to_direction))
      return false;
    if (!(point_to_direction_count == rhs.point_to_direction_count))
      return false;
    if (!(is_kicking == rhs.is_kicking))
      return false;
    if (!(dist_from_ball == rhs.dist_from_ball))
      return false;
    if (!(angle_from_ball == rhs.angle_from_ball))
      return false;
    if (!(ball_reach_steps == rhs.ball_reach_steps))
      return false;
    if (!(is_tackling == rhs.is_tackling))
      return false;
    if (!(relative_neck_direction == rhs.relative_neck_direction))
      return false;
    if (!(stamina == rhs.stamina))
      return false;
    if (!(is_kickable == rhs.is_kickable))
      return false;
    if (!(catch_probability == rhs.catch_probability))
      return false;
    if (!(tackle_probability == rhs.tackle_probability))
      return false;
    if (!(foul_probability == rhs.foul_probability))
      return false;
    if (!(view_width == rhs.view_width))
      return false;
    if (!(type_id == rhs.type_id))
      return false;
    if (!(kick_rate == rhs.kick_rate))
      return false;
    return true;
  }
  bool operator != (const Self &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Self & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Self &a, Self &b);

std::ostream& operator<<(std::ostream& out, const Self& obj);

typedef struct _InterceptInfo__isset {
  _InterceptInfo__isset() : action_type(false), turn_steps(false), turn_angle(false), dash_steps(false), dash_power(false), dash_dir(false), final_self_position(false), final_ball_dist(false), final_stamina(false), value(false) {}
  bool action_type :1;
  bool turn_steps :1;
  bool turn_angle :1;
  bool dash_steps :1;
  bool dash_power :1;
  bool dash_dir :1;
  bool final_self_position :1;
  bool final_ball_dist :1;
  bool final_stamina :1;
  bool value :1;
} _InterceptInfo__isset;

class InterceptInfo : public virtual ::apache::thrift::TBase {
 public:

  InterceptInfo(const InterceptInfo&) noexcept;
  InterceptInfo& operator=(const InterceptInfo&) noexcept;
  InterceptInfo() noexcept
                : action_type(static_cast<InterceptActionType::type>(0)),
                  turn_steps(0),
                  turn_angle(0),
                  dash_steps(0),
                  dash_power(0),
                  dash_dir(0),
                  final_ball_dist(0),
                  final_stamina(0),
                  value(0) {
  }

  virtual ~InterceptInfo() noexcept;
  /**
   * 
   * @see InterceptActionType
   */
  InterceptActionType::type action_type;
  int32_t turn_steps;
  double turn_angle;
  int32_t dash_steps;
  double dash_power;
  double dash_dir;
  RpcVector2D final_self_position;
  double final_ball_dist;
  double final_stamina;
  double value;

  _InterceptInfo__isset __isset;

  void __set_action_type(const InterceptActionType::type val);

  void __set_turn_steps(const int32_t val);

  void __set_turn_angle(const double val);

  void __set_dash_steps(const int32_t val);

  void __set_dash_power(const double val);

  void __set_dash_dir(const double val);

  void __set_final_self_position(const RpcVector2D& val);

  void __set_final_ball_dist(const double val);

  void __set_final_stamina(const double val);

  void __set_value(const double val);

  bool operator == (const InterceptInfo & rhs) const
  {
    if (!(action_type == rhs.action_type))
      return false;
    if (!(turn_steps == rhs.turn_steps))
      return false;
    if (!(turn_angle == rhs.turn_angle))
      return false;
    if (!(dash_steps == rhs.dash_steps))
      return false;
    if (!(dash_power == rhs.dash_power))
      return false;
    if (!(dash_dir == rhs.dash_dir))
      return false;
    if (!(final_self_position == rhs.final_self_position))
      return false;
    if (!(final_ball_dist == rhs.final_ball_dist))
      return false;
    if (!(final_stamina == rhs.final_stamina))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const InterceptInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterceptInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(InterceptInfo &a, InterceptInfo &b);

std::ostream& operator<<(std::ostream& out, const InterceptInfo& obj);

typedef struct _InterceptTable__isset {
  _InterceptTable__isset() : self_reach_steps(false), first_teammate_reach_steps(false), second_teammate_reach_steps(false), first_opponent_reach_steps(false), second_opponent_reach_steps(false), first_teammate_id(false), second_teammate_id(false), first_opponent_id(false), second_opponent_id(false), self_intercept_info(false) {}
  bool self_reach_steps :1;
  bool first_teammate_reach_steps :1;
  bool second_teammate_reach_steps :1;
  bool first_opponent_reach_steps :1;
  bool second_opponent_reach_steps :1;
  bool first_teammate_id :1;
  bool second_teammate_id :1;
  bool first_opponent_id :1;
  bool second_opponent_id :1;
  bool self_intercept_info :1;
} _InterceptTable__isset;

class InterceptTable : public virtual ::apache::thrift::TBase {
 public:

  InterceptTable(const InterceptTable&);
  InterceptTable& operator=(const InterceptTable&);
  InterceptTable() noexcept
                 : self_reach_steps(0),
                   first_teammate_reach_steps(0),
                   second_teammate_reach_steps(0),
                   first_opponent_reach_steps(0),
                   second_opponent_reach_steps(0),
                   first_teammate_id(0),
                   second_teammate_id(0),
                   first_opponent_id(0),
                   second_opponent_id(0) {
  }

  virtual ~InterceptTable() noexcept;
  int32_t self_reach_steps;
  int32_t first_teammate_reach_steps;
  int32_t second_teammate_reach_steps;
  int32_t first_opponent_reach_steps;
  int32_t second_opponent_reach_steps;
  int32_t first_teammate_id;
  int32_t second_teammate_id;
  int32_t first_opponent_id;
  int32_t second_opponent_id;
  std::vector<InterceptInfo>  self_intercept_info;

  _InterceptTable__isset __isset;

  void __set_self_reach_steps(const int32_t val);

  void __set_first_teammate_reach_steps(const int32_t val);

  void __set_second_teammate_reach_steps(const int32_t val);

  void __set_first_opponent_reach_steps(const int32_t val);

  void __set_second_opponent_reach_steps(const int32_t val);

  void __set_first_teammate_id(const int32_t val);

  void __set_second_teammate_id(const int32_t val);

  void __set_first_opponent_id(const int32_t val);

  void __set_second_opponent_id(const int32_t val);

  void __set_self_intercept_info(const std::vector<InterceptInfo> & val);

  bool operator == (const InterceptTable & rhs) const
  {
    if (!(self_reach_steps == rhs.self_reach_steps))
      return false;
    if (!(first_teammate_reach_steps == rhs.first_teammate_reach_steps))
      return false;
    if (!(second_teammate_reach_steps == rhs.second_teammate_reach_steps))
      return false;
    if (!(first_opponent_reach_steps == rhs.first_opponent_reach_steps))
      return false;
    if (!(second_opponent_reach_steps == rhs.second_opponent_reach_steps))
      return false;
    if (!(first_teammate_id == rhs.first_teammate_id))
      return false;
    if (!(second_teammate_id == rhs.second_teammate_id))
      return false;
    if (!(first_opponent_id == rhs.first_opponent_id))
      return false;
    if (!(second_opponent_id == rhs.second_opponent_id))
      return false;
    if (!(self_intercept_info == rhs.self_intercept_info))
      return false;
    return true;
  }
  bool operator != (const InterceptTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterceptTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(InterceptTable &a, InterceptTable &b);

std::ostream& operator<<(std::ostream& out, const InterceptTable& obj);

typedef struct _WorldModel__isset {
  _WorldModel__isset() : intercept_table(false), our_team_name(false), their_team_name(false), our_side(false), last_set_play_start_time(false), myself(false), ball(false), teammates(false), opponents(false), unknowns(false), our_players_dict(false), their_players_dict(false), our_goalie_uniform_number(false), their_goalie_uniform_number(false), offside_line_x(false), offside_line_x_count(false), kickable_teammate_id(false), kickable_opponent_id(false), last_kick_side(false), last_kicker_uniform_number(false), cycle(false), game_mode_type(false), left_team_score(false), right_team_score(false), is_our_set_play(false), is_their_set_play(false), stoped_cycle(false), our_team_score(false), their_team_score(false), is_penalty_kick_mode(false), helios_home_positions(false) {}
  bool intercept_table :1;
  bool our_team_name :1;
  bool their_team_name :1;
  bool our_side :1;
  bool last_set_play_start_time :1;
  bool myself :1;
  bool ball :1;
  bool teammates :1;
  bool opponents :1;
  bool unknowns :1;
  bool our_players_dict :1;
  bool their_players_dict :1;
  bool our_goalie_uniform_number :1;
  bool their_goalie_uniform_number :1;
  bool offside_line_x :1;
  bool offside_line_x_count :1;
  bool kickable_teammate_id :1;
  bool kickable_opponent_id :1;
  bool last_kick_side :1;
  bool last_kicker_uniform_number :1;
  bool cycle :1;
  bool game_mode_type :1;
  bool left_team_score :1;
  bool right_team_score :1;
  bool is_our_set_play :1;
  bool is_their_set_play :1;
  bool stoped_cycle :1;
  bool our_team_score :1;
  bool their_team_score :1;
  bool is_penalty_kick_mode :1;
  bool helios_home_positions :1;
} _WorldModel__isset;

class WorldModel : public virtual ::apache::thrift::TBase {
 public:

  WorldModel(const WorldModel&);
  WorldModel& operator=(const WorldModel&);
  WorldModel() noexcept
             : our_team_name(),
               their_team_name(),
               our_side(static_cast<Side::type>(0)),
               last_set_play_start_time(0),
               our_goalie_uniform_number(0),
               their_goalie_uniform_number(0),
               offside_line_x(0),
               offside_line_x_count(0),
               kickable_teammate_id(0),
               kickable_opponent_id(0),
               last_kick_side(static_cast<Side::type>(0)),
               last_kicker_uniform_number(0),
               cycle(0),
               game_mode_type(static_cast<GameModeType::type>(0)),
               left_team_score(0),
               right_team_score(0),
               is_our_set_play(0),
               is_their_set_play(0),
               stoped_cycle(0),
               our_team_score(0),
               their_team_score(0),
               is_penalty_kick_mode(0) {
  }

  virtual ~WorldModel() noexcept;
  InterceptTable intercept_table;
  std::string our_team_name;
  std::string their_team_name;
  /**
   * 
   * @see Side
   */
  Side::type our_side;
  int32_t last_set_play_start_time;
  Self myself;
  Ball ball;
  std::vector<Player>  teammates;
  std::vector<Player>  opponents;
  std::vector<Player>  unknowns;
  std::map<int32_t, Player>  our_players_dict;
  std::map<int32_t, Player>  their_players_dict;
  int32_t our_goalie_uniform_number;
  int32_t their_goalie_uniform_number;
  double offside_line_x;
  int32_t offside_line_x_count;
  int32_t kickable_teammate_id;
  int32_t kickable_opponent_id;
  /**
   * 
   * @see Side
   */
  Side::type last_kick_side;
  int32_t last_kicker_uniform_number;
  int32_t cycle;
  /**
   * 
   * @see GameModeType
   */
  GameModeType::type game_mode_type;
  int32_t left_team_score;
  int32_t right_team_score;
  bool is_our_set_play;
  bool is_their_set_play;
  int32_t stoped_cycle;
  int32_t our_team_score;
  int32_t their_team_score;
  bool is_penalty_kick_mode;
  std::map<int32_t, RpcVector2D>  helios_home_positions;

  _WorldModel__isset __isset;

  void __set_intercept_table(const InterceptTable& val);

  void __set_our_team_name(const std::string& val);

  void __set_their_team_name(const std::string& val);

  void __set_our_side(const Side::type val);

  void __set_last_set_play_start_time(const int32_t val);

  void __set_myself(const Self& val);

  void __set_ball(const Ball& val);

  void __set_teammates(const std::vector<Player> & val);

  void __set_opponents(const std::vector<Player> & val);

  void __set_unknowns(const std::vector<Player> & val);

  void __set_our_players_dict(const std::map<int32_t, Player> & val);

  void __set_their_players_dict(const std::map<int32_t, Player> & val);

  void __set_our_goalie_uniform_number(const int32_t val);

  void __set_their_goalie_uniform_number(const int32_t val);

  void __set_offside_line_x(const double val);

  void __set_offside_line_x_count(const int32_t val);

  void __set_kickable_teammate_id(const int32_t val);

  void __set_kickable_opponent_id(const int32_t val);

  void __set_last_kick_side(const Side::type val);

  void __set_last_kicker_uniform_number(const int32_t val);

  void __set_cycle(const int32_t val);

  void __set_game_mode_type(const GameModeType::type val);

  void __set_left_team_score(const int32_t val);

  void __set_right_team_score(const int32_t val);

  void __set_is_our_set_play(const bool val);

  void __set_is_their_set_play(const bool val);

  void __set_stoped_cycle(const int32_t val);

  void __set_our_team_score(const int32_t val);

  void __set_their_team_score(const int32_t val);

  void __set_is_penalty_kick_mode(const bool val);

  void __set_helios_home_positions(const std::map<int32_t, RpcVector2D> & val);

  bool operator == (const WorldModel & rhs) const
  {
    if (!(intercept_table == rhs.intercept_table))
      return false;
    if (!(our_team_name == rhs.our_team_name))
      return false;
    if (!(their_team_name == rhs.their_team_name))
      return false;
    if (!(our_side == rhs.our_side))
      return false;
    if (!(last_set_play_start_time == rhs.last_set_play_start_time))
      return false;
    if (!(myself == rhs.myself))
      return false;
    if (!(ball == rhs.ball))
      return false;
    if (!(teammates == rhs.teammates))
      return false;
    if (!(opponents == rhs.opponents))
      return false;
    if (!(unknowns == rhs.unknowns))
      return false;
    if (!(our_players_dict == rhs.our_players_dict))
      return false;
    if (!(their_players_dict == rhs.their_players_dict))
      return false;
    if (!(our_goalie_uniform_number == rhs.our_goalie_uniform_number))
      return false;
    if (!(their_goalie_uniform_number == rhs.their_goalie_uniform_number))
      return false;
    if (!(offside_line_x == rhs.offside_line_x))
      return false;
    if (!(offside_line_x_count == rhs.offside_line_x_count))
      return false;
    if (!(kickable_teammate_id == rhs.kickable_teammate_id))
      return false;
    if (!(kickable_opponent_id == rhs.kickable_opponent_id))
      return false;
    if (!(last_kick_side == rhs.last_kick_side))
      return false;
    if (!(last_kicker_uniform_number == rhs.last_kicker_uniform_number))
      return false;
    if (!(cycle == rhs.cycle))
      return false;
    if (!(game_mode_type == rhs.game_mode_type))
      return false;
    if (!(left_team_score == rhs.left_team_score))
      return false;
    if (!(right_team_score == rhs.right_team_score))
      return false;
    if (!(is_our_set_play == rhs.is_our_set_play))
      return false;
    if (!(is_their_set_play == rhs.is_their_set_play))
      return false;
    if (!(stoped_cycle == rhs.stoped_cycle))
      return false;
    if (!(our_team_score == rhs.our_team_score))
      return false;
    if (!(their_team_score == rhs.their_team_score))
      return false;
    if (!(is_penalty_kick_mode == rhs.is_penalty_kick_mode))
      return false;
    if (!(helios_home_positions == rhs.helios_home_positions))
      return false;
    return true;
  }
  bool operator != (const WorldModel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WorldModel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WorldModel &a, WorldModel &b);

std::ostream& operator<<(std::ostream& out, const WorldModel& obj);

typedef struct _State__isset {
  _State__isset() : agent_type(false), world_model(false), full_world_model(false) {}
  bool agent_type :1;
  bool world_model :1;
  bool full_world_model :1;
} _State__isset;

class State : public virtual ::apache::thrift::TBase {
 public:

  State(const State&);
  State& operator=(const State&);
  State() noexcept
        : agent_type(static_cast<AgentType::type>(0)) {
  }

  virtual ~State() noexcept;
  /**
   * 
   * @see AgentType
   */
  AgentType::type agent_type;
  WorldModel world_model;
  WorldModel full_world_model;

  _State__isset __isset;

  void __set_agent_type(const AgentType::type val);

  void __set_world_model(const WorldModel& val);

  void __set_full_world_model(const WorldModel& val);

  bool operator == (const State & rhs) const
  {
    if (!(agent_type == rhs.agent_type))
      return false;
    if (!(world_model == rhs.world_model))
      return false;
    if (!(full_world_model == rhs.full_world_model))
      return false;
    return true;
  }
  bool operator != (const State &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const State & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(State &a, State &b);

std::ostream& operator<<(std::ostream& out, const State& obj);

typedef struct _InitMessage__isset {
  _InitMessage__isset() : agent_type(false), debug_mode(false) {}
  bool agent_type :1;
  bool debug_mode :1;
} _InitMessage__isset;

class InitMessage : public virtual ::apache::thrift::TBase {
 public:

  InitMessage(const InitMessage&) noexcept;
  InitMessage& operator=(const InitMessage&) noexcept;
  InitMessage() noexcept
              : agent_type(static_cast<AgentType::type>(0)),
                debug_mode(0) {
  }

  virtual ~InitMessage() noexcept;
  /**
   * 
   * @see AgentType
   */
  AgentType::type agent_type;
  bool debug_mode;

  _InitMessage__isset __isset;

  void __set_agent_type(const AgentType::type val);

  void __set_debug_mode(const bool val);

  bool operator == (const InitMessage & rhs) const
  {
    if (!(agent_type == rhs.agent_type))
      return false;
    if (!(debug_mode == rhs.debug_mode))
      return false;
    return true;
  }
  bool operator != (const InitMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InitMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(InitMessage &a, InitMessage &b);

std::ostream& operator<<(std::ostream& out, const InitMessage& obj);

typedef struct _Dash__isset {
  _Dash__isset() : power(false), relative_direction(false) {}
  bool power :1;
  bool relative_direction :1;
} _Dash__isset;

class Dash : public virtual ::apache::thrift::TBase {
 public:

  Dash(const Dash&) noexcept;
  Dash& operator=(const Dash&) noexcept;
  Dash() noexcept
       : power(0),
         relative_direction(0) {
  }

  virtual ~Dash() noexcept;
  double power;
  double relative_direction;

  _Dash__isset __isset;

  void __set_power(const double val);

  void __set_relative_direction(const double val);

  bool operator == (const Dash & rhs) const
  {
    if (!(power == rhs.power))
      return false;
    if (!(relative_direction == rhs.relative_direction))
      return false;
    return true;
  }
  bool operator != (const Dash &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Dash & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Dash &a, Dash &b);

std::ostream& operator<<(std::ostream& out, const Dash& obj);

typedef struct _Turn__isset {
  _Turn__isset() : relative_direction(false) {}
  bool relative_direction :1;
} _Turn__isset;

class Turn : public virtual ::apache::thrift::TBase {
 public:

  Turn(const Turn&) noexcept;
  Turn& operator=(const Turn&) noexcept;
  Turn() noexcept
       : relative_direction(0) {
  }

  virtual ~Turn() noexcept;
  double relative_direction;

  _Turn__isset __isset;

  void __set_relative_direction(const double val);

  bool operator == (const Turn & rhs) const
  {
    if (!(relative_direction == rhs.relative_direction))
      return false;
    return true;
  }
  bool operator != (const Turn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Turn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Turn &a, Turn &b);

std::ostream& operator<<(std::ostream& out, const Turn& obj);

typedef struct _Kick__isset {
  _Kick__isset() : power(false), relative_direction(false) {}
  bool power :1;
  bool relative_direction :1;
} _Kick__isset;

class Kick : public virtual ::apache::thrift::TBase {
 public:

  Kick(const Kick&) noexcept;
  Kick& operator=(const Kick&) noexcept;
  Kick() noexcept
       : power(0),
         relative_direction(0) {
  }

  virtual ~Kick() noexcept;
  double power;
  double relative_direction;

  _Kick__isset __isset;

  void __set_power(const double val);

  void __set_relative_direction(const double val);

  bool operator == (const Kick & rhs) const
  {
    if (!(power == rhs.power))
      return false;
    if (!(relative_direction == rhs.relative_direction))
      return false;
    return true;
  }
  bool operator != (const Kick &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Kick & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Kick &a, Kick &b);

std::ostream& operator<<(std::ostream& out, const Kick& obj);

typedef struct _Tackle__isset {
  _Tackle__isset() : power_or_dir(false), foul(false) {}
  bool power_or_dir :1;
  bool foul :1;
} _Tackle__isset;

class Tackle : public virtual ::apache::thrift::TBase {
 public:

  Tackle(const Tackle&) noexcept;
  Tackle& operator=(const Tackle&) noexcept;
  Tackle() noexcept
         : power_or_dir(0),
           foul(0) {
  }

  virtual ~Tackle() noexcept;
  double power_or_dir;
  bool foul;

  _Tackle__isset __isset;

  void __set_power_or_dir(const double val);

  void __set_foul(const bool val);

  bool operator == (const Tackle & rhs) const
  {
    if (!(power_or_dir == rhs.power_or_dir))
      return false;
    if (!(foul == rhs.foul))
      return false;
    return true;
  }
  bool operator != (const Tackle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Tackle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Tackle &a, Tackle &b);

std::ostream& operator<<(std::ostream& out, const Tackle& obj);


class Catch : public virtual ::apache::thrift::TBase {
 public:

  Catch(const Catch&) noexcept;
  Catch& operator=(const Catch&) noexcept;
  Catch() noexcept {
  }

  virtual ~Catch() noexcept;

  bool operator == (const Catch & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Catch &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Catch & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Catch &a, Catch &b);

std::ostream& operator<<(std::ostream& out, const Catch& obj);

typedef struct _Move__isset {
  _Move__isset() : x(false), y(false) {}
  bool x :1;
  bool y :1;
} _Move__isset;

class Move : public virtual ::apache::thrift::TBase {
 public:

  Move(const Move&) noexcept;
  Move& operator=(const Move&) noexcept;
  Move() noexcept
       : x(0),
         y(0) {
  }

  virtual ~Move() noexcept;
  double x;
  double y;

  _Move__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  bool operator == (const Move & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    return true;
  }
  bool operator != (const Move &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Move & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Move &a, Move &b);

std::ostream& operator<<(std::ostream& out, const Move& obj);

typedef struct _TurnNeck__isset {
  _TurnNeck__isset() : moment(false) {}
  bool moment :1;
} _TurnNeck__isset;

class TurnNeck : public virtual ::apache::thrift::TBase {
 public:

  TurnNeck(const TurnNeck&) noexcept;
  TurnNeck& operator=(const TurnNeck&) noexcept;
  TurnNeck() noexcept
           : moment(0) {
  }

  virtual ~TurnNeck() noexcept;
  double moment;

  _TurnNeck__isset __isset;

  void __set_moment(const double val);

  bool operator == (const TurnNeck & rhs) const
  {
    if (!(moment == rhs.moment))
      return false;
    return true;
  }
  bool operator != (const TurnNeck &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TurnNeck & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TurnNeck &a, TurnNeck &b);

std::ostream& operator<<(std::ostream& out, const TurnNeck& obj);

typedef struct _ChangeView__isset {
  _ChangeView__isset() : view_width(false) {}
  bool view_width :1;
} _ChangeView__isset;

class ChangeView : public virtual ::apache::thrift::TBase {
 public:

  ChangeView(const ChangeView&) noexcept;
  ChangeView& operator=(const ChangeView&) noexcept;
  ChangeView() noexcept
             : view_width(static_cast<ViewWidth::type>(0)) {
  }

  virtual ~ChangeView() noexcept;
  /**
   * 
   * @see ViewWidth
   */
  ViewWidth::type view_width;

  _ChangeView__isset __isset;

  void __set_view_width(const ViewWidth::type val);

  bool operator == (const ChangeView & rhs) const
  {
    if (!(view_width == rhs.view_width))
      return false;
    return true;
  }
  bool operator != (const ChangeView &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChangeView & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ChangeView &a, ChangeView &b);

std::ostream& operator<<(std::ostream& out, const ChangeView& obj);

typedef struct _BallMessage__isset {
  _BallMessage__isset() : ball_position(false), ball_velocity(false) {}
  bool ball_position :1;
  bool ball_velocity :1;
} _BallMessage__isset;

class BallMessage : public virtual ::apache::thrift::TBase {
 public:

  BallMessage(const BallMessage&) noexcept;
  BallMessage& operator=(const BallMessage&) noexcept;
  BallMessage() noexcept {
  }

  virtual ~BallMessage() noexcept;
  RpcVector2D ball_position;
  RpcVector2D ball_velocity;

  _BallMessage__isset __isset;

  void __set_ball_position(const RpcVector2D& val);

  void __set_ball_velocity(const RpcVector2D& val);

  bool operator == (const BallMessage & rhs) const
  {
    if (!(ball_position == rhs.ball_position))
      return false;
    if (!(ball_velocity == rhs.ball_velocity))
      return false;
    return true;
  }
  bool operator != (const BallMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BallMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(BallMessage &a, BallMessage &b);

std::ostream& operator<<(std::ostream& out, const BallMessage& obj);

typedef struct _PassMessage__isset {
  _PassMessage__isset() : receiver_uniform_number(false), receiver_point(false), ball_position(false), ball_velocity(false) {}
  bool receiver_uniform_number :1;
  bool receiver_point :1;
  bool ball_position :1;
  bool ball_velocity :1;
} _PassMessage__isset;

class PassMessage : public virtual ::apache::thrift::TBase {
 public:

  PassMessage(const PassMessage&) noexcept;
  PassMessage& operator=(const PassMessage&) noexcept;
  PassMessage() noexcept
              : receiver_uniform_number(0) {
  }

  virtual ~PassMessage() noexcept;
  int32_t receiver_uniform_number;
  RpcVector2D receiver_point;
  RpcVector2D ball_position;
  RpcVector2D ball_velocity;

  _PassMessage__isset __isset;

  void __set_receiver_uniform_number(const int32_t val);

  void __set_receiver_point(const RpcVector2D& val);

  void __set_ball_position(const RpcVector2D& val);

  void __set_ball_velocity(const RpcVector2D& val);

  bool operator == (const PassMessage & rhs) const
  {
    if (!(receiver_uniform_number == rhs.receiver_uniform_number))
      return false;
    if (!(receiver_point == rhs.receiver_point))
      return false;
    if (!(ball_position == rhs.ball_position))
      return false;
    if (!(ball_velocity == rhs.ball_velocity))
      return false;
    return true;
  }
  bool operator != (const PassMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PassMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PassMessage &a, PassMessage &b);

std::ostream& operator<<(std::ostream& out, const PassMessage& obj);

typedef struct _InterceptMessage__isset {
  _InterceptMessage__isset() : our(false), uniform_number(false), cycle(false) {}
  bool our :1;
  bool uniform_number :1;
  bool cycle :1;
} _InterceptMessage__isset;

class InterceptMessage : public virtual ::apache::thrift::TBase {
 public:

  InterceptMessage(const InterceptMessage&) noexcept;
  InterceptMessage& operator=(const InterceptMessage&) noexcept;
  InterceptMessage() noexcept
                   : our(0),
                     uniform_number(0),
                     cycle(0) {
  }

  virtual ~InterceptMessage() noexcept;
  bool our;
  int32_t uniform_number;
  int32_t cycle;

  _InterceptMessage__isset __isset;

  void __set_our(const bool val);

  void __set_uniform_number(const int32_t val);

  void __set_cycle(const int32_t val);

  bool operator == (const InterceptMessage & rhs) const
  {
    if (!(our == rhs.our))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(cycle == rhs.cycle))
      return false;
    return true;
  }
  bool operator != (const InterceptMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterceptMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(InterceptMessage &a, InterceptMessage &b);

std::ostream& operator<<(std::ostream& out, const InterceptMessage& obj);

typedef struct _GoalieMessage__isset {
  _GoalieMessage__isset() : goalie_uniform_number(false), goalie_position(false), goalie_body_direction(false) {}
  bool goalie_uniform_number :1;
  bool goalie_position :1;
  bool goalie_body_direction :1;
} _GoalieMessage__isset;

class GoalieMessage : public virtual ::apache::thrift::TBase {
 public:

  GoalieMessage(const GoalieMessage&) noexcept;
  GoalieMessage& operator=(const GoalieMessage&) noexcept;
  GoalieMessage() noexcept
                : goalie_uniform_number(0),
                  goalie_body_direction(0) {
  }

  virtual ~GoalieMessage() noexcept;
  int32_t goalie_uniform_number;
  RpcVector2D goalie_position;
  double goalie_body_direction;

  _GoalieMessage__isset __isset;

  void __set_goalie_uniform_number(const int32_t val);

  void __set_goalie_position(const RpcVector2D& val);

  void __set_goalie_body_direction(const double val);

  bool operator == (const GoalieMessage & rhs) const
  {
    if (!(goalie_uniform_number == rhs.goalie_uniform_number))
      return false;
    if (!(goalie_position == rhs.goalie_position))
      return false;
    if (!(goalie_body_direction == rhs.goalie_body_direction))
      return false;
    return true;
  }
  bool operator != (const GoalieMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GoalieMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GoalieMessage &a, GoalieMessage &b);

std::ostream& operator<<(std::ostream& out, const GoalieMessage& obj);

typedef struct _GoalieAndPlayerMessage__isset {
  _GoalieAndPlayerMessage__isset() : goalie_uniform_number(false), goalie_position(false), goalie_body_direction(false), player_uniform_number(false), player_position(false) {}
  bool goalie_uniform_number :1;
  bool goalie_position :1;
  bool goalie_body_direction :1;
  bool player_uniform_number :1;
  bool player_position :1;
} _GoalieAndPlayerMessage__isset;

class GoalieAndPlayerMessage : public virtual ::apache::thrift::TBase {
 public:

  GoalieAndPlayerMessage(const GoalieAndPlayerMessage&) noexcept;
  GoalieAndPlayerMessage& operator=(const GoalieAndPlayerMessage&) noexcept;
  GoalieAndPlayerMessage() noexcept
                         : goalie_uniform_number(0),
                           goalie_body_direction(0),
                           player_uniform_number(0) {
  }

  virtual ~GoalieAndPlayerMessage() noexcept;
  int32_t goalie_uniform_number;
  RpcVector2D goalie_position;
  double goalie_body_direction;
  int32_t player_uniform_number;
  RpcVector2D player_position;

  _GoalieAndPlayerMessage__isset __isset;

  void __set_goalie_uniform_number(const int32_t val);

  void __set_goalie_position(const RpcVector2D& val);

  void __set_goalie_body_direction(const double val);

  void __set_player_uniform_number(const int32_t val);

  void __set_player_position(const RpcVector2D& val);

  bool operator == (const GoalieAndPlayerMessage & rhs) const
  {
    if (!(goalie_uniform_number == rhs.goalie_uniform_number))
      return false;
    if (!(goalie_position == rhs.goalie_position))
      return false;
    if (!(goalie_body_direction == rhs.goalie_body_direction))
      return false;
    if (!(player_uniform_number == rhs.player_uniform_number))
      return false;
    if (!(player_position == rhs.player_position))
      return false;
    return true;
  }
  bool operator != (const GoalieAndPlayerMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GoalieAndPlayerMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GoalieAndPlayerMessage &a, GoalieAndPlayerMessage &b);

std::ostream& operator<<(std::ostream& out, const GoalieAndPlayerMessage& obj);

typedef struct _OffsideLineMessage__isset {
  _OffsideLineMessage__isset() : offside_line_x(false) {}
  bool offside_line_x :1;
} _OffsideLineMessage__isset;

class OffsideLineMessage : public virtual ::apache::thrift::TBase {
 public:

  OffsideLineMessage(const OffsideLineMessage&) noexcept;
  OffsideLineMessage& operator=(const OffsideLineMessage&) noexcept;
  OffsideLineMessage() noexcept
                     : offside_line_x(0) {
  }

  virtual ~OffsideLineMessage() noexcept;
  double offside_line_x;

  _OffsideLineMessage__isset __isset;

  void __set_offside_line_x(const double val);

  bool operator == (const OffsideLineMessage & rhs) const
  {
    if (!(offside_line_x == rhs.offside_line_x))
      return false;
    return true;
  }
  bool operator != (const OffsideLineMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OffsideLineMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(OffsideLineMessage &a, OffsideLineMessage &b);

std::ostream& operator<<(std::ostream& out, const OffsideLineMessage& obj);

typedef struct _DefenseLineMessage__isset {
  _DefenseLineMessage__isset() : defense_line_x(false) {}
  bool defense_line_x :1;
} _DefenseLineMessage__isset;

class DefenseLineMessage : public virtual ::apache::thrift::TBase {
 public:

  DefenseLineMessage(const DefenseLineMessage&) noexcept;
  DefenseLineMessage& operator=(const DefenseLineMessage&) noexcept;
  DefenseLineMessage() noexcept
                     : defense_line_x(0) {
  }

  virtual ~DefenseLineMessage() noexcept;
  double defense_line_x;

  _DefenseLineMessage__isset __isset;

  void __set_defense_line_x(const double val);

  bool operator == (const DefenseLineMessage & rhs) const
  {
    if (!(defense_line_x == rhs.defense_line_x))
      return false;
    return true;
  }
  bool operator != (const DefenseLineMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefenseLineMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DefenseLineMessage &a, DefenseLineMessage &b);

std::ostream& operator<<(std::ostream& out, const DefenseLineMessage& obj);


class WaitRequestMessage : public virtual ::apache::thrift::TBase {
 public:

  WaitRequestMessage(const WaitRequestMessage&) noexcept;
  WaitRequestMessage& operator=(const WaitRequestMessage&) noexcept;
  WaitRequestMessage() noexcept {
  }

  virtual ~WaitRequestMessage() noexcept;

  bool operator == (const WaitRequestMessage & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WaitRequestMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WaitRequestMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WaitRequestMessage &a, WaitRequestMessage &b);

std::ostream& operator<<(std::ostream& out, const WaitRequestMessage& obj);

typedef struct _SetplayMessage__isset {
  _SetplayMessage__isset() : wait_step(false) {}
  bool wait_step :1;
} _SetplayMessage__isset;

class SetplayMessage : public virtual ::apache::thrift::TBase {
 public:

  SetplayMessage(const SetplayMessage&) noexcept;
  SetplayMessage& operator=(const SetplayMessage&) noexcept;
  SetplayMessage() noexcept
                 : wait_step(0) {
  }

  virtual ~SetplayMessage() noexcept;
  int32_t wait_step;

  _SetplayMessage__isset __isset;

  void __set_wait_step(const int32_t val);

  bool operator == (const SetplayMessage & rhs) const
  {
    if (!(wait_step == rhs.wait_step))
      return false;
    return true;
  }
  bool operator != (const SetplayMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetplayMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetplayMessage &a, SetplayMessage &b);

std::ostream& operator<<(std::ostream& out, const SetplayMessage& obj);

typedef struct _PassRequestMessage__isset {
  _PassRequestMessage__isset() : target_point(false) {}
  bool target_point :1;
} _PassRequestMessage__isset;

class PassRequestMessage : public virtual ::apache::thrift::TBase {
 public:

  PassRequestMessage(const PassRequestMessage&) noexcept;
  PassRequestMessage& operator=(const PassRequestMessage&) noexcept;
  PassRequestMessage() noexcept {
  }

  virtual ~PassRequestMessage() noexcept;
  RpcVector2D target_point;

  _PassRequestMessage__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  bool operator == (const PassRequestMessage & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    return true;
  }
  bool operator != (const PassRequestMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PassRequestMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PassRequestMessage &a, PassRequestMessage &b);

std::ostream& operator<<(std::ostream& out, const PassRequestMessage& obj);

typedef struct _StaminaMessage__isset {
  _StaminaMessage__isset() : stamina(false) {}
  bool stamina :1;
} _StaminaMessage__isset;

class StaminaMessage : public virtual ::apache::thrift::TBase {
 public:

  StaminaMessage(const StaminaMessage&) noexcept;
  StaminaMessage& operator=(const StaminaMessage&) noexcept;
  StaminaMessage() noexcept
                 : stamina(0) {
  }

  virtual ~StaminaMessage() noexcept;
  double stamina;

  _StaminaMessage__isset __isset;

  void __set_stamina(const double val);

  bool operator == (const StaminaMessage & rhs) const
  {
    if (!(stamina == rhs.stamina))
      return false;
    return true;
  }
  bool operator != (const StaminaMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StaminaMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(StaminaMessage &a, StaminaMessage &b);

std::ostream& operator<<(std::ostream& out, const StaminaMessage& obj);

typedef struct _RecoveryMessage__isset {
  _RecoveryMessage__isset() : recovery(false) {}
  bool recovery :1;
} _RecoveryMessage__isset;

class RecoveryMessage : public virtual ::apache::thrift::TBase {
 public:

  RecoveryMessage(const RecoveryMessage&) noexcept;
  RecoveryMessage& operator=(const RecoveryMessage&) noexcept;
  RecoveryMessage() noexcept
                  : recovery(0) {
  }

  virtual ~RecoveryMessage() noexcept;
  double recovery;

  _RecoveryMessage__isset __isset;

  void __set_recovery(const double val);

  bool operator == (const RecoveryMessage & rhs) const
  {
    if (!(recovery == rhs.recovery))
      return false;
    return true;
  }
  bool operator != (const RecoveryMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecoveryMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RecoveryMessage &a, RecoveryMessage &b);

std::ostream& operator<<(std::ostream& out, const RecoveryMessage& obj);

typedef struct _StaminaCapacityMessage__isset {
  _StaminaCapacityMessage__isset() : stamina_capacity(false) {}
  bool stamina_capacity :1;
} _StaminaCapacityMessage__isset;

class StaminaCapacityMessage : public virtual ::apache::thrift::TBase {
 public:

  StaminaCapacityMessage(const StaminaCapacityMessage&) noexcept;
  StaminaCapacityMessage& operator=(const StaminaCapacityMessage&) noexcept;
  StaminaCapacityMessage() noexcept
                         : stamina_capacity(0) {
  }

  virtual ~StaminaCapacityMessage() noexcept;
  double stamina_capacity;

  _StaminaCapacityMessage__isset __isset;

  void __set_stamina_capacity(const double val);

  bool operator == (const StaminaCapacityMessage & rhs) const
  {
    if (!(stamina_capacity == rhs.stamina_capacity))
      return false;
    return true;
  }
  bool operator != (const StaminaCapacityMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StaminaCapacityMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(StaminaCapacityMessage &a, StaminaCapacityMessage &b);

std::ostream& operator<<(std::ostream& out, const StaminaCapacityMessage& obj);

typedef struct _DribbleMessage__isset {
  _DribbleMessage__isset() : target_point(false), queue_count(false) {}
  bool target_point :1;
  bool queue_count :1;
} _DribbleMessage__isset;

class DribbleMessage : public virtual ::apache::thrift::TBase {
 public:

  DribbleMessage(const DribbleMessage&) noexcept;
  DribbleMessage& operator=(const DribbleMessage&) noexcept;
  DribbleMessage() noexcept
                 : queue_count(0) {
  }

  virtual ~DribbleMessage() noexcept;
  RpcVector2D target_point;
  int32_t queue_count;

  _DribbleMessage__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_queue_count(const int32_t val);

  bool operator == (const DribbleMessage & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(queue_count == rhs.queue_count))
      return false;
    return true;
  }
  bool operator != (const DribbleMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DribbleMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DribbleMessage &a, DribbleMessage &b);

std::ostream& operator<<(std::ostream& out, const DribbleMessage& obj);

typedef struct _BallGoalieMessage__isset {
  _BallGoalieMessage__isset() : ball_position(false), ball_velocity(false), goalie_position(false), goalie_body_direction(false) {}
  bool ball_position :1;
  bool ball_velocity :1;
  bool goalie_position :1;
  bool goalie_body_direction :1;
} _BallGoalieMessage__isset;

class BallGoalieMessage : public virtual ::apache::thrift::TBase {
 public:

  BallGoalieMessage(const BallGoalieMessage&) noexcept;
  BallGoalieMessage& operator=(const BallGoalieMessage&) noexcept;
  BallGoalieMessage() noexcept
                    : goalie_body_direction(0) {
  }

  virtual ~BallGoalieMessage() noexcept;
  RpcVector2D ball_position;
  RpcVector2D ball_velocity;
  RpcVector2D goalie_position;
  double goalie_body_direction;

  _BallGoalieMessage__isset __isset;

  void __set_ball_position(const RpcVector2D& val);

  void __set_ball_velocity(const RpcVector2D& val);

  void __set_goalie_position(const RpcVector2D& val);

  void __set_goalie_body_direction(const double val);

  bool operator == (const BallGoalieMessage & rhs) const
  {
    if (!(ball_position == rhs.ball_position))
      return false;
    if (!(ball_velocity == rhs.ball_velocity))
      return false;
    if (!(goalie_position == rhs.goalie_position))
      return false;
    if (!(goalie_body_direction == rhs.goalie_body_direction))
      return false;
    return true;
  }
  bool operator != (const BallGoalieMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BallGoalieMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(BallGoalieMessage &a, BallGoalieMessage &b);

std::ostream& operator<<(std::ostream& out, const BallGoalieMessage& obj);

typedef struct _OnePlayerMessage__isset {
  _OnePlayerMessage__isset() : uniform_number(false), position(false) {}
  bool uniform_number :1;
  bool position :1;
} _OnePlayerMessage__isset;

class OnePlayerMessage : public virtual ::apache::thrift::TBase {
 public:

  OnePlayerMessage(const OnePlayerMessage&) noexcept;
  OnePlayerMessage& operator=(const OnePlayerMessage&) noexcept;
  OnePlayerMessage() noexcept
                   : uniform_number(0) {
  }

  virtual ~OnePlayerMessage() noexcept;
  int32_t uniform_number;
  RpcVector2D position;

  _OnePlayerMessage__isset __isset;

  void __set_uniform_number(const int32_t val);

  void __set_position(const RpcVector2D& val);

  bool operator == (const OnePlayerMessage & rhs) const
  {
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(position == rhs.position))
      return false;
    return true;
  }
  bool operator != (const OnePlayerMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OnePlayerMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(OnePlayerMessage &a, OnePlayerMessage &b);

std::ostream& operator<<(std::ostream& out, const OnePlayerMessage& obj);

typedef struct _TwoPlayerMessage__isset {
  _TwoPlayerMessage__isset() : first_uniform_number(false), first_position(false), second_uniform_number(false), second_position(false) {}
  bool first_uniform_number :1;
  bool first_position :1;
  bool second_uniform_number :1;
  bool second_position :1;
} _TwoPlayerMessage__isset;

class TwoPlayerMessage : public virtual ::apache::thrift::TBase {
 public:

  TwoPlayerMessage(const TwoPlayerMessage&) noexcept;
  TwoPlayerMessage& operator=(const TwoPlayerMessage&) noexcept;
  TwoPlayerMessage() noexcept
                   : first_uniform_number(0),
                     second_uniform_number(0) {
  }

  virtual ~TwoPlayerMessage() noexcept;
  int32_t first_uniform_number;
  RpcVector2D first_position;
  int32_t second_uniform_number;
  RpcVector2D second_position;

  _TwoPlayerMessage__isset __isset;

  void __set_first_uniform_number(const int32_t val);

  void __set_first_position(const RpcVector2D& val);

  void __set_second_uniform_number(const int32_t val);

  void __set_second_position(const RpcVector2D& val);

  bool operator == (const TwoPlayerMessage & rhs) const
  {
    if (!(first_uniform_number == rhs.first_uniform_number))
      return false;
    if (!(first_position == rhs.first_position))
      return false;
    if (!(second_uniform_number == rhs.second_uniform_number))
      return false;
    if (!(second_position == rhs.second_position))
      return false;
    return true;
  }
  bool operator != (const TwoPlayerMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TwoPlayerMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TwoPlayerMessage &a, TwoPlayerMessage &b);

std::ostream& operator<<(std::ostream& out, const TwoPlayerMessage& obj);

typedef struct _ThreePlayerMessage__isset {
  _ThreePlayerMessage__isset() : first_uniform_number(false), first_position(false), second_uniform_number(false), second_position(false), third_uniform_number(false), third_position(false) {}
  bool first_uniform_number :1;
  bool first_position :1;
  bool second_uniform_number :1;
  bool second_position :1;
  bool third_uniform_number :1;
  bool third_position :1;
} _ThreePlayerMessage__isset;

class ThreePlayerMessage : public virtual ::apache::thrift::TBase {
 public:

  ThreePlayerMessage(const ThreePlayerMessage&) noexcept;
  ThreePlayerMessage& operator=(const ThreePlayerMessage&) noexcept;
  ThreePlayerMessage() noexcept
                     : first_uniform_number(0),
                       second_uniform_number(0),
                       third_uniform_number(0) {
  }

  virtual ~ThreePlayerMessage() noexcept;
  int32_t first_uniform_number;
  RpcVector2D first_position;
  int32_t second_uniform_number;
  RpcVector2D second_position;
  int32_t third_uniform_number;
  RpcVector2D third_position;

  _ThreePlayerMessage__isset __isset;

  void __set_first_uniform_number(const int32_t val);

  void __set_first_position(const RpcVector2D& val);

  void __set_second_uniform_number(const int32_t val);

  void __set_second_position(const RpcVector2D& val);

  void __set_third_uniform_number(const int32_t val);

  void __set_third_position(const RpcVector2D& val);

  bool operator == (const ThreePlayerMessage & rhs) const
  {
    if (!(first_uniform_number == rhs.first_uniform_number))
      return false;
    if (!(first_position == rhs.first_position))
      return false;
    if (!(second_uniform_number == rhs.second_uniform_number))
      return false;
    if (!(second_position == rhs.second_position))
      return false;
    if (!(third_uniform_number == rhs.third_uniform_number))
      return false;
    if (!(third_position == rhs.third_position))
      return false;
    return true;
  }
  bool operator != (const ThreePlayerMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThreePlayerMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ThreePlayerMessage &a, ThreePlayerMessage &b);

std::ostream& operator<<(std::ostream& out, const ThreePlayerMessage& obj);

typedef struct _SelfMessage__isset {
  _SelfMessage__isset() : self_position(false), self_body_direction(false), self_stamina(false) {}
  bool self_position :1;
  bool self_body_direction :1;
  bool self_stamina :1;
} _SelfMessage__isset;

class SelfMessage : public virtual ::apache::thrift::TBase {
 public:

  SelfMessage(const SelfMessage&) noexcept;
  SelfMessage& operator=(const SelfMessage&) noexcept;
  SelfMessage() noexcept
              : self_body_direction(0),
                self_stamina(0) {
  }

  virtual ~SelfMessage() noexcept;
  RpcVector2D self_position;
  double self_body_direction;
  double self_stamina;

  _SelfMessage__isset __isset;

  void __set_self_position(const RpcVector2D& val);

  void __set_self_body_direction(const double val);

  void __set_self_stamina(const double val);

  bool operator == (const SelfMessage & rhs) const
  {
    if (!(self_position == rhs.self_position))
      return false;
    if (!(self_body_direction == rhs.self_body_direction))
      return false;
    if (!(self_stamina == rhs.self_stamina))
      return false;
    return true;
  }
  bool operator != (const SelfMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SelfMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SelfMessage &a, SelfMessage &b);

std::ostream& operator<<(std::ostream& out, const SelfMessage& obj);

typedef struct _TeammateMessage__isset {
  _TeammateMessage__isset() : uniform_number(false), position(false), body_direction(false) {}
  bool uniform_number :1;
  bool position :1;
  bool body_direction :1;
} _TeammateMessage__isset;

class TeammateMessage : public virtual ::apache::thrift::TBase {
 public:

  TeammateMessage(const TeammateMessage&) noexcept;
  TeammateMessage& operator=(const TeammateMessage&) noexcept;
  TeammateMessage() noexcept
                  : uniform_number(0),
                    body_direction(0) {
  }

  virtual ~TeammateMessage() noexcept;
  int32_t uniform_number;
  RpcVector2D position;
  double body_direction;

  _TeammateMessage__isset __isset;

  void __set_uniform_number(const int32_t val);

  void __set_position(const RpcVector2D& val);

  void __set_body_direction(const double val);

  bool operator == (const TeammateMessage & rhs) const
  {
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(position == rhs.position))
      return false;
    if (!(body_direction == rhs.body_direction))
      return false;
    return true;
  }
  bool operator != (const TeammateMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TeammateMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TeammateMessage &a, TeammateMessage &b);

std::ostream& operator<<(std::ostream& out, const TeammateMessage& obj);

typedef struct _OpponentMessage__isset {
  _OpponentMessage__isset() : uniform_number(false), position(false), body_direction(false) {}
  bool uniform_number :1;
  bool position :1;
  bool body_direction :1;
} _OpponentMessage__isset;

class OpponentMessage : public virtual ::apache::thrift::TBase {
 public:

  OpponentMessage(const OpponentMessage&) noexcept;
  OpponentMessage& operator=(const OpponentMessage&) noexcept;
  OpponentMessage() noexcept
                  : uniform_number(0),
                    body_direction(0) {
  }

  virtual ~OpponentMessage() noexcept;
  int32_t uniform_number;
  RpcVector2D position;
  double body_direction;

  _OpponentMessage__isset __isset;

  void __set_uniform_number(const int32_t val);

  void __set_position(const RpcVector2D& val);

  void __set_body_direction(const double val);

  bool operator == (const OpponentMessage & rhs) const
  {
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(position == rhs.position))
      return false;
    if (!(body_direction == rhs.body_direction))
      return false;
    return true;
  }
  bool operator != (const OpponentMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OpponentMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(OpponentMessage &a, OpponentMessage &b);

std::ostream& operator<<(std::ostream& out, const OpponentMessage& obj);

typedef struct _BallPlayerMessage__isset {
  _BallPlayerMessage__isset() : ball_position(false), ball_velocity(false), uniform_number(false), player_position(false), body_direction(false) {}
  bool ball_position :1;
  bool ball_velocity :1;
  bool uniform_number :1;
  bool player_position :1;
  bool body_direction :1;
} _BallPlayerMessage__isset;

class BallPlayerMessage : public virtual ::apache::thrift::TBase {
 public:

  BallPlayerMessage(const BallPlayerMessage&) noexcept;
  BallPlayerMessage& operator=(const BallPlayerMessage&) noexcept;
  BallPlayerMessage() noexcept
                    : uniform_number(0),
                      body_direction(0) {
  }

  virtual ~BallPlayerMessage() noexcept;
  RpcVector2D ball_position;
  RpcVector2D ball_velocity;
  int32_t uniform_number;
  RpcVector2D player_position;
  double body_direction;

  _BallPlayerMessage__isset __isset;

  void __set_ball_position(const RpcVector2D& val);

  void __set_ball_velocity(const RpcVector2D& val);

  void __set_uniform_number(const int32_t val);

  void __set_player_position(const RpcVector2D& val);

  void __set_body_direction(const double val);

  bool operator == (const BallPlayerMessage & rhs) const
  {
    if (!(ball_position == rhs.ball_position))
      return false;
    if (!(ball_velocity == rhs.ball_velocity))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(player_position == rhs.player_position))
      return false;
    if (!(body_direction == rhs.body_direction))
      return false;
    return true;
  }
  bool operator != (const BallPlayerMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BallPlayerMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(BallPlayerMessage &a, BallPlayerMessage &b);

std::ostream& operator<<(std::ostream& out, const BallPlayerMessage& obj);

typedef struct _Say__isset {
  _Say__isset() : ball_message(false), pass_message(false), intercept_message(false), goalie_message(false), goalie_and_player_message(false), offside_line_message(false), defense_line_message(false), wait_request_message(false), setplay_message(false), pass_request_message(false), stamina_message(false), recovery_message(false), stamina_capacity_message(false), dribble_message(false), ball_goalie_message(false), one_player_message(false), two_player_message(false), three_player_message(false), self_message(false), teammate_message(false), opponent_message(false), ball_player_message(false) {}
  bool ball_message :1;
  bool pass_message :1;
  bool intercept_message :1;
  bool goalie_message :1;
  bool goalie_and_player_message :1;
  bool offside_line_message :1;
  bool defense_line_message :1;
  bool wait_request_message :1;
  bool setplay_message :1;
  bool pass_request_message :1;
  bool stamina_message :1;
  bool recovery_message :1;
  bool stamina_capacity_message :1;
  bool dribble_message :1;
  bool ball_goalie_message :1;
  bool one_player_message :1;
  bool two_player_message :1;
  bool three_player_message :1;
  bool self_message :1;
  bool teammate_message :1;
  bool opponent_message :1;
  bool ball_player_message :1;
} _Say__isset;

class Say : public virtual ::apache::thrift::TBase {
 public:

  Say(const Say&) noexcept;
  Say& operator=(const Say&) noexcept;
  Say() noexcept {
  }

  virtual ~Say() noexcept;
  BallMessage ball_message;
  PassMessage pass_message;
  InterceptMessage intercept_message;
  GoalieMessage goalie_message;
  GoalieAndPlayerMessage goalie_and_player_message;
  OffsideLineMessage offside_line_message;
  DefenseLineMessage defense_line_message;
  WaitRequestMessage wait_request_message;
  SetplayMessage setplay_message;
  PassRequestMessage pass_request_message;
  StaminaMessage stamina_message;
  RecoveryMessage recovery_message;
  StaminaCapacityMessage stamina_capacity_message;
  DribbleMessage dribble_message;
  BallGoalieMessage ball_goalie_message;
  OnePlayerMessage one_player_message;
  TwoPlayerMessage two_player_message;
  ThreePlayerMessage three_player_message;
  SelfMessage self_message;
  TeammateMessage teammate_message;
  OpponentMessage opponent_message;
  BallPlayerMessage ball_player_message;

  _Say__isset __isset;

  void __set_ball_message(const BallMessage& val);

  void __set_pass_message(const PassMessage& val);

  void __set_intercept_message(const InterceptMessage& val);

  void __set_goalie_message(const GoalieMessage& val);

  void __set_goalie_and_player_message(const GoalieAndPlayerMessage& val);

  void __set_offside_line_message(const OffsideLineMessage& val);

  void __set_defense_line_message(const DefenseLineMessage& val);

  void __set_wait_request_message(const WaitRequestMessage& val);

  void __set_setplay_message(const SetplayMessage& val);

  void __set_pass_request_message(const PassRequestMessage& val);

  void __set_stamina_message(const StaminaMessage& val);

  void __set_recovery_message(const RecoveryMessage& val);

  void __set_stamina_capacity_message(const StaminaCapacityMessage& val);

  void __set_dribble_message(const DribbleMessage& val);

  void __set_ball_goalie_message(const BallGoalieMessage& val);

  void __set_one_player_message(const OnePlayerMessage& val);

  void __set_two_player_message(const TwoPlayerMessage& val);

  void __set_three_player_message(const ThreePlayerMessage& val);

  void __set_self_message(const SelfMessage& val);

  void __set_teammate_message(const TeammateMessage& val);

  void __set_opponent_message(const OpponentMessage& val);

  void __set_ball_player_message(const BallPlayerMessage& val);

  bool operator == (const Say & rhs) const
  {
    if (__isset.ball_message != rhs.__isset.ball_message)
      return false;
    else if (__isset.ball_message && !(ball_message == rhs.ball_message))
      return false;
    if (__isset.pass_message != rhs.__isset.pass_message)
      return false;
    else if (__isset.pass_message && !(pass_message == rhs.pass_message))
      return false;
    if (__isset.intercept_message != rhs.__isset.intercept_message)
      return false;
    else if (__isset.intercept_message && !(intercept_message == rhs.intercept_message))
      return false;
    if (__isset.goalie_message != rhs.__isset.goalie_message)
      return false;
    else if (__isset.goalie_message && !(goalie_message == rhs.goalie_message))
      return false;
    if (__isset.goalie_and_player_message != rhs.__isset.goalie_and_player_message)
      return false;
    else if (__isset.goalie_and_player_message && !(goalie_and_player_message == rhs.goalie_and_player_message))
      return false;
    if (__isset.offside_line_message != rhs.__isset.offside_line_message)
      return false;
    else if (__isset.offside_line_message && !(offside_line_message == rhs.offside_line_message))
      return false;
    if (__isset.defense_line_message != rhs.__isset.defense_line_message)
      return false;
    else if (__isset.defense_line_message && !(defense_line_message == rhs.defense_line_message))
      return false;
    if (__isset.wait_request_message != rhs.__isset.wait_request_message)
      return false;
    else if (__isset.wait_request_message && !(wait_request_message == rhs.wait_request_message))
      return false;
    if (__isset.setplay_message != rhs.__isset.setplay_message)
      return false;
    else if (__isset.setplay_message && !(setplay_message == rhs.setplay_message))
      return false;
    if (__isset.pass_request_message != rhs.__isset.pass_request_message)
      return false;
    else if (__isset.pass_request_message && !(pass_request_message == rhs.pass_request_message))
      return false;
    if (__isset.stamina_message != rhs.__isset.stamina_message)
      return false;
    else if (__isset.stamina_message && !(stamina_message == rhs.stamina_message))
      return false;
    if (__isset.recovery_message != rhs.__isset.recovery_message)
      return false;
    else if (__isset.recovery_message && !(recovery_message == rhs.recovery_message))
      return false;
    if (__isset.stamina_capacity_message != rhs.__isset.stamina_capacity_message)
      return false;
    else if (__isset.stamina_capacity_message && !(stamina_capacity_message == rhs.stamina_capacity_message))
      return false;
    if (__isset.dribble_message != rhs.__isset.dribble_message)
      return false;
    else if (__isset.dribble_message && !(dribble_message == rhs.dribble_message))
      return false;
    if (__isset.ball_goalie_message != rhs.__isset.ball_goalie_message)
      return false;
    else if (__isset.ball_goalie_message && !(ball_goalie_message == rhs.ball_goalie_message))
      return false;
    if (__isset.one_player_message != rhs.__isset.one_player_message)
      return false;
    else if (__isset.one_player_message && !(one_player_message == rhs.one_player_message))
      return false;
    if (__isset.two_player_message != rhs.__isset.two_player_message)
      return false;
    else if (__isset.two_player_message && !(two_player_message == rhs.two_player_message))
      return false;
    if (__isset.three_player_message != rhs.__isset.three_player_message)
      return false;
    else if (__isset.three_player_message && !(three_player_message == rhs.three_player_message))
      return false;
    if (__isset.self_message != rhs.__isset.self_message)
      return false;
    else if (__isset.self_message && !(self_message == rhs.self_message))
      return false;
    if (__isset.teammate_message != rhs.__isset.teammate_message)
      return false;
    else if (__isset.teammate_message && !(teammate_message == rhs.teammate_message))
      return false;
    if (__isset.opponent_message != rhs.__isset.opponent_message)
      return false;
    else if (__isset.opponent_message && !(opponent_message == rhs.opponent_message))
      return false;
    if (__isset.ball_player_message != rhs.__isset.ball_player_message)
      return false;
    else if (__isset.ball_player_message && !(ball_player_message == rhs.ball_player_message))
      return false;
    return true;
  }
  bool operator != (const Say &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Say & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Say &a, Say &b);

std::ostream& operator<<(std::ostream& out, const Say& obj);

typedef struct _PointTo__isset {
  _PointTo__isset() : x(false), y(false) {}
  bool x :1;
  bool y :1;
} _PointTo__isset;

class PointTo : public virtual ::apache::thrift::TBase {
 public:

  PointTo(const PointTo&) noexcept;
  PointTo& operator=(const PointTo&) noexcept;
  PointTo() noexcept
          : x(0),
            y(0) {
  }

  virtual ~PointTo() noexcept;
  double x;
  double y;

  _PointTo__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  bool operator == (const PointTo & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    return true;
  }
  bool operator != (const PointTo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PointTo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PointTo &a, PointTo &b);

std::ostream& operator<<(std::ostream& out, const PointTo& obj);


class PointToOf : public virtual ::apache::thrift::TBase {
 public:

  PointToOf(const PointToOf&) noexcept;
  PointToOf& operator=(const PointToOf&) noexcept;
  PointToOf() noexcept {
  }

  virtual ~PointToOf() noexcept;

  bool operator == (const PointToOf & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PointToOf &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PointToOf & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PointToOf &a, PointToOf &b);

std::ostream& operator<<(std::ostream& out, const PointToOf& obj);

typedef struct _AttentionTo__isset {
  _AttentionTo__isset() : side(false), unum(false) {}
  bool side :1;
  bool unum :1;
} _AttentionTo__isset;

class AttentionTo : public virtual ::apache::thrift::TBase {
 public:

  AttentionTo(const AttentionTo&) noexcept;
  AttentionTo& operator=(const AttentionTo&) noexcept;
  AttentionTo() noexcept
              : side(static_cast<Side::type>(0)),
                unum(0) {
  }

  virtual ~AttentionTo() noexcept;
  /**
   * 
   * @see Side
   */
  Side::type side;
  int32_t unum;

  _AttentionTo__isset __isset;

  void __set_side(const Side::type val);

  void __set_unum(const int32_t val);

  bool operator == (const AttentionTo & rhs) const
  {
    if (!(side == rhs.side))
      return false;
    if (!(unum == rhs.unum))
      return false;
    return true;
  }
  bool operator != (const AttentionTo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AttentionTo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AttentionTo &a, AttentionTo &b);

std::ostream& operator<<(std::ostream& out, const AttentionTo& obj);


class AttentionToOf : public virtual ::apache::thrift::TBase {
 public:

  AttentionToOf(const AttentionToOf&) noexcept;
  AttentionToOf& operator=(const AttentionToOf&) noexcept;
  AttentionToOf() noexcept {
  }

  virtual ~AttentionToOf() noexcept;

  bool operator == (const AttentionToOf & /* rhs */) const
  {
    return true;
  }
  bool operator != (const AttentionToOf &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AttentionToOf & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AttentionToOf &a, AttentionToOf &b);

std::ostream& operator<<(std::ostream& out, const AttentionToOf& obj);

typedef struct _AddText__isset {
  _AddText__isset() : level(false), message(false) {}
  bool level :1;
  bool message :1;
} _AddText__isset;

class AddText : public virtual ::apache::thrift::TBase {
 public:

  AddText(const AddText&);
  AddText& operator=(const AddText&);
  AddText() noexcept
          : level(static_cast<LoggerLevel::type>(0)),
            message() {
  }

  virtual ~AddText() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  std::string message;

  _AddText__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_message(const std::string& val);

  bool operator == (const AddText & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const AddText &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddText & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddText &a, AddText &b);

std::ostream& operator<<(std::ostream& out, const AddText& obj);

typedef struct _AddPoint__isset {
  _AddPoint__isset() : level(false), point(false), color(false) {}
  bool level :1;
  bool point :1;
  bool color :1;
} _AddPoint__isset;

class AddPoint : public virtual ::apache::thrift::TBase {
 public:

  AddPoint(const AddPoint&);
  AddPoint& operator=(const AddPoint&);
  AddPoint() noexcept
           : level(static_cast<LoggerLevel::type>(0)),
             color() {
  }

  virtual ~AddPoint() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  RpcVector2D point;
  std::string color;

  _AddPoint__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_point(const RpcVector2D& val);

  void __set_color(const std::string& val);

  bool operator == (const AddPoint & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(point == rhs.point))
      return false;
    if (!(color == rhs.color))
      return false;
    return true;
  }
  bool operator != (const AddPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPoint &a, AddPoint &b);

std::ostream& operator<<(std::ostream& out, const AddPoint& obj);

typedef struct _AddLine__isset {
  _AddLine__isset() : level(false), start_point(false), end_point(false), color(false) {}
  bool level :1;
  bool start_point :1;
  bool end_point :1;
  bool color :1;
} _AddLine__isset;

class AddLine : public virtual ::apache::thrift::TBase {
 public:

  AddLine(const AddLine&);
  AddLine& operator=(const AddLine&);
  AddLine() noexcept
          : level(static_cast<LoggerLevel::type>(0)),
            color() {
  }

  virtual ~AddLine() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  RpcVector2D start_point;
  RpcVector2D end_point;
  std::string color;

  _AddLine__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_start_point(const RpcVector2D& val);

  void __set_end_point(const RpcVector2D& val);

  void __set_color(const std::string& val);

  bool operator == (const AddLine & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(start_point == rhs.start_point))
      return false;
    if (!(end_point == rhs.end_point))
      return false;
    if (!(color == rhs.color))
      return false;
    return true;
  }
  bool operator != (const AddLine &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddLine & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddLine &a, AddLine &b);

std::ostream& operator<<(std::ostream& out, const AddLine& obj);

typedef struct _AddArc__isset {
  _AddArc__isset() : level(false), center(false), radius(false), start_angle(false), span_angel(false), color(false) {}
  bool level :1;
  bool center :1;
  bool radius :1;
  bool start_angle :1;
  bool span_angel :1;
  bool color :1;
} _AddArc__isset;

class AddArc : public virtual ::apache::thrift::TBase {
 public:

  AddArc(const AddArc&);
  AddArc& operator=(const AddArc&);
  AddArc() noexcept
         : level(static_cast<LoggerLevel::type>(0)),
           radius(0),
           start_angle(0),
           span_angel(0),
           color() {
  }

  virtual ~AddArc() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  RpcVector2D center;
  double radius;
  double start_angle;
  double span_angel;
  std::string color;

  _AddArc__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_center(const RpcVector2D& val);

  void __set_radius(const double val);

  void __set_start_angle(const double val);

  void __set_span_angel(const double val);

  void __set_color(const std::string& val);

  bool operator == (const AddArc & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(center == rhs.center))
      return false;
    if (!(radius == rhs.radius))
      return false;
    if (!(start_angle == rhs.start_angle))
      return false;
    if (!(span_angel == rhs.span_angel))
      return false;
    if (!(color == rhs.color))
      return false;
    return true;
  }
  bool operator != (const AddArc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddArc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddArc &a, AddArc &b);

std::ostream& operator<<(std::ostream& out, const AddArc& obj);

typedef struct _AddCircle__isset {
  _AddCircle__isset() : level(false), center(false), radius(false), color(false), fill(false) {}
  bool level :1;
  bool center :1;
  bool radius :1;
  bool color :1;
  bool fill :1;
} _AddCircle__isset;

class AddCircle : public virtual ::apache::thrift::TBase {
 public:

  AddCircle(const AddCircle&);
  AddCircle& operator=(const AddCircle&);
  AddCircle() noexcept
            : level(static_cast<LoggerLevel::type>(0)),
              radius(0),
              color(),
              fill(0) {
  }

  virtual ~AddCircle() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  RpcVector2D center;
  double radius;
  std::string color;
  bool fill;

  _AddCircle__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_center(const RpcVector2D& val);

  void __set_radius(const double val);

  void __set_color(const std::string& val);

  void __set_fill(const bool val);

  bool operator == (const AddCircle & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(center == rhs.center))
      return false;
    if (!(radius == rhs.radius))
      return false;
    if (!(color == rhs.color))
      return false;
    if (!(fill == rhs.fill))
      return false;
    return true;
  }
  bool operator != (const AddCircle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddCircle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddCircle &a, AddCircle &b);

std::ostream& operator<<(std::ostream& out, const AddCircle& obj);

typedef struct _AddTriangle__isset {
  _AddTriangle__isset() : level(false), point1(false), point2(false), point3(false), color(false), fill(false) {}
  bool level :1;
  bool point1 :1;
  bool point2 :1;
  bool point3 :1;
  bool color :1;
  bool fill :1;
} _AddTriangle__isset;

class AddTriangle : public virtual ::apache::thrift::TBase {
 public:

  AddTriangle(const AddTriangle&);
  AddTriangle& operator=(const AddTriangle&);
  AddTriangle() noexcept
              : level(static_cast<LoggerLevel::type>(0)),
                color(),
                fill(0) {
  }

  virtual ~AddTriangle() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  RpcVector2D point1;
  RpcVector2D point2;
  RpcVector2D point3;
  std::string color;
  bool fill;

  _AddTriangle__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_point1(const RpcVector2D& val);

  void __set_point2(const RpcVector2D& val);

  void __set_point3(const RpcVector2D& val);

  void __set_color(const std::string& val);

  void __set_fill(const bool val);

  bool operator == (const AddTriangle & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(point1 == rhs.point1))
      return false;
    if (!(point2 == rhs.point2))
      return false;
    if (!(point3 == rhs.point3))
      return false;
    if (!(color == rhs.color))
      return false;
    if (!(fill == rhs.fill))
      return false;
    return true;
  }
  bool operator != (const AddTriangle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddTriangle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddTriangle &a, AddTriangle &b);

std::ostream& operator<<(std::ostream& out, const AddTriangle& obj);

typedef struct _AddRectangle__isset {
  _AddRectangle__isset() : level(false), left(false), top(false), length(false), width(false), color(false), fill(false) {}
  bool level :1;
  bool left :1;
  bool top :1;
  bool length :1;
  bool width :1;
  bool color :1;
  bool fill :1;
} _AddRectangle__isset;

class AddRectangle : public virtual ::apache::thrift::TBase {
 public:

  AddRectangle(const AddRectangle&);
  AddRectangle& operator=(const AddRectangle&);
  AddRectangle() noexcept
               : level(static_cast<LoggerLevel::type>(0)),
                 left(0),
                 top(0),
                 length(0),
                 width(0),
                 color(),
                 fill(0) {
  }

  virtual ~AddRectangle() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  double left;
  double top;
  double length;
  double width;
  std::string color;
  bool fill;

  _AddRectangle__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_left(const double val);

  void __set_top(const double val);

  void __set_length(const double val);

  void __set_width(const double val);

  void __set_color(const std::string& val);

  void __set_fill(const bool val);

  bool operator == (const AddRectangle & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(left == rhs.left))
      return false;
    if (!(top == rhs.top))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(width == rhs.width))
      return false;
    if (!(color == rhs.color))
      return false;
    if (!(fill == rhs.fill))
      return false;
    return true;
  }
  bool operator != (const AddRectangle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddRectangle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddRectangle &a, AddRectangle &b);

std::ostream& operator<<(std::ostream& out, const AddRectangle& obj);

typedef struct _AddSector__isset {
  _AddSector__isset() : level(false), center(false), min_radius(false), max_radius(false), start_angle(false), span_angel(false), color(false), fill(false) {}
  bool level :1;
  bool center :1;
  bool min_radius :1;
  bool max_radius :1;
  bool start_angle :1;
  bool span_angel :1;
  bool color :1;
  bool fill :1;
} _AddSector__isset;

class AddSector : public virtual ::apache::thrift::TBase {
 public:

  AddSector(const AddSector&);
  AddSector& operator=(const AddSector&);
  AddSector() noexcept
            : level(static_cast<LoggerLevel::type>(0)),
              min_radius(0),
              max_radius(0),
              start_angle(0),
              span_angel(0),
              color(),
              fill(0) {
  }

  virtual ~AddSector() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  RpcVector2D center;
  double min_radius;
  double max_radius;
  double start_angle;
  double span_angel;
  std::string color;
  bool fill;

  _AddSector__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_center(const RpcVector2D& val);

  void __set_min_radius(const double val);

  void __set_max_radius(const double val);

  void __set_start_angle(const double val);

  void __set_span_angel(const double val);

  void __set_color(const std::string& val);

  void __set_fill(const bool val);

  bool operator == (const AddSector & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(center == rhs.center))
      return false;
    if (!(min_radius == rhs.min_radius))
      return false;
    if (!(max_radius == rhs.max_radius))
      return false;
    if (!(start_angle == rhs.start_angle))
      return false;
    if (!(span_angel == rhs.span_angel))
      return false;
    if (!(color == rhs.color))
      return false;
    if (!(fill == rhs.fill))
      return false;
    return true;
  }
  bool operator != (const AddSector &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddSector & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddSector &a, AddSector &b);

std::ostream& operator<<(std::ostream& out, const AddSector& obj);

typedef struct _AddMessage__isset {
  _AddMessage__isset() : level(false), position(false), message(false), color(false) {}
  bool level :1;
  bool position :1;
  bool message :1;
  bool color :1;
} _AddMessage__isset;

class AddMessage : public virtual ::apache::thrift::TBase {
 public:

  AddMessage(const AddMessage&);
  AddMessage& operator=(const AddMessage&);
  AddMessage() noexcept
             : level(static_cast<LoggerLevel::type>(0)),
               message(),
               color() {
  }

  virtual ~AddMessage() noexcept;
  /**
   * 
   * @see LoggerLevel
   */
  LoggerLevel::type level;
  RpcVector2D position;
  std::string message;
  std::string color;

  _AddMessage__isset __isset;

  void __set_level(const LoggerLevel::type val);

  void __set_position(const RpcVector2D& val);

  void __set_message(const std::string& val);

  void __set_color(const std::string& val);

  bool operator == (const AddMessage & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(position == rhs.position))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(color == rhs.color))
      return false;
    return true;
  }
  bool operator != (const AddMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddMessage &a, AddMessage &b);

std::ostream& operator<<(std::ostream& out, const AddMessage& obj);

typedef struct _Log__isset {
  _Log__isset() : add_text(false), add_point(false), add_line(false), add_arc(false), add_circle(false), add_triangle(false), add_rectangle(false), add_sector(false), add_message(false) {}
  bool add_text :1;
  bool add_point :1;
  bool add_line :1;
  bool add_arc :1;
  bool add_circle :1;
  bool add_triangle :1;
  bool add_rectangle :1;
  bool add_sector :1;
  bool add_message :1;
} _Log__isset;

class Log : public virtual ::apache::thrift::TBase {
 public:

  Log(const Log&);
  Log& operator=(const Log&);
  Log() noexcept {
  }

  virtual ~Log() noexcept;
  AddText add_text;
  AddPoint add_point;
  AddLine add_line;
  AddArc add_arc;
  AddCircle add_circle;
  AddTriangle add_triangle;
  AddRectangle add_rectangle;
  AddSector add_sector;
  AddMessage add_message;

  _Log__isset __isset;

  void __set_add_text(const AddText& val);

  void __set_add_point(const AddPoint& val);

  void __set_add_line(const AddLine& val);

  void __set_add_arc(const AddArc& val);

  void __set_add_circle(const AddCircle& val);

  void __set_add_triangle(const AddTriangle& val);

  void __set_add_rectangle(const AddRectangle& val);

  void __set_add_sector(const AddSector& val);

  void __set_add_message(const AddMessage& val);

  bool operator == (const Log & rhs) const
  {
    if (__isset.add_text != rhs.__isset.add_text)
      return false;
    else if (__isset.add_text && !(add_text == rhs.add_text))
      return false;
    if (__isset.add_point != rhs.__isset.add_point)
      return false;
    else if (__isset.add_point && !(add_point == rhs.add_point))
      return false;
    if (__isset.add_line != rhs.__isset.add_line)
      return false;
    else if (__isset.add_line && !(add_line == rhs.add_line))
      return false;
    if (__isset.add_arc != rhs.__isset.add_arc)
      return false;
    else if (__isset.add_arc && !(add_arc == rhs.add_arc))
      return false;
    if (__isset.add_circle != rhs.__isset.add_circle)
      return false;
    else if (__isset.add_circle && !(add_circle == rhs.add_circle))
      return false;
    if (__isset.add_triangle != rhs.__isset.add_triangle)
      return false;
    else if (__isset.add_triangle && !(add_triangle == rhs.add_triangle))
      return false;
    if (__isset.add_rectangle != rhs.__isset.add_rectangle)
      return false;
    else if (__isset.add_rectangle && !(add_rectangle == rhs.add_rectangle))
      return false;
    if (__isset.add_sector != rhs.__isset.add_sector)
      return false;
    else if (__isset.add_sector && !(add_sector == rhs.add_sector))
      return false;
    if (__isset.add_message != rhs.__isset.add_message)
      return false;
    else if (__isset.add_message && !(add_message == rhs.add_message))
      return false;
    return true;
  }
  bool operator != (const Log &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Log & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Log &a, Log &b);

std::ostream& operator<<(std::ostream& out, const Log& obj);

typedef struct _DebugClient__isset {
  _DebugClient__isset() : message(false) {}
  bool message :1;
} _DebugClient__isset;

class DebugClient : public virtual ::apache::thrift::TBase {
 public:

  DebugClient(const DebugClient&);
  DebugClient& operator=(const DebugClient&);
  DebugClient() noexcept
              : message() {
  }

  virtual ~DebugClient() noexcept;
  std::string message;

  _DebugClient__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const DebugClient & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const DebugClient &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DebugClient & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DebugClient &a, DebugClient &b);

std::ostream& operator<<(std::ostream& out, const DebugClient& obj);

typedef struct _Body_GoToPoint__isset {
  _Body_GoToPoint__isset() : target_point(false), distance_threshold(false), max_dash_power(false) {}
  bool target_point :1;
  bool distance_threshold :1;
  bool max_dash_power :1;
} _Body_GoToPoint__isset;

class Body_GoToPoint : public virtual ::apache::thrift::TBase {
 public:

  Body_GoToPoint(const Body_GoToPoint&) noexcept;
  Body_GoToPoint& operator=(const Body_GoToPoint&) noexcept;
  Body_GoToPoint() noexcept
                 : distance_threshold(0),
                   max_dash_power(0) {
  }

  virtual ~Body_GoToPoint() noexcept;
  RpcVector2D target_point;
  double distance_threshold;
  double max_dash_power;

  _Body_GoToPoint__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_distance_threshold(const double val);

  void __set_max_dash_power(const double val);

  bool operator == (const Body_GoToPoint & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(distance_threshold == rhs.distance_threshold))
      return false;
    if (!(max_dash_power == rhs.max_dash_power))
      return false;
    return true;
  }
  bool operator != (const Body_GoToPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_GoToPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_GoToPoint &a, Body_GoToPoint &b);

std::ostream& operator<<(std::ostream& out, const Body_GoToPoint& obj);

typedef struct _Body_SmartKick__isset {
  _Body_SmartKick__isset() : target_point(false), first_speed(false), first_speed_threshold(false), max_steps(false) {}
  bool target_point :1;
  bool first_speed :1;
  bool first_speed_threshold :1;
  bool max_steps :1;
} _Body_SmartKick__isset;

class Body_SmartKick : public virtual ::apache::thrift::TBase {
 public:

  Body_SmartKick(const Body_SmartKick&) noexcept;
  Body_SmartKick& operator=(const Body_SmartKick&) noexcept;
  Body_SmartKick() noexcept
                 : first_speed(0),
                   first_speed_threshold(0),
                   max_steps(0) {
  }

  virtual ~Body_SmartKick() noexcept;
  RpcVector2D target_point;
  double first_speed;
  double first_speed_threshold;
  int32_t max_steps;

  _Body_SmartKick__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_first_speed(const double val);

  void __set_first_speed_threshold(const double val);

  void __set_max_steps(const int32_t val);

  bool operator == (const Body_SmartKick & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(first_speed == rhs.first_speed))
      return false;
    if (!(first_speed_threshold == rhs.first_speed_threshold))
      return false;
    if (!(max_steps == rhs.max_steps))
      return false;
    return true;
  }
  bool operator != (const Body_SmartKick &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_SmartKick & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_SmartKick &a, Body_SmartKick &b);

std::ostream& operator<<(std::ostream& out, const Body_SmartKick& obj);

typedef struct _Bhv_BeforeKickOff__isset {
  _Bhv_BeforeKickOff__isset() : point(false) {}
  bool point :1;
} _Bhv_BeforeKickOff__isset;

class Bhv_BeforeKickOff : public virtual ::apache::thrift::TBase {
 public:

  Bhv_BeforeKickOff(const Bhv_BeforeKickOff&) noexcept;
  Bhv_BeforeKickOff& operator=(const Bhv_BeforeKickOff&) noexcept;
  Bhv_BeforeKickOff() noexcept {
  }

  virtual ~Bhv_BeforeKickOff() noexcept;
  RpcVector2D point;

  _Bhv_BeforeKickOff__isset __isset;

  void __set_point(const RpcVector2D& val);

  bool operator == (const Bhv_BeforeKickOff & rhs) const
  {
    if (!(point == rhs.point))
      return false;
    return true;
  }
  bool operator != (const Bhv_BeforeKickOff &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_BeforeKickOff & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_BeforeKickOff &a, Bhv_BeforeKickOff &b);

std::ostream& operator<<(std::ostream& out, const Bhv_BeforeKickOff& obj);


class Bhv_BodyNeckToBall : public virtual ::apache::thrift::TBase {
 public:

  Bhv_BodyNeckToBall(const Bhv_BodyNeckToBall&) noexcept;
  Bhv_BodyNeckToBall& operator=(const Bhv_BodyNeckToBall&) noexcept;
  Bhv_BodyNeckToBall() noexcept {
  }

  virtual ~Bhv_BodyNeckToBall() noexcept;

  bool operator == (const Bhv_BodyNeckToBall & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Bhv_BodyNeckToBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_BodyNeckToBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_BodyNeckToBall &a, Bhv_BodyNeckToBall &b);

std::ostream& operator<<(std::ostream& out, const Bhv_BodyNeckToBall& obj);

typedef struct _Bhv_BodyNeckToPoint__isset {
  _Bhv_BodyNeckToPoint__isset() : point(false) {}
  bool point :1;
} _Bhv_BodyNeckToPoint__isset;

class Bhv_BodyNeckToPoint : public virtual ::apache::thrift::TBase {
 public:

  Bhv_BodyNeckToPoint(const Bhv_BodyNeckToPoint&) noexcept;
  Bhv_BodyNeckToPoint& operator=(const Bhv_BodyNeckToPoint&) noexcept;
  Bhv_BodyNeckToPoint() noexcept {
  }

  virtual ~Bhv_BodyNeckToPoint() noexcept;
  RpcVector2D point;

  _Bhv_BodyNeckToPoint__isset __isset;

  void __set_point(const RpcVector2D& val);

  bool operator == (const Bhv_BodyNeckToPoint & rhs) const
  {
    if (!(point == rhs.point))
      return false;
    return true;
  }
  bool operator != (const Bhv_BodyNeckToPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_BodyNeckToPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_BodyNeckToPoint &a, Bhv_BodyNeckToPoint &b);

std::ostream& operator<<(std::ostream& out, const Bhv_BodyNeckToPoint& obj);


class Bhv_Emergency : public virtual ::apache::thrift::TBase {
 public:

  Bhv_Emergency(const Bhv_Emergency&) noexcept;
  Bhv_Emergency& operator=(const Bhv_Emergency&) noexcept;
  Bhv_Emergency() noexcept {
  }

  virtual ~Bhv_Emergency() noexcept;

  bool operator == (const Bhv_Emergency & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Bhv_Emergency &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_Emergency & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_Emergency &a, Bhv_Emergency &b);

std::ostream& operator<<(std::ostream& out, const Bhv_Emergency& obj);

typedef struct _Bhv_GoToPointLookBall__isset {
  _Bhv_GoToPointLookBall__isset() : target_point(false), distance_threshold(false), max_dash_power(false) {}
  bool target_point :1;
  bool distance_threshold :1;
  bool max_dash_power :1;
} _Bhv_GoToPointLookBall__isset;

class Bhv_GoToPointLookBall : public virtual ::apache::thrift::TBase {
 public:

  Bhv_GoToPointLookBall(const Bhv_GoToPointLookBall&) noexcept;
  Bhv_GoToPointLookBall& operator=(const Bhv_GoToPointLookBall&) noexcept;
  Bhv_GoToPointLookBall() noexcept
                        : distance_threshold(0),
                          max_dash_power(0) {
  }

  virtual ~Bhv_GoToPointLookBall() noexcept;
  RpcVector2D target_point;
  double distance_threshold;
  double max_dash_power;

  _Bhv_GoToPointLookBall__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_distance_threshold(const double val);

  void __set_max_dash_power(const double val);

  bool operator == (const Bhv_GoToPointLookBall & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(distance_threshold == rhs.distance_threshold))
      return false;
    if (!(max_dash_power == rhs.max_dash_power))
      return false;
    return true;
  }
  bool operator != (const Bhv_GoToPointLookBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_GoToPointLookBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_GoToPointLookBall &a, Bhv_GoToPointLookBall &b);

std::ostream& operator<<(std::ostream& out, const Bhv_GoToPointLookBall& obj);

typedef struct _Bhv_NeckBodyToBall__isset {
  _Bhv_NeckBodyToBall__isset() : angle_buf(false) {}
  bool angle_buf :1;
} _Bhv_NeckBodyToBall__isset;

class Bhv_NeckBodyToBall : public virtual ::apache::thrift::TBase {
 public:

  Bhv_NeckBodyToBall(const Bhv_NeckBodyToBall&) noexcept;
  Bhv_NeckBodyToBall& operator=(const Bhv_NeckBodyToBall&) noexcept;
  Bhv_NeckBodyToBall() noexcept
                     : angle_buf(0) {
  }

  virtual ~Bhv_NeckBodyToBall() noexcept;
  double angle_buf;

  _Bhv_NeckBodyToBall__isset __isset;

  void __set_angle_buf(const double val);

  bool operator == (const Bhv_NeckBodyToBall & rhs) const
  {
    if (!(angle_buf == rhs.angle_buf))
      return false;
    return true;
  }
  bool operator != (const Bhv_NeckBodyToBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_NeckBodyToBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_NeckBodyToBall &a, Bhv_NeckBodyToBall &b);

std::ostream& operator<<(std::ostream& out, const Bhv_NeckBodyToBall& obj);

typedef struct _Bhv_NeckBodyToPoint__isset {
  _Bhv_NeckBodyToPoint__isset() : point(false), angle_buf(false) {}
  bool point :1;
  bool angle_buf :1;
} _Bhv_NeckBodyToPoint__isset;

class Bhv_NeckBodyToPoint : public virtual ::apache::thrift::TBase {
 public:

  Bhv_NeckBodyToPoint(const Bhv_NeckBodyToPoint&) noexcept;
  Bhv_NeckBodyToPoint& operator=(const Bhv_NeckBodyToPoint&) noexcept;
  Bhv_NeckBodyToPoint() noexcept
                      : angle_buf(0) {
  }

  virtual ~Bhv_NeckBodyToPoint() noexcept;
  RpcVector2D point;
  double angle_buf;

  _Bhv_NeckBodyToPoint__isset __isset;

  void __set_point(const RpcVector2D& val);

  void __set_angle_buf(const double val);

  bool operator == (const Bhv_NeckBodyToPoint & rhs) const
  {
    if (!(point == rhs.point))
      return false;
    if (!(angle_buf == rhs.angle_buf))
      return false;
    return true;
  }
  bool operator != (const Bhv_NeckBodyToPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_NeckBodyToPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_NeckBodyToPoint &a, Bhv_NeckBodyToPoint &b);

std::ostream& operator<<(std::ostream& out, const Bhv_NeckBodyToPoint& obj);


class Bhv_ScanField : public virtual ::apache::thrift::TBase {
 public:

  Bhv_ScanField(const Bhv_ScanField&) noexcept;
  Bhv_ScanField& operator=(const Bhv_ScanField&) noexcept;
  Bhv_ScanField() noexcept {
  }

  virtual ~Bhv_ScanField() noexcept;

  bool operator == (const Bhv_ScanField & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Bhv_ScanField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bhv_ScanField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bhv_ScanField &a, Bhv_ScanField &b);

std::ostream& operator<<(std::ostream& out, const Bhv_ScanField& obj);


class Body_AdvanceBall : public virtual ::apache::thrift::TBase {
 public:

  Body_AdvanceBall(const Body_AdvanceBall&) noexcept;
  Body_AdvanceBall& operator=(const Body_AdvanceBall&) noexcept;
  Body_AdvanceBall() noexcept {
  }

  virtual ~Body_AdvanceBall() noexcept;

  bool operator == (const Body_AdvanceBall & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Body_AdvanceBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_AdvanceBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_AdvanceBall &a, Body_AdvanceBall &b);

std::ostream& operator<<(std::ostream& out, const Body_AdvanceBall& obj);


class Body_ClearBall : public virtual ::apache::thrift::TBase {
 public:

  Body_ClearBall(const Body_ClearBall&) noexcept;
  Body_ClearBall& operator=(const Body_ClearBall&) noexcept;
  Body_ClearBall() noexcept {
  }

  virtual ~Body_ClearBall() noexcept;

  bool operator == (const Body_ClearBall & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Body_ClearBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_ClearBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_ClearBall &a, Body_ClearBall &b);

std::ostream& operator<<(std::ostream& out, const Body_ClearBall& obj);

typedef struct _Body_Dribble__isset {
  _Body_Dribble__isset() : target_point(false), distance_threshold(false), dash_power(false), dash_count(false), dodge(false) {}
  bool target_point :1;
  bool distance_threshold :1;
  bool dash_power :1;
  bool dash_count :1;
  bool dodge :1;
} _Body_Dribble__isset;

class Body_Dribble : public virtual ::apache::thrift::TBase {
 public:

  Body_Dribble(const Body_Dribble&) noexcept;
  Body_Dribble& operator=(const Body_Dribble&) noexcept;
  Body_Dribble() noexcept
               : distance_threshold(0),
                 dash_power(0),
                 dash_count(0),
                 dodge(0) {
  }

  virtual ~Body_Dribble() noexcept;
  RpcVector2D target_point;
  double distance_threshold;
  double dash_power;
  int32_t dash_count;
  bool dodge;

  _Body_Dribble__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_distance_threshold(const double val);

  void __set_dash_power(const double val);

  void __set_dash_count(const int32_t val);

  void __set_dodge(const bool val);

  bool operator == (const Body_Dribble & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(distance_threshold == rhs.distance_threshold))
      return false;
    if (!(dash_power == rhs.dash_power))
      return false;
    if (!(dash_count == rhs.dash_count))
      return false;
    if (!(dodge == rhs.dodge))
      return false;
    return true;
  }
  bool operator != (const Body_Dribble &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_Dribble & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_Dribble &a, Body_Dribble &b);

std::ostream& operator<<(std::ostream& out, const Body_Dribble& obj);

typedef struct _Body_GoToPointDodge__isset {
  _Body_GoToPointDodge__isset() : target_point(false), dash_power(false) {}
  bool target_point :1;
  bool dash_power :1;
} _Body_GoToPointDodge__isset;

class Body_GoToPointDodge : public virtual ::apache::thrift::TBase {
 public:

  Body_GoToPointDodge(const Body_GoToPointDodge&) noexcept;
  Body_GoToPointDodge& operator=(const Body_GoToPointDodge&) noexcept;
  Body_GoToPointDodge() noexcept
                      : dash_power(0) {
  }

  virtual ~Body_GoToPointDodge() noexcept;
  RpcVector2D target_point;
  double dash_power;

  _Body_GoToPointDodge__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_dash_power(const double val);

  bool operator == (const Body_GoToPointDodge & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(dash_power == rhs.dash_power))
      return false;
    return true;
  }
  bool operator != (const Body_GoToPointDodge &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_GoToPointDodge & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_GoToPointDodge &a, Body_GoToPointDodge &b);

std::ostream& operator<<(std::ostream& out, const Body_GoToPointDodge& obj);

typedef struct _Body_HoldBall__isset {
  _Body_HoldBall__isset() : do_turn(false), turn_target_point(false), kick_target_point(false) {}
  bool do_turn :1;
  bool turn_target_point :1;
  bool kick_target_point :1;
} _Body_HoldBall__isset;

class Body_HoldBall : public virtual ::apache::thrift::TBase {
 public:

  Body_HoldBall(const Body_HoldBall&) noexcept;
  Body_HoldBall& operator=(const Body_HoldBall&) noexcept;
  Body_HoldBall() noexcept
                : do_turn(0) {
  }

  virtual ~Body_HoldBall() noexcept;
  bool do_turn;
  RpcVector2D turn_target_point;
  RpcVector2D kick_target_point;

  _Body_HoldBall__isset __isset;

  void __set_do_turn(const bool val);

  void __set_turn_target_point(const RpcVector2D& val);

  void __set_kick_target_point(const RpcVector2D& val);

  bool operator == (const Body_HoldBall & rhs) const
  {
    if (!(do_turn == rhs.do_turn))
      return false;
    if (!(turn_target_point == rhs.turn_target_point))
      return false;
    if (!(kick_target_point == rhs.kick_target_point))
      return false;
    return true;
  }
  bool operator != (const Body_HoldBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_HoldBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_HoldBall &a, Body_HoldBall &b);

std::ostream& operator<<(std::ostream& out, const Body_HoldBall& obj);

typedef struct _Body_Intercept__isset {
  _Body_Intercept__isset() : save_recovery(false), face_point(false) {}
  bool save_recovery :1;
  bool face_point :1;
} _Body_Intercept__isset;

class Body_Intercept : public virtual ::apache::thrift::TBase {
 public:

  Body_Intercept(const Body_Intercept&) noexcept;
  Body_Intercept& operator=(const Body_Intercept&) noexcept;
  Body_Intercept() noexcept
                 : save_recovery(0) {
  }

  virtual ~Body_Intercept() noexcept;
  bool save_recovery;
  RpcVector2D face_point;

  _Body_Intercept__isset __isset;

  void __set_save_recovery(const bool val);

  void __set_face_point(const RpcVector2D& val);

  bool operator == (const Body_Intercept & rhs) const
  {
    if (!(save_recovery == rhs.save_recovery))
      return false;
    if (!(face_point == rhs.face_point))
      return false;
    return true;
  }
  bool operator != (const Body_Intercept &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_Intercept & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_Intercept &a, Body_Intercept &b);

std::ostream& operator<<(std::ostream& out, const Body_Intercept& obj);

typedef struct _Body_KickOneStep__isset {
  _Body_KickOneStep__isset() : target_point(false), first_speed(false), force_mode(false) {}
  bool target_point :1;
  bool first_speed :1;
  bool force_mode :1;
} _Body_KickOneStep__isset;

class Body_KickOneStep : public virtual ::apache::thrift::TBase {
 public:

  Body_KickOneStep(const Body_KickOneStep&) noexcept;
  Body_KickOneStep& operator=(const Body_KickOneStep&) noexcept;
  Body_KickOneStep() noexcept
                   : first_speed(0),
                     force_mode(0) {
  }

  virtual ~Body_KickOneStep() noexcept;
  RpcVector2D target_point;
  double first_speed;
  bool force_mode;

  _Body_KickOneStep__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_first_speed(const double val);

  void __set_force_mode(const bool val);

  bool operator == (const Body_KickOneStep & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(first_speed == rhs.first_speed))
      return false;
    if (!(force_mode == rhs.force_mode))
      return false;
    return true;
  }
  bool operator != (const Body_KickOneStep &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_KickOneStep & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_KickOneStep &a, Body_KickOneStep &b);

std::ostream& operator<<(std::ostream& out, const Body_KickOneStep& obj);


class Body_StopBall : public virtual ::apache::thrift::TBase {
 public:

  Body_StopBall(const Body_StopBall&) noexcept;
  Body_StopBall& operator=(const Body_StopBall&) noexcept;
  Body_StopBall() noexcept {
  }

  virtual ~Body_StopBall() noexcept;

  bool operator == (const Body_StopBall & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Body_StopBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_StopBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_StopBall &a, Body_StopBall &b);

std::ostream& operator<<(std::ostream& out, const Body_StopBall& obj);

typedef struct _Body_StopDash__isset {
  _Body_StopDash__isset() : save_recovery(false) {}
  bool save_recovery :1;
} _Body_StopDash__isset;

class Body_StopDash : public virtual ::apache::thrift::TBase {
 public:

  Body_StopDash(const Body_StopDash&) noexcept;
  Body_StopDash& operator=(const Body_StopDash&) noexcept;
  Body_StopDash() noexcept
                : save_recovery(0) {
  }

  virtual ~Body_StopDash() noexcept;
  bool save_recovery;

  _Body_StopDash__isset __isset;

  void __set_save_recovery(const bool val);

  bool operator == (const Body_StopDash & rhs) const
  {
    if (!(save_recovery == rhs.save_recovery))
      return false;
    return true;
  }
  bool operator != (const Body_StopDash &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_StopDash & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_StopDash &a, Body_StopDash &b);

std::ostream& operator<<(std::ostream& out, const Body_StopDash& obj);

typedef struct _Body_TackleToPoint__isset {
  _Body_TackleToPoint__isset() : target_point(false), min_probability(false), min_speed(false) {}
  bool target_point :1;
  bool min_probability :1;
  bool min_speed :1;
} _Body_TackleToPoint__isset;

class Body_TackleToPoint : public virtual ::apache::thrift::TBase {
 public:

  Body_TackleToPoint(const Body_TackleToPoint&) noexcept;
  Body_TackleToPoint& operator=(const Body_TackleToPoint&) noexcept;
  Body_TackleToPoint() noexcept
                     : min_probability(0),
                       min_speed(0) {
  }

  virtual ~Body_TackleToPoint() noexcept;
  RpcVector2D target_point;
  double min_probability;
  double min_speed;

  _Body_TackleToPoint__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_min_probability(const double val);

  void __set_min_speed(const double val);

  bool operator == (const Body_TackleToPoint & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(min_probability == rhs.min_probability))
      return false;
    if (!(min_speed == rhs.min_speed))
      return false;
    return true;
  }
  bool operator != (const Body_TackleToPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_TackleToPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_TackleToPoint &a, Body_TackleToPoint &b);

std::ostream& operator<<(std::ostream& out, const Body_TackleToPoint& obj);

typedef struct _Body_TurnToAngle__isset {
  _Body_TurnToAngle__isset() : angle(false) {}
  bool angle :1;
} _Body_TurnToAngle__isset;

class Body_TurnToAngle : public virtual ::apache::thrift::TBase {
 public:

  Body_TurnToAngle(const Body_TurnToAngle&) noexcept;
  Body_TurnToAngle& operator=(const Body_TurnToAngle&) noexcept;
  Body_TurnToAngle() noexcept
                   : angle(0) {
  }

  virtual ~Body_TurnToAngle() noexcept;
  double angle;

  _Body_TurnToAngle__isset __isset;

  void __set_angle(const double val);

  bool operator == (const Body_TurnToAngle & rhs) const
  {
    if (!(angle == rhs.angle))
      return false;
    return true;
  }
  bool operator != (const Body_TurnToAngle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_TurnToAngle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_TurnToAngle &a, Body_TurnToAngle &b);

std::ostream& operator<<(std::ostream& out, const Body_TurnToAngle& obj);

typedef struct _Body_TurnToBall__isset {
  _Body_TurnToBall__isset() : cycle(false) {}
  bool cycle :1;
} _Body_TurnToBall__isset;

class Body_TurnToBall : public virtual ::apache::thrift::TBase {
 public:

  Body_TurnToBall(const Body_TurnToBall&) noexcept;
  Body_TurnToBall& operator=(const Body_TurnToBall&) noexcept;
  Body_TurnToBall() noexcept
                  : cycle(0) {
  }

  virtual ~Body_TurnToBall() noexcept;
  int32_t cycle;

  _Body_TurnToBall__isset __isset;

  void __set_cycle(const int32_t val);

  bool operator == (const Body_TurnToBall & rhs) const
  {
    if (!(cycle == rhs.cycle))
      return false;
    return true;
  }
  bool operator != (const Body_TurnToBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_TurnToBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_TurnToBall &a, Body_TurnToBall &b);

std::ostream& operator<<(std::ostream& out, const Body_TurnToBall& obj);

typedef struct _Body_TurnToPoint__isset {
  _Body_TurnToPoint__isset() : target_point(false), cycle(false) {}
  bool target_point :1;
  bool cycle :1;
} _Body_TurnToPoint__isset;

class Body_TurnToPoint : public virtual ::apache::thrift::TBase {
 public:

  Body_TurnToPoint(const Body_TurnToPoint&) noexcept;
  Body_TurnToPoint& operator=(const Body_TurnToPoint&) noexcept;
  Body_TurnToPoint() noexcept
                   : cycle(0) {
  }

  virtual ~Body_TurnToPoint() noexcept;
  RpcVector2D target_point;
  int32_t cycle;

  _Body_TurnToPoint__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  void __set_cycle(const int32_t val);

  bool operator == (const Body_TurnToPoint & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    if (!(cycle == rhs.cycle))
      return false;
    return true;
  }
  bool operator != (const Body_TurnToPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body_TurnToPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body_TurnToPoint &a, Body_TurnToPoint &b);

std::ostream& operator<<(std::ostream& out, const Body_TurnToPoint& obj);

typedef struct _Focus_MoveToPoint__isset {
  _Focus_MoveToPoint__isset() : target_point(false) {}
  bool target_point :1;
} _Focus_MoveToPoint__isset;

class Focus_MoveToPoint : public virtual ::apache::thrift::TBase {
 public:

  Focus_MoveToPoint(const Focus_MoveToPoint&) noexcept;
  Focus_MoveToPoint& operator=(const Focus_MoveToPoint&) noexcept;
  Focus_MoveToPoint() noexcept {
  }

  virtual ~Focus_MoveToPoint() noexcept;
  RpcVector2D target_point;

  _Focus_MoveToPoint__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  bool operator == (const Focus_MoveToPoint & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    return true;
  }
  bool operator != (const Focus_MoveToPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Focus_MoveToPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Focus_MoveToPoint &a, Focus_MoveToPoint &b);

std::ostream& operator<<(std::ostream& out, const Focus_MoveToPoint& obj);


class Focus_Reset : public virtual ::apache::thrift::TBase {
 public:

  Focus_Reset(const Focus_Reset&) noexcept;
  Focus_Reset& operator=(const Focus_Reset&) noexcept;
  Focus_Reset() noexcept {
  }

  virtual ~Focus_Reset() noexcept;

  bool operator == (const Focus_Reset & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Focus_Reset &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Focus_Reset & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Focus_Reset &a, Focus_Reset &b);

std::ostream& operator<<(std::ostream& out, const Focus_Reset& obj);


class Neck_ScanField : public virtual ::apache::thrift::TBase {
 public:

  Neck_ScanField(const Neck_ScanField&) noexcept;
  Neck_ScanField& operator=(const Neck_ScanField&) noexcept;
  Neck_ScanField() noexcept {
  }

  virtual ~Neck_ScanField() noexcept;

  bool operator == (const Neck_ScanField & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Neck_ScanField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_ScanField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_ScanField &a, Neck_ScanField &b);

std::ostream& operator<<(std::ostream& out, const Neck_ScanField& obj);


class Neck_ScanPlayers : public virtual ::apache::thrift::TBase {
 public:

  Neck_ScanPlayers(const Neck_ScanPlayers&) noexcept;
  Neck_ScanPlayers& operator=(const Neck_ScanPlayers&) noexcept;
  Neck_ScanPlayers() noexcept {
  }

  virtual ~Neck_ScanPlayers() noexcept;

  bool operator == (const Neck_ScanPlayers & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Neck_ScanPlayers &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_ScanPlayers & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_ScanPlayers &a, Neck_ScanPlayers &b);

std::ostream& operator<<(std::ostream& out, const Neck_ScanPlayers& obj);

typedef struct _Neck_TurnToBallAndPlayer__isset {
  _Neck_TurnToBallAndPlayer__isset() : side(false), uniform_number(false), count_threshold(false) {}
  bool side :1;
  bool uniform_number :1;
  bool count_threshold :1;
} _Neck_TurnToBallAndPlayer__isset;

class Neck_TurnToBallAndPlayer : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToBallAndPlayer(const Neck_TurnToBallAndPlayer&) noexcept;
  Neck_TurnToBallAndPlayer& operator=(const Neck_TurnToBallAndPlayer&) noexcept;
  Neck_TurnToBallAndPlayer() noexcept
                           : side(static_cast<Side::type>(0)),
                             uniform_number(0),
                             count_threshold(0) {
  }

  virtual ~Neck_TurnToBallAndPlayer() noexcept;
  /**
   * 
   * @see Side
   */
  Side::type side;
  int32_t uniform_number;
  int32_t count_threshold;

  _Neck_TurnToBallAndPlayer__isset __isset;

  void __set_side(const Side::type val);

  void __set_uniform_number(const int32_t val);

  void __set_count_threshold(const int32_t val);

  bool operator == (const Neck_TurnToBallAndPlayer & rhs) const
  {
    if (!(side == rhs.side))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(count_threshold == rhs.count_threshold))
      return false;
    return true;
  }
  bool operator != (const Neck_TurnToBallAndPlayer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToBallAndPlayer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToBallAndPlayer &a, Neck_TurnToBallAndPlayer &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToBallAndPlayer& obj);

typedef struct _Neck_TurnToBallOrScan__isset {
  _Neck_TurnToBallOrScan__isset() : count_threshold(false) {}
  bool count_threshold :1;
} _Neck_TurnToBallOrScan__isset;

class Neck_TurnToBallOrScan : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToBallOrScan(const Neck_TurnToBallOrScan&) noexcept;
  Neck_TurnToBallOrScan& operator=(const Neck_TurnToBallOrScan&) noexcept;
  Neck_TurnToBallOrScan() noexcept
                        : count_threshold(0) {
  }

  virtual ~Neck_TurnToBallOrScan() noexcept;
  int32_t count_threshold;

  _Neck_TurnToBallOrScan__isset __isset;

  void __set_count_threshold(const int32_t val);

  bool operator == (const Neck_TurnToBallOrScan & rhs) const
  {
    if (!(count_threshold == rhs.count_threshold))
      return false;
    return true;
  }
  bool operator != (const Neck_TurnToBallOrScan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToBallOrScan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToBallOrScan &a, Neck_TurnToBallOrScan &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToBallOrScan& obj);


class Neck_TurnToBall : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToBall(const Neck_TurnToBall&) noexcept;
  Neck_TurnToBall& operator=(const Neck_TurnToBall&) noexcept;
  Neck_TurnToBall() noexcept {
  }

  virtual ~Neck_TurnToBall() noexcept;

  bool operator == (const Neck_TurnToBall & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Neck_TurnToBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToBall &a, Neck_TurnToBall &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToBall& obj);

typedef struct _Neck_TurnToGoalieOrScan__isset {
  _Neck_TurnToGoalieOrScan__isset() : count_threshold(false) {}
  bool count_threshold :1;
} _Neck_TurnToGoalieOrScan__isset;

class Neck_TurnToGoalieOrScan : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToGoalieOrScan(const Neck_TurnToGoalieOrScan&) noexcept;
  Neck_TurnToGoalieOrScan& operator=(const Neck_TurnToGoalieOrScan&) noexcept;
  Neck_TurnToGoalieOrScan() noexcept
                          : count_threshold(0) {
  }

  virtual ~Neck_TurnToGoalieOrScan() noexcept;
  int32_t count_threshold;

  _Neck_TurnToGoalieOrScan__isset __isset;

  void __set_count_threshold(const int32_t val);

  bool operator == (const Neck_TurnToGoalieOrScan & rhs) const
  {
    if (!(count_threshold == rhs.count_threshold))
      return false;
    return true;
  }
  bool operator != (const Neck_TurnToGoalieOrScan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToGoalieOrScan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToGoalieOrScan &a, Neck_TurnToGoalieOrScan &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToGoalieOrScan& obj);


class Neck_TurnToLowConfTeammate : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToLowConfTeammate(const Neck_TurnToLowConfTeammate&) noexcept;
  Neck_TurnToLowConfTeammate& operator=(const Neck_TurnToLowConfTeammate&) noexcept;
  Neck_TurnToLowConfTeammate() noexcept {
  }

  virtual ~Neck_TurnToLowConfTeammate() noexcept;

  bool operator == (const Neck_TurnToLowConfTeammate & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Neck_TurnToLowConfTeammate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToLowConfTeammate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToLowConfTeammate &a, Neck_TurnToLowConfTeammate &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToLowConfTeammate& obj);

typedef struct _Neck_TurnToPlayerOrScan__isset {
  _Neck_TurnToPlayerOrScan__isset() : side(false), uniform_number(false), count_threshold(false) {}
  bool side :1;
  bool uniform_number :1;
  bool count_threshold :1;
} _Neck_TurnToPlayerOrScan__isset;

class Neck_TurnToPlayerOrScan : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToPlayerOrScan(const Neck_TurnToPlayerOrScan&) noexcept;
  Neck_TurnToPlayerOrScan& operator=(const Neck_TurnToPlayerOrScan&) noexcept;
  Neck_TurnToPlayerOrScan() noexcept
                          : side(static_cast<Side::type>(0)),
                            uniform_number(0),
                            count_threshold(0) {
  }

  virtual ~Neck_TurnToPlayerOrScan() noexcept;
  /**
   * 
   * @see Side
   */
  Side::type side;
  int32_t uniform_number;
  int32_t count_threshold;

  _Neck_TurnToPlayerOrScan__isset __isset;

  void __set_side(const Side::type val);

  void __set_uniform_number(const int32_t val);

  void __set_count_threshold(const int32_t val);

  bool operator == (const Neck_TurnToPlayerOrScan & rhs) const
  {
    if (!(side == rhs.side))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(count_threshold == rhs.count_threshold))
      return false;
    return true;
  }
  bool operator != (const Neck_TurnToPlayerOrScan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToPlayerOrScan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToPlayerOrScan &a, Neck_TurnToPlayerOrScan &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToPlayerOrScan& obj);

typedef struct _Neck_TurnToPoint__isset {
  _Neck_TurnToPoint__isset() : target_point(false) {}
  bool target_point :1;
} _Neck_TurnToPoint__isset;

class Neck_TurnToPoint : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToPoint(const Neck_TurnToPoint&) noexcept;
  Neck_TurnToPoint& operator=(const Neck_TurnToPoint&) noexcept;
  Neck_TurnToPoint() noexcept {
  }

  virtual ~Neck_TurnToPoint() noexcept;
  RpcVector2D target_point;

  _Neck_TurnToPoint__isset __isset;

  void __set_target_point(const RpcVector2D& val);

  bool operator == (const Neck_TurnToPoint & rhs) const
  {
    if (!(target_point == rhs.target_point))
      return false;
    return true;
  }
  bool operator != (const Neck_TurnToPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToPoint &a, Neck_TurnToPoint &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToPoint& obj);

typedef struct _Neck_TurnToRelative__isset {
  _Neck_TurnToRelative__isset() : angle(false) {}
  bool angle :1;
} _Neck_TurnToRelative__isset;

class Neck_TurnToRelative : public virtual ::apache::thrift::TBase {
 public:

  Neck_TurnToRelative(const Neck_TurnToRelative&) noexcept;
  Neck_TurnToRelative& operator=(const Neck_TurnToRelative&) noexcept;
  Neck_TurnToRelative() noexcept
                      : angle(0) {
  }

  virtual ~Neck_TurnToRelative() noexcept;
  double angle;

  _Neck_TurnToRelative__isset __isset;

  void __set_angle(const double val);

  bool operator == (const Neck_TurnToRelative & rhs) const
  {
    if (!(angle == rhs.angle))
      return false;
    return true;
  }
  bool operator != (const Neck_TurnToRelative &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Neck_TurnToRelative & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Neck_TurnToRelative &a, Neck_TurnToRelative &b);

std::ostream& operator<<(std::ostream& out, const Neck_TurnToRelative& obj);

typedef struct _View_ChangeWidth__isset {
  _View_ChangeWidth__isset() : view_width(false) {}
  bool view_width :1;
} _View_ChangeWidth__isset;

class View_ChangeWidth : public virtual ::apache::thrift::TBase {
 public:

  View_ChangeWidth(const View_ChangeWidth&) noexcept;
  View_ChangeWidth& operator=(const View_ChangeWidth&) noexcept;
  View_ChangeWidth() noexcept
                   : view_width(static_cast<ViewWidth::type>(0)) {
  }

  virtual ~View_ChangeWidth() noexcept;
  /**
   * 
   * @see ViewWidth
   */
  ViewWidth::type view_width;

  _View_ChangeWidth__isset __isset;

  void __set_view_width(const ViewWidth::type val);

  bool operator == (const View_ChangeWidth & rhs) const
  {
    if (!(view_width == rhs.view_width))
      return false;
    return true;
  }
  bool operator != (const View_ChangeWidth &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const View_ChangeWidth & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(View_ChangeWidth &a, View_ChangeWidth &b);

std::ostream& operator<<(std::ostream& out, const View_ChangeWidth& obj);


class View_Normal : public virtual ::apache::thrift::TBase {
 public:

  View_Normal(const View_Normal&) noexcept;
  View_Normal& operator=(const View_Normal&) noexcept;
  View_Normal() noexcept {
  }

  virtual ~View_Normal() noexcept;

  bool operator == (const View_Normal & /* rhs */) const
  {
    return true;
  }
  bool operator != (const View_Normal &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const View_Normal & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(View_Normal &a, View_Normal &b);

std::ostream& operator<<(std::ostream& out, const View_Normal& obj);


class View_Synch : public virtual ::apache::thrift::TBase {
 public:

  View_Synch(const View_Synch&) noexcept;
  View_Synch& operator=(const View_Synch&) noexcept;
  View_Synch() noexcept {
  }

  virtual ~View_Synch() noexcept;

  bool operator == (const View_Synch & /* rhs */) const
  {
    return true;
  }
  bool operator != (const View_Synch &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const View_Synch & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(View_Synch &a, View_Synch &b);

std::ostream& operator<<(std::ostream& out, const View_Synch& obj);


class View_Wide : public virtual ::apache::thrift::TBase {
 public:

  View_Wide(const View_Wide&) noexcept;
  View_Wide& operator=(const View_Wide&) noexcept;
  View_Wide() noexcept {
  }

  virtual ~View_Wide() noexcept;

  bool operator == (const View_Wide & /* rhs */) const
  {
    return true;
  }
  bool operator != (const View_Wide &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const View_Wide & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(View_Wide &a, View_Wide &b);

std::ostream& operator<<(std::ostream& out, const View_Wide& obj);


class HeliosGoalie : public virtual ::apache::thrift::TBase {
 public:

  HeliosGoalie(const HeliosGoalie&) noexcept;
  HeliosGoalie& operator=(const HeliosGoalie&) noexcept;
  HeliosGoalie() noexcept {
  }

  virtual ~HeliosGoalie() noexcept;

  bool operator == (const HeliosGoalie & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosGoalie &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosGoalie & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosGoalie &a, HeliosGoalie &b);

std::ostream& operator<<(std::ostream& out, const HeliosGoalie& obj);


class HeliosGoalieMove : public virtual ::apache::thrift::TBase {
 public:

  HeliosGoalieMove(const HeliosGoalieMove&) noexcept;
  HeliosGoalieMove& operator=(const HeliosGoalieMove&) noexcept;
  HeliosGoalieMove() noexcept {
  }

  virtual ~HeliosGoalieMove() noexcept;

  bool operator == (const HeliosGoalieMove & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosGoalieMove &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosGoalieMove & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosGoalieMove &a, HeliosGoalieMove &b);

std::ostream& operator<<(std::ostream& out, const HeliosGoalieMove& obj);


class HeliosGoalieKick : public virtual ::apache::thrift::TBase {
 public:

  HeliosGoalieKick(const HeliosGoalieKick&) noexcept;
  HeliosGoalieKick& operator=(const HeliosGoalieKick&) noexcept;
  HeliosGoalieKick() noexcept {
  }

  virtual ~HeliosGoalieKick() noexcept;

  bool operator == (const HeliosGoalieKick & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosGoalieKick &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosGoalieKick & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosGoalieKick &a, HeliosGoalieKick &b);

std::ostream& operator<<(std::ostream& out, const HeliosGoalieKick& obj);


class HeliosShoot : public virtual ::apache::thrift::TBase {
 public:

  HeliosShoot(const HeliosShoot&) noexcept;
  HeliosShoot& operator=(const HeliosShoot&) noexcept;
  HeliosShoot() noexcept {
  }

  virtual ~HeliosShoot() noexcept;

  bool operator == (const HeliosShoot & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosShoot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosShoot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosShoot &a, HeliosShoot &b);

std::ostream& operator<<(std::ostream& out, const HeliosShoot& obj);

typedef struct _HeliosChainAction__isset {
  _HeliosChainAction__isset() : direct_pass(false), lead_pass(false), through_pass(false), short_dribble(false), long_dribble(false), cross(false), simple_pass(false), simple_dribble(false), simple_shoot(false) {}
  bool direct_pass :1;
  bool lead_pass :1;
  bool through_pass :1;
  bool short_dribble :1;
  bool long_dribble :1;
  bool cross :1;
  bool simple_pass :1;
  bool simple_dribble :1;
  bool simple_shoot :1;
} _HeliosChainAction__isset;

class HeliosChainAction : public virtual ::apache::thrift::TBase {
 public:

  HeliosChainAction(const HeliosChainAction&) noexcept;
  HeliosChainAction& operator=(const HeliosChainAction&) noexcept;
  HeliosChainAction() noexcept
                    : direct_pass(0),
                      lead_pass(0),
                      through_pass(0),
                      short_dribble(0),
                      long_dribble(0),
                      cross(0),
                      simple_pass(0),
                      simple_dribble(0),
                      simple_shoot(0) {
  }

  virtual ~HeliosChainAction() noexcept;
  bool direct_pass;
  bool lead_pass;
  bool through_pass;
  bool short_dribble;
  bool long_dribble;
  bool cross;
  bool simple_pass;
  bool simple_dribble;
  bool simple_shoot;

  _HeliosChainAction__isset __isset;

  void __set_direct_pass(const bool val);

  void __set_lead_pass(const bool val);

  void __set_through_pass(const bool val);

  void __set_short_dribble(const bool val);

  void __set_long_dribble(const bool val);

  void __set_cross(const bool val);

  void __set_simple_pass(const bool val);

  void __set_simple_dribble(const bool val);

  void __set_simple_shoot(const bool val);

  bool operator == (const HeliosChainAction & rhs) const
  {
    if (!(direct_pass == rhs.direct_pass))
      return false;
    if (!(lead_pass == rhs.lead_pass))
      return false;
    if (!(through_pass == rhs.through_pass))
      return false;
    if (!(short_dribble == rhs.short_dribble))
      return false;
    if (!(long_dribble == rhs.long_dribble))
      return false;
    if (!(cross == rhs.cross))
      return false;
    if (!(simple_pass == rhs.simple_pass))
      return false;
    if (!(simple_dribble == rhs.simple_dribble))
      return false;
    if (!(simple_shoot == rhs.simple_shoot))
      return false;
    return true;
  }
  bool operator != (const HeliosChainAction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosChainAction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosChainAction &a, HeliosChainAction &b);

std::ostream& operator<<(std::ostream& out, const HeliosChainAction& obj);


class HeliosBasicOffensive : public virtual ::apache::thrift::TBase {
 public:

  HeliosBasicOffensive(const HeliosBasicOffensive&) noexcept;
  HeliosBasicOffensive& operator=(const HeliosBasicOffensive&) noexcept;
  HeliosBasicOffensive() noexcept {
  }

  virtual ~HeliosBasicOffensive() noexcept;

  bool operator == (const HeliosBasicOffensive & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosBasicOffensive &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosBasicOffensive & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosBasicOffensive &a, HeliosBasicOffensive &b);

std::ostream& operator<<(std::ostream& out, const HeliosBasicOffensive& obj);


class HeliosBasicMove : public virtual ::apache::thrift::TBase {
 public:

  HeliosBasicMove(const HeliosBasicMove&) noexcept;
  HeliosBasicMove& operator=(const HeliosBasicMove&) noexcept;
  HeliosBasicMove() noexcept {
  }

  virtual ~HeliosBasicMove() noexcept;

  bool operator == (const HeliosBasicMove & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosBasicMove &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosBasicMove & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosBasicMove &a, HeliosBasicMove &b);

std::ostream& operator<<(std::ostream& out, const HeliosBasicMove& obj);


class HeliosSetPlay : public virtual ::apache::thrift::TBase {
 public:

  HeliosSetPlay(const HeliosSetPlay&) noexcept;
  HeliosSetPlay& operator=(const HeliosSetPlay&) noexcept;
  HeliosSetPlay() noexcept {
  }

  virtual ~HeliosSetPlay() noexcept;

  bool operator == (const HeliosSetPlay & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosSetPlay &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosSetPlay & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosSetPlay &a, HeliosSetPlay &b);

std::ostream& operator<<(std::ostream& out, const HeliosSetPlay& obj);


class HeliosPenalty : public virtual ::apache::thrift::TBase {
 public:

  HeliosPenalty(const HeliosPenalty&) noexcept;
  HeliosPenalty& operator=(const HeliosPenalty&) noexcept;
  HeliosPenalty() noexcept {
  }

  virtual ~HeliosPenalty() noexcept;

  bool operator == (const HeliosPenalty & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosPenalty &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosPenalty & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosPenalty &a, HeliosPenalty &b);

std::ostream& operator<<(std::ostream& out, const HeliosPenalty& obj);


class HeliosCommunicaion : public virtual ::apache::thrift::TBase {
 public:

  HeliosCommunicaion(const HeliosCommunicaion&) noexcept;
  HeliosCommunicaion& operator=(const HeliosCommunicaion&) noexcept;
  HeliosCommunicaion() noexcept {
  }

  virtual ~HeliosCommunicaion() noexcept;

  bool operator == (const HeliosCommunicaion & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HeliosCommunicaion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeliosCommunicaion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeliosCommunicaion &a, HeliosCommunicaion &b);

std::ostream& operator<<(std::ostream& out, const HeliosCommunicaion& obj);

typedef struct _PlayerAction__isset {
  _PlayerAction__isset() : dash(false), turn(false), kick(false), tackle(false), catch_action(false), move(false), turn_neck(false), change_view(false), say(false), point_to(false), point_to_of(false), attention_to(false), attention_to_of(false), log(false), debug_client(false), body_go_to_point(false), body_smart_kick(false), bhv_before_kick_off(false), bhv_body_neck_to_ball(false), bhv_body_neck_to_point(false), bhv_emergency(false), bhv_go_to_point_look_ball(false), bhv_neck_body_to_ball(false), bhv_neck_body_to_point(false), bhv_scan_field(false), body_advance_ball(false), body_clear_ball(false), body_dribble(false), body_go_to_point_dodge(false), body_hold_ball(false), body_intercept(false), body_kick_one_step(false), body_stop_ball(false), body_stop_dash(false), body_tackle_to_point(false), body_turn_to_angle(false), body_turn_to_ball(false), body_turn_to_point(false), focus_move_to_point(false), focus_reset(false), neck_scan_field(false), neck_scan_players(false), neck_turn_to_ball_and_player(false), neck_turn_to_ball_or_scan(false), neck_turn_to_ball(false), neck_turn_to_goalie_or_scan(false), neck_turn_to_low_conf_teammate(false), neck_turn_to_player_or_scan(false), neck_turn_to_point(false), neck_turn_to_relative(false), view_change_width(false), view_normal(false), view_synch(false), view_wide(false), helios_goalie(false), helios_goalie_move(false), helios_goalie_kick(false), helios_shoot(false), helios_chain_action(false), helios_basic_offensive(false), helios_basic_move(false), helios_set_play(false), helios_penalty(false), helios_communication(false) {}
  bool dash :1;
  bool turn :1;
  bool kick :1;
  bool tackle :1;
  bool catch_action :1;
  bool move :1;
  bool turn_neck :1;
  bool change_view :1;
  bool say :1;
  bool point_to :1;
  bool point_to_of :1;
  bool attention_to :1;
  bool attention_to_of :1;
  bool log :1;
  bool debug_client :1;
  bool body_go_to_point :1;
  bool body_smart_kick :1;
  bool bhv_before_kick_off :1;
  bool bhv_body_neck_to_ball :1;
  bool bhv_body_neck_to_point :1;
  bool bhv_emergency :1;
  bool bhv_go_to_point_look_ball :1;
  bool bhv_neck_body_to_ball :1;
  bool bhv_neck_body_to_point :1;
  bool bhv_scan_field :1;
  bool body_advance_ball :1;
  bool body_clear_ball :1;
  bool body_dribble :1;
  bool body_go_to_point_dodge :1;
  bool body_hold_ball :1;
  bool body_intercept :1;
  bool body_kick_one_step :1;
  bool body_stop_ball :1;
  bool body_stop_dash :1;
  bool body_tackle_to_point :1;
  bool body_turn_to_angle :1;
  bool body_turn_to_ball :1;
  bool body_turn_to_point :1;
  bool focus_move_to_point :1;
  bool focus_reset :1;
  bool neck_scan_field :1;
  bool neck_scan_players :1;
  bool neck_turn_to_ball_and_player :1;
  bool neck_turn_to_ball_or_scan :1;
  bool neck_turn_to_ball :1;
  bool neck_turn_to_goalie_or_scan :1;
  bool neck_turn_to_low_conf_teammate :1;
  bool neck_turn_to_player_or_scan :1;
  bool neck_turn_to_point :1;
  bool neck_turn_to_relative :1;
  bool view_change_width :1;
  bool view_normal :1;
  bool view_synch :1;
  bool view_wide :1;
  bool helios_goalie :1;
  bool helios_goalie_move :1;
  bool helios_goalie_kick :1;
  bool helios_shoot :1;
  bool helios_chain_action :1;
  bool helios_basic_offensive :1;
  bool helios_basic_move :1;
  bool helios_set_play :1;
  bool helios_penalty :1;
  bool helios_communication :1;
} _PlayerAction__isset;

class PlayerAction : public virtual ::apache::thrift::TBase {
 public:

  PlayerAction(const PlayerAction&);
  PlayerAction& operator=(const PlayerAction&);
  PlayerAction() noexcept {
  }

  virtual ~PlayerAction() noexcept;
  Dash dash;
  Turn turn;
  Kick kick;
  Tackle tackle;
  Catch catch_action;
  Move move;
  TurnNeck turn_neck;
  ChangeView change_view;
  Say say;
  PointTo point_to;
  PointToOf point_to_of;
  AttentionTo attention_to;
  AttentionToOf attention_to_of;
  Log log;
  DebugClient debug_client;
  Body_GoToPoint body_go_to_point;
  Body_SmartKick body_smart_kick;
  Bhv_BeforeKickOff bhv_before_kick_off;
  Bhv_BodyNeckToBall bhv_body_neck_to_ball;
  Bhv_BodyNeckToPoint bhv_body_neck_to_point;
  Bhv_Emergency bhv_emergency;
  Bhv_GoToPointLookBall bhv_go_to_point_look_ball;
  Bhv_NeckBodyToBall bhv_neck_body_to_ball;
  Bhv_NeckBodyToPoint bhv_neck_body_to_point;
  Bhv_ScanField bhv_scan_field;
  Body_AdvanceBall body_advance_ball;
  Body_ClearBall body_clear_ball;
  Body_Dribble body_dribble;
  Body_GoToPointDodge body_go_to_point_dodge;
  Body_HoldBall body_hold_ball;
  Body_Intercept body_intercept;
  Body_KickOneStep body_kick_one_step;
  Body_StopBall body_stop_ball;
  Body_StopDash body_stop_dash;
  Body_TackleToPoint body_tackle_to_point;
  Body_TurnToAngle body_turn_to_angle;
  Body_TurnToBall body_turn_to_ball;
  Body_TurnToPoint body_turn_to_point;
  Focus_MoveToPoint focus_move_to_point;
  Focus_Reset focus_reset;
  Neck_ScanField neck_scan_field;
  Neck_ScanPlayers neck_scan_players;
  Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player;
  Neck_TurnToBallOrScan neck_turn_to_ball_or_scan;
  Neck_TurnToBall neck_turn_to_ball;
  Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan;
  Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate;
  Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan;
  Neck_TurnToPoint neck_turn_to_point;
  Neck_TurnToRelative neck_turn_to_relative;
  View_ChangeWidth view_change_width;
  View_Normal view_normal;
  View_Synch view_synch;
  View_Wide view_wide;
  HeliosGoalie helios_goalie;
  HeliosGoalieMove helios_goalie_move;
  HeliosGoalieKick helios_goalie_kick;
  HeliosShoot helios_shoot;
  HeliosChainAction helios_chain_action;
  HeliosBasicOffensive helios_basic_offensive;
  HeliosBasicMove helios_basic_move;
  HeliosSetPlay helios_set_play;
  HeliosPenalty helios_penalty;
  HeliosCommunicaion helios_communication;

  _PlayerAction__isset __isset;

  void __set_dash(const Dash& val);

  void __set_turn(const Turn& val);

  void __set_kick(const Kick& val);

  void __set_tackle(const Tackle& val);

  void __set_catch_action(const Catch& val);

  void __set_move(const Move& val);

  void __set_turn_neck(const TurnNeck& val);

  void __set_change_view(const ChangeView& val);

  void __set_say(const Say& val);

  void __set_point_to(const PointTo& val);

  void __set_point_to_of(const PointToOf& val);

  void __set_attention_to(const AttentionTo& val);

  void __set_attention_to_of(const AttentionToOf& val);

  void __set_log(const Log& val);

  void __set_debug_client(const DebugClient& val);

  void __set_body_go_to_point(const Body_GoToPoint& val);

  void __set_body_smart_kick(const Body_SmartKick& val);

  void __set_bhv_before_kick_off(const Bhv_BeforeKickOff& val);

  void __set_bhv_body_neck_to_ball(const Bhv_BodyNeckToBall& val);

  void __set_bhv_body_neck_to_point(const Bhv_BodyNeckToPoint& val);

  void __set_bhv_emergency(const Bhv_Emergency& val);

  void __set_bhv_go_to_point_look_ball(const Bhv_GoToPointLookBall& val);

  void __set_bhv_neck_body_to_ball(const Bhv_NeckBodyToBall& val);

  void __set_bhv_neck_body_to_point(const Bhv_NeckBodyToPoint& val);

  void __set_bhv_scan_field(const Bhv_ScanField& val);

  void __set_body_advance_ball(const Body_AdvanceBall& val);

  void __set_body_clear_ball(const Body_ClearBall& val);

  void __set_body_dribble(const Body_Dribble& val);

  void __set_body_go_to_point_dodge(const Body_GoToPointDodge& val);

  void __set_body_hold_ball(const Body_HoldBall& val);

  void __set_body_intercept(const Body_Intercept& val);

  void __set_body_kick_one_step(const Body_KickOneStep& val);

  void __set_body_stop_ball(const Body_StopBall& val);

  void __set_body_stop_dash(const Body_StopDash& val);

  void __set_body_tackle_to_point(const Body_TackleToPoint& val);

  void __set_body_turn_to_angle(const Body_TurnToAngle& val);

  void __set_body_turn_to_ball(const Body_TurnToBall& val);

  void __set_body_turn_to_point(const Body_TurnToPoint& val);

  void __set_focus_move_to_point(const Focus_MoveToPoint& val);

  void __set_focus_reset(const Focus_Reset& val);

  void __set_neck_scan_field(const Neck_ScanField& val);

  void __set_neck_scan_players(const Neck_ScanPlayers& val);

  void __set_neck_turn_to_ball_and_player(const Neck_TurnToBallAndPlayer& val);

  void __set_neck_turn_to_ball_or_scan(const Neck_TurnToBallOrScan& val);

  void __set_neck_turn_to_ball(const Neck_TurnToBall& val);

  void __set_neck_turn_to_goalie_or_scan(const Neck_TurnToGoalieOrScan& val);

  void __set_neck_turn_to_low_conf_teammate(const Neck_TurnToLowConfTeammate& val);

  void __set_neck_turn_to_player_or_scan(const Neck_TurnToPlayerOrScan& val);

  void __set_neck_turn_to_point(const Neck_TurnToPoint& val);

  void __set_neck_turn_to_relative(const Neck_TurnToRelative& val);

  void __set_view_change_width(const View_ChangeWidth& val);

  void __set_view_normal(const View_Normal& val);

  void __set_view_synch(const View_Synch& val);

  void __set_view_wide(const View_Wide& val);

  void __set_helios_goalie(const HeliosGoalie& val);

  void __set_helios_goalie_move(const HeliosGoalieMove& val);

  void __set_helios_goalie_kick(const HeliosGoalieKick& val);

  void __set_helios_shoot(const HeliosShoot& val);

  void __set_helios_chain_action(const HeliosChainAction& val);

  void __set_helios_basic_offensive(const HeliosBasicOffensive& val);

  void __set_helios_basic_move(const HeliosBasicMove& val);

  void __set_helios_set_play(const HeliosSetPlay& val);

  void __set_helios_penalty(const HeliosPenalty& val);

  void __set_helios_communication(const HeliosCommunicaion& val);

  bool operator == (const PlayerAction & rhs) const
  {
    if (__isset.dash != rhs.__isset.dash)
      return false;
    else if (__isset.dash && !(dash == rhs.dash))
      return false;
    if (__isset.turn != rhs.__isset.turn)
      return false;
    else if (__isset.turn && !(turn == rhs.turn))
      return false;
    if (__isset.kick != rhs.__isset.kick)
      return false;
    else if (__isset.kick && !(kick == rhs.kick))
      return false;
    if (__isset.tackle != rhs.__isset.tackle)
      return false;
    else if (__isset.tackle && !(tackle == rhs.tackle))
      return false;
    if (__isset.catch_action != rhs.__isset.catch_action)
      return false;
    else if (__isset.catch_action && !(catch_action == rhs.catch_action))
      return false;
    if (__isset.move != rhs.__isset.move)
      return false;
    else if (__isset.move && !(move == rhs.move))
      return false;
    if (__isset.turn_neck != rhs.__isset.turn_neck)
      return false;
    else if (__isset.turn_neck && !(turn_neck == rhs.turn_neck))
      return false;
    if (__isset.change_view != rhs.__isset.change_view)
      return false;
    else if (__isset.change_view && !(change_view == rhs.change_view))
      return false;
    if (__isset.say != rhs.__isset.say)
      return false;
    else if (__isset.say && !(say == rhs.say))
      return false;
    if (__isset.point_to != rhs.__isset.point_to)
      return false;
    else if (__isset.point_to && !(point_to == rhs.point_to))
      return false;
    if (__isset.point_to_of != rhs.__isset.point_to_of)
      return false;
    else if (__isset.point_to_of && !(point_to_of == rhs.point_to_of))
      return false;
    if (__isset.attention_to != rhs.__isset.attention_to)
      return false;
    else if (__isset.attention_to && !(attention_to == rhs.attention_to))
      return false;
    if (__isset.attention_to_of != rhs.__isset.attention_to_of)
      return false;
    else if (__isset.attention_to_of && !(attention_to_of == rhs.attention_to_of))
      return false;
    if (__isset.log != rhs.__isset.log)
      return false;
    else if (__isset.log && !(log == rhs.log))
      return false;
    if (__isset.debug_client != rhs.__isset.debug_client)
      return false;
    else if (__isset.debug_client && !(debug_client == rhs.debug_client))
      return false;
    if (__isset.body_go_to_point != rhs.__isset.body_go_to_point)
      return false;
    else if (__isset.body_go_to_point && !(body_go_to_point == rhs.body_go_to_point))
      return false;
    if (__isset.body_smart_kick != rhs.__isset.body_smart_kick)
      return false;
    else if (__isset.body_smart_kick && !(body_smart_kick == rhs.body_smart_kick))
      return false;
    if (__isset.bhv_before_kick_off != rhs.__isset.bhv_before_kick_off)
      return false;
    else if (__isset.bhv_before_kick_off && !(bhv_before_kick_off == rhs.bhv_before_kick_off))
      return false;
    if (__isset.bhv_body_neck_to_ball != rhs.__isset.bhv_body_neck_to_ball)
      return false;
    else if (__isset.bhv_body_neck_to_ball && !(bhv_body_neck_to_ball == rhs.bhv_body_neck_to_ball))
      return false;
    if (__isset.bhv_body_neck_to_point != rhs.__isset.bhv_body_neck_to_point)
      return false;
    else if (__isset.bhv_body_neck_to_point && !(bhv_body_neck_to_point == rhs.bhv_body_neck_to_point))
      return false;
    if (__isset.bhv_emergency != rhs.__isset.bhv_emergency)
      return false;
    else if (__isset.bhv_emergency && !(bhv_emergency == rhs.bhv_emergency))
      return false;
    if (__isset.bhv_go_to_point_look_ball != rhs.__isset.bhv_go_to_point_look_ball)
      return false;
    else if (__isset.bhv_go_to_point_look_ball && !(bhv_go_to_point_look_ball == rhs.bhv_go_to_point_look_ball))
      return false;
    if (__isset.bhv_neck_body_to_ball != rhs.__isset.bhv_neck_body_to_ball)
      return false;
    else if (__isset.bhv_neck_body_to_ball && !(bhv_neck_body_to_ball == rhs.bhv_neck_body_to_ball))
      return false;
    if (__isset.bhv_neck_body_to_point != rhs.__isset.bhv_neck_body_to_point)
      return false;
    else if (__isset.bhv_neck_body_to_point && !(bhv_neck_body_to_point == rhs.bhv_neck_body_to_point))
      return false;
    if (__isset.bhv_scan_field != rhs.__isset.bhv_scan_field)
      return false;
    else if (__isset.bhv_scan_field && !(bhv_scan_field == rhs.bhv_scan_field))
      return false;
    if (__isset.body_advance_ball != rhs.__isset.body_advance_ball)
      return false;
    else if (__isset.body_advance_ball && !(body_advance_ball == rhs.body_advance_ball))
      return false;
    if (__isset.body_clear_ball != rhs.__isset.body_clear_ball)
      return false;
    else if (__isset.body_clear_ball && !(body_clear_ball == rhs.body_clear_ball))
      return false;
    if (__isset.body_dribble != rhs.__isset.body_dribble)
      return false;
    else if (__isset.body_dribble && !(body_dribble == rhs.body_dribble))
      return false;
    if (__isset.body_go_to_point_dodge != rhs.__isset.body_go_to_point_dodge)
      return false;
    else if (__isset.body_go_to_point_dodge && !(body_go_to_point_dodge == rhs.body_go_to_point_dodge))
      return false;
    if (__isset.body_hold_ball != rhs.__isset.body_hold_ball)
      return false;
    else if (__isset.body_hold_ball && !(body_hold_ball == rhs.body_hold_ball))
      return false;
    if (__isset.body_intercept != rhs.__isset.body_intercept)
      return false;
    else if (__isset.body_intercept && !(body_intercept == rhs.body_intercept))
      return false;
    if (__isset.body_kick_one_step != rhs.__isset.body_kick_one_step)
      return false;
    else if (__isset.body_kick_one_step && !(body_kick_one_step == rhs.body_kick_one_step))
      return false;
    if (__isset.body_stop_ball != rhs.__isset.body_stop_ball)
      return false;
    else if (__isset.body_stop_ball && !(body_stop_ball == rhs.body_stop_ball))
      return false;
    if (__isset.body_stop_dash != rhs.__isset.body_stop_dash)
      return false;
    else if (__isset.body_stop_dash && !(body_stop_dash == rhs.body_stop_dash))
      return false;
    if (__isset.body_tackle_to_point != rhs.__isset.body_tackle_to_point)
      return false;
    else if (__isset.body_tackle_to_point && !(body_tackle_to_point == rhs.body_tackle_to_point))
      return false;
    if (__isset.body_turn_to_angle != rhs.__isset.body_turn_to_angle)
      return false;
    else if (__isset.body_turn_to_angle && !(body_turn_to_angle == rhs.body_turn_to_angle))
      return false;
    if (__isset.body_turn_to_ball != rhs.__isset.body_turn_to_ball)
      return false;
    else if (__isset.body_turn_to_ball && !(body_turn_to_ball == rhs.body_turn_to_ball))
      return false;
    if (__isset.body_turn_to_point != rhs.__isset.body_turn_to_point)
      return false;
    else if (__isset.body_turn_to_point && !(body_turn_to_point == rhs.body_turn_to_point))
      return false;
    if (__isset.focus_move_to_point != rhs.__isset.focus_move_to_point)
      return false;
    else if (__isset.focus_move_to_point && !(focus_move_to_point == rhs.focus_move_to_point))
      return false;
    if (__isset.focus_reset != rhs.__isset.focus_reset)
      return false;
    else if (__isset.focus_reset && !(focus_reset == rhs.focus_reset))
      return false;
    if (__isset.neck_scan_field != rhs.__isset.neck_scan_field)
      return false;
    else if (__isset.neck_scan_field && !(neck_scan_field == rhs.neck_scan_field))
      return false;
    if (__isset.neck_scan_players != rhs.__isset.neck_scan_players)
      return false;
    else if (__isset.neck_scan_players && !(neck_scan_players == rhs.neck_scan_players))
      return false;
    if (__isset.neck_turn_to_ball_and_player != rhs.__isset.neck_turn_to_ball_and_player)
      return false;
    else if (__isset.neck_turn_to_ball_and_player && !(neck_turn_to_ball_and_player == rhs.neck_turn_to_ball_and_player))
      return false;
    if (__isset.neck_turn_to_ball_or_scan != rhs.__isset.neck_turn_to_ball_or_scan)
      return false;
    else if (__isset.neck_turn_to_ball_or_scan && !(neck_turn_to_ball_or_scan == rhs.neck_turn_to_ball_or_scan))
      return false;
    if (__isset.neck_turn_to_ball != rhs.__isset.neck_turn_to_ball)
      return false;
    else if (__isset.neck_turn_to_ball && !(neck_turn_to_ball == rhs.neck_turn_to_ball))
      return false;
    if (__isset.neck_turn_to_goalie_or_scan != rhs.__isset.neck_turn_to_goalie_or_scan)
      return false;
    else if (__isset.neck_turn_to_goalie_or_scan && !(neck_turn_to_goalie_or_scan == rhs.neck_turn_to_goalie_or_scan))
      return false;
    if (__isset.neck_turn_to_low_conf_teammate != rhs.__isset.neck_turn_to_low_conf_teammate)
      return false;
    else if (__isset.neck_turn_to_low_conf_teammate && !(neck_turn_to_low_conf_teammate == rhs.neck_turn_to_low_conf_teammate))
      return false;
    if (__isset.neck_turn_to_player_or_scan != rhs.__isset.neck_turn_to_player_or_scan)
      return false;
    else if (__isset.neck_turn_to_player_or_scan && !(neck_turn_to_player_or_scan == rhs.neck_turn_to_player_or_scan))
      return false;
    if (__isset.neck_turn_to_point != rhs.__isset.neck_turn_to_point)
      return false;
    else if (__isset.neck_turn_to_point && !(neck_turn_to_point == rhs.neck_turn_to_point))
      return false;
    if (__isset.neck_turn_to_relative != rhs.__isset.neck_turn_to_relative)
      return false;
    else if (__isset.neck_turn_to_relative && !(neck_turn_to_relative == rhs.neck_turn_to_relative))
      return false;
    if (__isset.view_change_width != rhs.__isset.view_change_width)
      return false;
    else if (__isset.view_change_width && !(view_change_width == rhs.view_change_width))
      return false;
    if (__isset.view_normal != rhs.__isset.view_normal)
      return false;
    else if (__isset.view_normal && !(view_normal == rhs.view_normal))
      return false;
    if (__isset.view_synch != rhs.__isset.view_synch)
      return false;
    else if (__isset.view_synch && !(view_synch == rhs.view_synch))
      return false;
    if (__isset.view_wide != rhs.__isset.view_wide)
      return false;
    else if (__isset.view_wide && !(view_wide == rhs.view_wide))
      return false;
    if (__isset.helios_goalie != rhs.__isset.helios_goalie)
      return false;
    else if (__isset.helios_goalie && !(helios_goalie == rhs.helios_goalie))
      return false;
    if (__isset.helios_goalie_move != rhs.__isset.helios_goalie_move)
      return false;
    else if (__isset.helios_goalie_move && !(helios_goalie_move == rhs.helios_goalie_move))
      return false;
    if (__isset.helios_goalie_kick != rhs.__isset.helios_goalie_kick)
      return false;
    else if (__isset.helios_goalie_kick && !(helios_goalie_kick == rhs.helios_goalie_kick))
      return false;
    if (__isset.helios_shoot != rhs.__isset.helios_shoot)
      return false;
    else if (__isset.helios_shoot && !(helios_shoot == rhs.helios_shoot))
      return false;
    if (__isset.helios_chain_action != rhs.__isset.helios_chain_action)
      return false;
    else if (__isset.helios_chain_action && !(helios_chain_action == rhs.helios_chain_action))
      return false;
    if (__isset.helios_basic_offensive != rhs.__isset.helios_basic_offensive)
      return false;
    else if (__isset.helios_basic_offensive && !(helios_basic_offensive == rhs.helios_basic_offensive))
      return false;
    if (__isset.helios_basic_move != rhs.__isset.helios_basic_move)
      return false;
    else if (__isset.helios_basic_move && !(helios_basic_move == rhs.helios_basic_move))
      return false;
    if (__isset.helios_set_play != rhs.__isset.helios_set_play)
      return false;
    else if (__isset.helios_set_play && !(helios_set_play == rhs.helios_set_play))
      return false;
    if (__isset.helios_penalty != rhs.__isset.helios_penalty)
      return false;
    else if (__isset.helios_penalty && !(helios_penalty == rhs.helios_penalty))
      return false;
    if (__isset.helios_communication != rhs.__isset.helios_communication)
      return false;
    else if (__isset.helios_communication && !(helios_communication == rhs.helios_communication))
      return false;
    return true;
  }
  bool operator != (const PlayerAction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerAction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PlayerAction &a, PlayerAction &b);

std::ostream& operator<<(std::ostream& out, const PlayerAction& obj);

typedef struct _PlayerActions__isset {
  _PlayerActions__isset() : actions(false) {}
  bool actions :1;
} _PlayerActions__isset;

class PlayerActions : public virtual ::apache::thrift::TBase {
 public:

  PlayerActions(const PlayerActions&);
  PlayerActions& operator=(const PlayerActions&);
  PlayerActions() noexcept {
  }

  virtual ~PlayerActions() noexcept;
  std::vector<PlayerAction>  actions;

  _PlayerActions__isset __isset;

  void __set_actions(const std::vector<PlayerAction> & val);

  bool operator == (const PlayerActions & rhs) const
  {
    if (!(actions == rhs.actions))
      return false;
    return true;
  }
  bool operator != (const PlayerActions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerActions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PlayerActions &a, PlayerActions &b);

std::ostream& operator<<(std::ostream& out, const PlayerActions& obj);

typedef struct _ChangePlayerType__isset {
  _ChangePlayerType__isset() : uniform_number(false), type(false) {}
  bool uniform_number :1;
  bool type :1;
} _ChangePlayerType__isset;

class ChangePlayerType : public virtual ::apache::thrift::TBase {
 public:

  ChangePlayerType(const ChangePlayerType&) noexcept;
  ChangePlayerType& operator=(const ChangePlayerType&) noexcept;
  ChangePlayerType() noexcept
                   : uniform_number(0),
                     type(0) {
  }

  virtual ~ChangePlayerType() noexcept;
  int32_t uniform_number;
  int32_t type;

  _ChangePlayerType__isset __isset;

  void __set_uniform_number(const int32_t val);

  void __set_type(const int32_t val);

  bool operator == (const ChangePlayerType & rhs) const
  {
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const ChangePlayerType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChangePlayerType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ChangePlayerType &a, ChangePlayerType &b);

std::ostream& operator<<(std::ostream& out, const ChangePlayerType& obj);


class DoHeliosSubstitute : public virtual ::apache::thrift::TBase {
 public:

  DoHeliosSubstitute(const DoHeliosSubstitute&) noexcept;
  DoHeliosSubstitute& operator=(const DoHeliosSubstitute&) noexcept;
  DoHeliosSubstitute() noexcept {
  }

  virtual ~DoHeliosSubstitute() noexcept;

  bool operator == (const DoHeliosSubstitute & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DoHeliosSubstitute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoHeliosSubstitute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoHeliosSubstitute &a, DoHeliosSubstitute &b);

std::ostream& operator<<(std::ostream& out, const DoHeliosSubstitute& obj);


class DoHeliosSayPlayerTypes : public virtual ::apache::thrift::TBase {
 public:

  DoHeliosSayPlayerTypes(const DoHeliosSayPlayerTypes&) noexcept;
  DoHeliosSayPlayerTypes& operator=(const DoHeliosSayPlayerTypes&) noexcept;
  DoHeliosSayPlayerTypes() noexcept {
  }

  virtual ~DoHeliosSayPlayerTypes() noexcept;

  bool operator == (const DoHeliosSayPlayerTypes & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DoHeliosSayPlayerTypes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoHeliosSayPlayerTypes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoHeliosSayPlayerTypes &a, DoHeliosSayPlayerTypes &b);

std::ostream& operator<<(std::ostream& out, const DoHeliosSayPlayerTypes& obj);

typedef struct _CoachAction__isset {
  _CoachAction__isset() : change_player_types(false), do_helios_substitute(false), do_helios_say_player_types(false) {}
  bool change_player_types :1;
  bool do_helios_substitute :1;
  bool do_helios_say_player_types :1;
} _CoachAction__isset;

class CoachAction : public virtual ::apache::thrift::TBase {
 public:

  CoachAction(const CoachAction&) noexcept;
  CoachAction& operator=(const CoachAction&) noexcept;
  CoachAction() noexcept {
  }

  virtual ~CoachAction() noexcept;
  ChangePlayerType change_player_types;
  DoHeliosSubstitute do_helios_substitute;
  DoHeliosSayPlayerTypes do_helios_say_player_types;

  _CoachAction__isset __isset;

  void __set_change_player_types(const ChangePlayerType& val);

  void __set_do_helios_substitute(const DoHeliosSubstitute& val);

  void __set_do_helios_say_player_types(const DoHeliosSayPlayerTypes& val);

  bool operator == (const CoachAction & rhs) const
  {
    if (__isset.change_player_types != rhs.__isset.change_player_types)
      return false;
    else if (__isset.change_player_types && !(change_player_types == rhs.change_player_types))
      return false;
    if (__isset.do_helios_substitute != rhs.__isset.do_helios_substitute)
      return false;
    else if (__isset.do_helios_substitute && !(do_helios_substitute == rhs.do_helios_substitute))
      return false;
    if (__isset.do_helios_say_player_types != rhs.__isset.do_helios_say_player_types)
      return false;
    else if (__isset.do_helios_say_player_types && !(do_helios_say_player_types == rhs.do_helios_say_player_types))
      return false;
    return true;
  }
  bool operator != (const CoachAction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoachAction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CoachAction &a, CoachAction &b);

std::ostream& operator<<(std::ostream& out, const CoachAction& obj);

typedef struct _CoachActions__isset {
  _CoachActions__isset() : actions(false) {}
  bool actions :1;
} _CoachActions__isset;

class CoachActions : public virtual ::apache::thrift::TBase {
 public:

  CoachActions(const CoachActions&);
  CoachActions& operator=(const CoachActions&);
  CoachActions() noexcept {
  }

  virtual ~CoachActions() noexcept;
  std::vector<CoachAction>  actions;

  _CoachActions__isset __isset;

  void __set_actions(const std::vector<CoachAction> & val);

  bool operator == (const CoachActions & rhs) const
  {
    if (!(actions == rhs.actions))
      return false;
    return true;
  }
  bool operator != (const CoachActions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoachActions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CoachActions &a, CoachActions &b);

std::ostream& operator<<(std::ostream& out, const CoachActions& obj);


class DoKickOff : public virtual ::apache::thrift::TBase {
 public:

  DoKickOff(const DoKickOff&) noexcept;
  DoKickOff& operator=(const DoKickOff&) noexcept;
  DoKickOff() noexcept {
  }

  virtual ~DoKickOff() noexcept;

  bool operator == (const DoKickOff & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DoKickOff &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoKickOff & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoKickOff &a, DoKickOff &b);

std::ostream& operator<<(std::ostream& out, const DoKickOff& obj);

typedef struct _DoMoveBall__isset {
  _DoMoveBall__isset() : position(false), velocity(false) {}
  bool position :1;
  bool velocity :1;
} _DoMoveBall__isset;

class DoMoveBall : public virtual ::apache::thrift::TBase {
 public:

  DoMoveBall(const DoMoveBall&) noexcept;
  DoMoveBall& operator=(const DoMoveBall&) noexcept;
  DoMoveBall() noexcept {
  }

  virtual ~DoMoveBall() noexcept;
  RpcVector2D position;
  RpcVector2D velocity;

  _DoMoveBall__isset __isset;

  void __set_position(const RpcVector2D& val);

  void __set_velocity(const RpcVector2D& val);

  bool operator == (const DoMoveBall & rhs) const
  {
    if (!(position == rhs.position))
      return false;
    if (__isset.velocity != rhs.__isset.velocity)
      return false;
    else if (__isset.velocity && !(velocity == rhs.velocity))
      return false;
    return true;
  }
  bool operator != (const DoMoveBall &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoMoveBall & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoMoveBall &a, DoMoveBall &b);

std::ostream& operator<<(std::ostream& out, const DoMoveBall& obj);

typedef struct _DoMovePlayer__isset {
  _DoMovePlayer__isset() : our_side(false), uniform_number(false), position(false), body_direction(false) {}
  bool our_side :1;
  bool uniform_number :1;
  bool position :1;
  bool body_direction :1;
} _DoMovePlayer__isset;

class DoMovePlayer : public virtual ::apache::thrift::TBase {
 public:

  DoMovePlayer(const DoMovePlayer&) noexcept;
  DoMovePlayer& operator=(const DoMovePlayer&) noexcept;
  DoMovePlayer() noexcept
               : our_side(0),
                 uniform_number(0),
                 body_direction(0) {
  }

  virtual ~DoMovePlayer() noexcept;
  bool our_side;
  int32_t uniform_number;
  RpcVector2D position;
  double body_direction;

  _DoMovePlayer__isset __isset;

  void __set_our_side(const bool val);

  void __set_uniform_number(const int32_t val);

  void __set_position(const RpcVector2D& val);

  void __set_body_direction(const double val);

  bool operator == (const DoMovePlayer & rhs) const
  {
    if (!(our_side == rhs.our_side))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(position == rhs.position))
      return false;
    if (!(body_direction == rhs.body_direction))
      return false;
    return true;
  }
  bool operator != (const DoMovePlayer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoMovePlayer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoMovePlayer &a, DoMovePlayer &b);

std::ostream& operator<<(std::ostream& out, const DoMovePlayer& obj);


class DoRecover : public virtual ::apache::thrift::TBase {
 public:

  DoRecover(const DoRecover&) noexcept;
  DoRecover& operator=(const DoRecover&) noexcept;
  DoRecover() noexcept {
  }

  virtual ~DoRecover() noexcept;

  bool operator == (const DoRecover & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DoRecover &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoRecover & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoRecover &a, DoRecover &b);

std::ostream& operator<<(std::ostream& out, const DoRecover& obj);

typedef struct _DoChangeMode__isset {
  _DoChangeMode__isset() : game_mode_type(false), side(false) {}
  bool game_mode_type :1;
  bool side :1;
} _DoChangeMode__isset;

class DoChangeMode : public virtual ::apache::thrift::TBase {
 public:

  DoChangeMode(const DoChangeMode&) noexcept;
  DoChangeMode& operator=(const DoChangeMode&) noexcept;
  DoChangeMode() noexcept
               : game_mode_type(static_cast<GameModeType::type>(0)),
                 side(static_cast<Side::type>(0)) {
  }

  virtual ~DoChangeMode() noexcept;
  /**
   * 
   * @see GameModeType
   */
  GameModeType::type game_mode_type;
  /**
   * 
   * @see Side
   */
  Side::type side;

  _DoChangeMode__isset __isset;

  void __set_game_mode_type(const GameModeType::type val);

  void __set_side(const Side::type val);

  bool operator == (const DoChangeMode & rhs) const
  {
    if (!(game_mode_type == rhs.game_mode_type))
      return false;
    if (!(side == rhs.side))
      return false;
    return true;
  }
  bool operator != (const DoChangeMode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoChangeMode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoChangeMode &a, DoChangeMode &b);

std::ostream& operator<<(std::ostream& out, const DoChangeMode& obj);

typedef struct _DoChangePlayerType__isset {
  _DoChangePlayerType__isset() : our_side(false), uniform_number(false), type(false) {}
  bool our_side :1;
  bool uniform_number :1;
  bool type :1;
} _DoChangePlayerType__isset;

class DoChangePlayerType : public virtual ::apache::thrift::TBase {
 public:

  DoChangePlayerType(const DoChangePlayerType&) noexcept;
  DoChangePlayerType& operator=(const DoChangePlayerType&) noexcept;
  DoChangePlayerType() noexcept
                     : our_side(0),
                       uniform_number(0),
                       type(0) {
  }

  virtual ~DoChangePlayerType() noexcept;
  bool our_side;
  int32_t uniform_number;
  int32_t type;

  _DoChangePlayerType__isset __isset;

  void __set_our_side(const bool val);

  void __set_uniform_number(const int32_t val);

  void __set_type(const int32_t val);

  bool operator == (const DoChangePlayerType & rhs) const
  {
    if (!(our_side == rhs.our_side))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const DoChangePlayerType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoChangePlayerType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoChangePlayerType &a, DoChangePlayerType &b);

std::ostream& operator<<(std::ostream& out, const DoChangePlayerType& obj);

typedef struct _TrainerAction__isset {
  _TrainerAction__isset() : do_kick_off(false), do_move_ball(false), do_move_player(false), do_recover(false), do_change_mode(false), do_change_player_type(false) {}
  bool do_kick_off :1;
  bool do_move_ball :1;
  bool do_move_player :1;
  bool do_recover :1;
  bool do_change_mode :1;
  bool do_change_player_type :1;
} _TrainerAction__isset;

class TrainerAction : public virtual ::apache::thrift::TBase {
 public:

  TrainerAction(const TrainerAction&) noexcept;
  TrainerAction& operator=(const TrainerAction&) noexcept;
  TrainerAction() noexcept {
  }

  virtual ~TrainerAction() noexcept;
  DoKickOff do_kick_off;
  DoMoveBall do_move_ball;
  DoMovePlayer do_move_player;
  DoRecover do_recover;
  DoChangeMode do_change_mode;
  DoChangePlayerType do_change_player_type;

  _TrainerAction__isset __isset;

  void __set_do_kick_off(const DoKickOff& val);

  void __set_do_move_ball(const DoMoveBall& val);

  void __set_do_move_player(const DoMovePlayer& val);

  void __set_do_recover(const DoRecover& val);

  void __set_do_change_mode(const DoChangeMode& val);

  void __set_do_change_player_type(const DoChangePlayerType& val);

  bool operator == (const TrainerAction & rhs) const
  {
    if (__isset.do_kick_off != rhs.__isset.do_kick_off)
      return false;
    else if (__isset.do_kick_off && !(do_kick_off == rhs.do_kick_off))
      return false;
    if (__isset.do_move_ball != rhs.__isset.do_move_ball)
      return false;
    else if (__isset.do_move_ball && !(do_move_ball == rhs.do_move_ball))
      return false;
    if (__isset.do_move_player != rhs.__isset.do_move_player)
      return false;
    else if (__isset.do_move_player && !(do_move_player == rhs.do_move_player))
      return false;
    if (__isset.do_recover != rhs.__isset.do_recover)
      return false;
    else if (__isset.do_recover && !(do_recover == rhs.do_recover))
      return false;
    if (__isset.do_change_mode != rhs.__isset.do_change_mode)
      return false;
    else if (__isset.do_change_mode && !(do_change_mode == rhs.do_change_mode))
      return false;
    if (__isset.do_change_player_type != rhs.__isset.do_change_player_type)
      return false;
    else if (__isset.do_change_player_type && !(do_change_player_type == rhs.do_change_player_type))
      return false;
    return true;
  }
  bool operator != (const TrainerAction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrainerAction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TrainerAction &a, TrainerAction &b);

std::ostream& operator<<(std::ostream& out, const TrainerAction& obj);

typedef struct _TrainerActions__isset {
  _TrainerActions__isset() : actions(false) {}
  bool actions :1;
} _TrainerActions__isset;

class TrainerActions : public virtual ::apache::thrift::TBase {
 public:

  TrainerActions(const TrainerActions&);
  TrainerActions& operator=(const TrainerActions&);
  TrainerActions() noexcept {
  }

  virtual ~TrainerActions() noexcept;
  std::vector<TrainerAction>  actions;

  _TrainerActions__isset __isset;

  void __set_actions(const std::vector<TrainerAction> & val);

  bool operator == (const TrainerActions & rhs) const
  {
    if (!(actions == rhs.actions))
      return false;
    return true;
  }
  bool operator != (const TrainerActions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrainerActions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TrainerActions &a, TrainerActions &b);

std::ostream& operator<<(std::ostream& out, const TrainerActions& obj);

typedef struct _ServerParam__isset {
  _ServerParam__isset() : agent_type(false), inertia_moment(false), player_size(false), player_decay(false), player_rand(false), player_weight(false), player_speed_max(false), player_accel_max(false), stamina_max(false), stamina_inc_max(false), recover_init(false), recover_dec_thr(false), recover_min(false), recover_dec(false), effort_init(false), effort_dec_thr(false), effort_min(false), effort_dec(false), effort_inc_thr(false), effort_inc(false), kick_rand(false), team_actuator_noise(false), player_rand_factor_l(false), player_rand_factor_r(false), kick_rand_factor_l(false), kick_rand_factor_r(false), ball_size(false), ball_decay(false), ball_rand(false), ball_weight(false), ball_speed_max(false), ball_accel_max(false), dash_power_rate(false), kick_power_rate(false), kickable_margin(false), control_radius(false), control_radius_width(false), max_power(false), min_power(false), max_moment(false), min_moment(false), max_neck_moment(false), min_neck_moment(false), max_neck_angle(false), min_neck_angle(false), visible_angle(false), visible_distance(false), wind_dir(false), wind_force(false), wind_angle(false), wind_rand(false), kickable_area(false), catch_area_l(false), catch_area_w(false), catch_probability(false), goalie_max_moves(false), corner_kick_margin(false), offside_active_area_size(false), wind_none(false), use_wind_random(false), coach_say_count_max(false), coach_say_msg_size(false), clang_win_size(false), clang_define_win(false), clang_meta_win(false), clang_advice_win(false), clang_info_win(false), clang_mess_delay(false), clang_mess_per_cycle(false), half_time(false), simulator_step(false), send_step(false), recv_step(false), sense_body_step(false), lcm_step(false), player_say_msg_size(false), player_hear_max(false), player_hear_inc(false), player_hear_decay(false), catch_ban_cycle(false), slow_down_factor(false), use_offside(false), kickoff_offside(false), offside_kick_margin(false), audio_cut_dist(false), dist_quantize_step(false), landmark_dist_quantize_step(false), dir_quantize_step(false), dist_quantize_step_l(false), dist_quantize_step_r(false), landmark_dist_quantize_step_l(false), landmark_dist_quantize_step_r(false), dir_quantize_step_l(false), dir_quantize_step_r(false), coach_mode(false), coach_with_referee_mode(false), use_old_coach_hear(false), slowness_on_top_for_left_team(false), slowness_on_top_for_right_team(false), start_goal_l(false), start_goal_r(false), fullstate_l(false), fullstate_r(false), drop_ball_time(false), synch_mode(false), synch_offset(false), synch_micro_sleep(false), point_to_ban(false), point_to_duration(false), player_port(false), trainer_port(false), online_coach_port(false), verbose_mode(false), coach_send_vi_step(false), replay_file(false), landmark_file(false), send_comms(false), text_logging(false), game_logging(false), game_log_version(false), text_log_dir(false), game_log_dir(false), text_log_fixed_name(false), game_log_fixed_name(false), use_text_log_fixed(false), use_game_log_fixed(false), use_text_log_dated(false), use_game_log_dated(false), log_date_format(false), log_times(false), record_message(false), text_log_compression(false), game_log_compression(false), use_profile(false), tackle_dist(false), tackle_back_dist(false), tackle_width(false), tackle_exponent(false), tackle_cycles(false), tackle_power_rate(false), freeform_wait_period(false), freeform_send_period(false), free_kick_faults(false), back_passes(false), proper_goal_kicks(false), stopped_ball_vel(false), max_goal_kicks(false), clang_del_win(false), clang_rule_win(false), auto_mode(false), kick_off_wait(false), connect_wait(false), game_over_wait(false), team_l_start(false), team_r_start(false), keepaway_mode(false), keepaway_length(false), keepaway_width(false), keepaway_logging(false), keepaway_log_dir(false), keepaway_log_fixed_name(false), keepaway_log_fixed(false), keepaway_log_dated(false), keepaway_start(false), nr_normal_halfs(false), nr_extra_halfs(false), penalty_shoot_outs(false), pen_before_setup_wait(false), pen_setup_wait(false), pen_ready_wait(false), pen_taken_wait(false), pen_nr_kicks(false), pen_max_extra_kicks(false), pen_dist_x(false), pen_random_winner(false), pen_allow_mult_kicks(false), pen_max_goalie_dist_x(false), pen_coach_moves_players(false), module_dir(false), ball_stuck_area(false), coach_msg_file(false), max_tackle_power(false), max_back_tackle_power(false), player_speed_max_min(false), extra_stamina(false), synch_see_offset(false), extra_half_time(false), stamina_capacity(false), max_dash_angle(false), min_dash_angle(false), dash_angle_step(false), side_dash_rate(false), back_dash_rate(false), max_dash_power(false), min_dash_power(false), tackle_rand_factor(false), foul_detect_probability(false), foul_exponent(false), foul_cycles(false), golden_goal(false), red_card_probability(false), illegal_defense_duration(false), illegal_defense_number(false), illegal_defense_dist_x(false), illegal_defense_width(false), fixed_teamname_l(false), fixed_teamname_r(false), max_catch_angle(false), min_catch_angle(false), random_seed(false), long_kick_power_factor(false), long_kick_delay(false), max_monitors(false), catchable_area(false), real_speed_max(false), pitch_half_length(false), pitch_half_width(false), our_penalty_area_line_x(false), their_penalty_area_line_x(false), penalty_area_half_width(false), penalty_area_length(false), goal_width(false) {}
  bool agent_type :1;
  bool inertia_moment :1;
  bool player_size :1;
  bool player_decay :1;
  bool player_rand :1;
  bool player_weight :1;
  bool player_speed_max :1;
  bool player_accel_max :1;
  bool stamina_max :1;
  bool stamina_inc_max :1;
  bool recover_init :1;
  bool recover_dec_thr :1;
  bool recover_min :1;
  bool recover_dec :1;
  bool effort_init :1;
  bool effort_dec_thr :1;
  bool effort_min :1;
  bool effort_dec :1;
  bool effort_inc_thr :1;
  bool effort_inc :1;
  bool kick_rand :1;
  bool team_actuator_noise :1;
  bool player_rand_factor_l :1;
  bool player_rand_factor_r :1;
  bool kick_rand_factor_l :1;
  bool kick_rand_factor_r :1;
  bool ball_size :1;
  bool ball_decay :1;
  bool ball_rand :1;
  bool ball_weight :1;
  bool ball_speed_max :1;
  bool ball_accel_max :1;
  bool dash_power_rate :1;
  bool kick_power_rate :1;
  bool kickable_margin :1;
  bool control_radius :1;
  bool control_radius_width :1;
  bool max_power :1;
  bool min_power :1;
  bool max_moment :1;
  bool min_moment :1;
  bool max_neck_moment :1;
  bool min_neck_moment :1;
  bool max_neck_angle :1;
  bool min_neck_angle :1;
  bool visible_angle :1;
  bool visible_distance :1;
  bool wind_dir :1;
  bool wind_force :1;
  bool wind_angle :1;
  bool wind_rand :1;
  bool kickable_area :1;
  bool catch_area_l :1;
  bool catch_area_w :1;
  bool catch_probability :1;
  bool goalie_max_moves :1;
  bool corner_kick_margin :1;
  bool offside_active_area_size :1;
  bool wind_none :1;
  bool use_wind_random :1;
  bool coach_say_count_max :1;
  bool coach_say_msg_size :1;
  bool clang_win_size :1;
  bool clang_define_win :1;
  bool clang_meta_win :1;
  bool clang_advice_win :1;
  bool clang_info_win :1;
  bool clang_mess_delay :1;
  bool clang_mess_per_cycle :1;
  bool half_time :1;
  bool simulator_step :1;
  bool send_step :1;
  bool recv_step :1;
  bool sense_body_step :1;
  bool lcm_step :1;
  bool player_say_msg_size :1;
  bool player_hear_max :1;
  bool player_hear_inc :1;
  bool player_hear_decay :1;
  bool catch_ban_cycle :1;
  bool slow_down_factor :1;
  bool use_offside :1;
  bool kickoff_offside :1;
  bool offside_kick_margin :1;
  bool audio_cut_dist :1;
  bool dist_quantize_step :1;
  bool landmark_dist_quantize_step :1;
  bool dir_quantize_step :1;
  bool dist_quantize_step_l :1;
  bool dist_quantize_step_r :1;
  bool landmark_dist_quantize_step_l :1;
  bool landmark_dist_quantize_step_r :1;
  bool dir_quantize_step_l :1;
  bool dir_quantize_step_r :1;
  bool coach_mode :1;
  bool coach_with_referee_mode :1;
  bool use_old_coach_hear :1;
  bool slowness_on_top_for_left_team :1;
  bool slowness_on_top_for_right_team :1;
  bool start_goal_l :1;
  bool start_goal_r :1;
  bool fullstate_l :1;
  bool fullstate_r :1;
  bool drop_ball_time :1;
  bool synch_mode :1;
  bool synch_offset :1;
  bool synch_micro_sleep :1;
  bool point_to_ban :1;
  bool point_to_duration :1;
  bool player_port :1;
  bool trainer_port :1;
  bool online_coach_port :1;
  bool verbose_mode :1;
  bool coach_send_vi_step :1;
  bool replay_file :1;
  bool landmark_file :1;
  bool send_comms :1;
  bool text_logging :1;
  bool game_logging :1;
  bool game_log_version :1;
  bool text_log_dir :1;
  bool game_log_dir :1;
  bool text_log_fixed_name :1;
  bool game_log_fixed_name :1;
  bool use_text_log_fixed :1;
  bool use_game_log_fixed :1;
  bool use_text_log_dated :1;
  bool use_game_log_dated :1;
  bool log_date_format :1;
  bool log_times :1;
  bool record_message :1;
  bool text_log_compression :1;
  bool game_log_compression :1;
  bool use_profile :1;
  bool tackle_dist :1;
  bool tackle_back_dist :1;
  bool tackle_width :1;
  bool tackle_exponent :1;
  bool tackle_cycles :1;
  bool tackle_power_rate :1;
  bool freeform_wait_period :1;
  bool freeform_send_period :1;
  bool free_kick_faults :1;
  bool back_passes :1;
  bool proper_goal_kicks :1;
  bool stopped_ball_vel :1;
  bool max_goal_kicks :1;
  bool clang_del_win :1;
  bool clang_rule_win :1;
  bool auto_mode :1;
  bool kick_off_wait :1;
  bool connect_wait :1;
  bool game_over_wait :1;
  bool team_l_start :1;
  bool team_r_start :1;
  bool keepaway_mode :1;
  bool keepaway_length :1;
  bool keepaway_width :1;
  bool keepaway_logging :1;
  bool keepaway_log_dir :1;
  bool keepaway_log_fixed_name :1;
  bool keepaway_log_fixed :1;
  bool keepaway_log_dated :1;
  bool keepaway_start :1;
  bool nr_normal_halfs :1;
  bool nr_extra_halfs :1;
  bool penalty_shoot_outs :1;
  bool pen_before_setup_wait :1;
  bool pen_setup_wait :1;
  bool pen_ready_wait :1;
  bool pen_taken_wait :1;
  bool pen_nr_kicks :1;
  bool pen_max_extra_kicks :1;
  bool pen_dist_x :1;
  bool pen_random_winner :1;
  bool pen_allow_mult_kicks :1;
  bool pen_max_goalie_dist_x :1;
  bool pen_coach_moves_players :1;
  bool module_dir :1;
  bool ball_stuck_area :1;
  bool coach_msg_file :1;
  bool max_tackle_power :1;
  bool max_back_tackle_power :1;
  bool player_speed_max_min :1;
  bool extra_stamina :1;
  bool synch_see_offset :1;
  bool extra_half_time :1;
  bool stamina_capacity :1;
  bool max_dash_angle :1;
  bool min_dash_angle :1;
  bool dash_angle_step :1;
  bool side_dash_rate :1;
  bool back_dash_rate :1;
  bool max_dash_power :1;
  bool min_dash_power :1;
  bool tackle_rand_factor :1;
  bool foul_detect_probability :1;
  bool foul_exponent :1;
  bool foul_cycles :1;
  bool golden_goal :1;
  bool red_card_probability :1;
  bool illegal_defense_duration :1;
  bool illegal_defense_number :1;
  bool illegal_defense_dist_x :1;
  bool illegal_defense_width :1;
  bool fixed_teamname_l :1;
  bool fixed_teamname_r :1;
  bool max_catch_angle :1;
  bool min_catch_angle :1;
  bool random_seed :1;
  bool long_kick_power_factor :1;
  bool long_kick_delay :1;
  bool max_monitors :1;
  bool catchable_area :1;
  bool real_speed_max :1;
  bool pitch_half_length :1;
  bool pitch_half_width :1;
  bool our_penalty_area_line_x :1;
  bool their_penalty_area_line_x :1;
  bool penalty_area_half_width :1;
  bool penalty_area_length :1;
  bool goal_width :1;
} _ServerParam__isset;

class ServerParam : public virtual ::apache::thrift::TBase {
 public:

  ServerParam(const ServerParam&);
  ServerParam& operator=(const ServerParam&);
  ServerParam() noexcept
              : agent_type(static_cast<AgentType::type>(0)),
                inertia_moment(0),
                player_size(0),
                player_decay(0),
                player_rand(0),
                player_weight(0),
                player_speed_max(0),
                player_accel_max(0),
                stamina_max(0),
                stamina_inc_max(0),
                recover_init(0),
                recover_dec_thr(0),
                recover_min(0),
                recover_dec(0),
                effort_init(0),
                effort_dec_thr(0),
                effort_min(0),
                effort_dec(0),
                effort_inc_thr(0),
                effort_inc(0),
                kick_rand(0),
                team_actuator_noise(0),
                player_rand_factor_l(0),
                player_rand_factor_r(0),
                kick_rand_factor_l(0),
                kick_rand_factor_r(0),
                ball_size(0),
                ball_decay(0),
                ball_rand(0),
                ball_weight(0),
                ball_speed_max(0),
                ball_accel_max(0),
                dash_power_rate(0),
                kick_power_rate(0),
                kickable_margin(0),
                control_radius(0),
                control_radius_width(0),
                max_power(0),
                min_power(0),
                max_moment(0),
                min_moment(0),
                max_neck_moment(0),
                min_neck_moment(0),
                max_neck_angle(0),
                min_neck_angle(0),
                visible_angle(0),
                visible_distance(0),
                wind_dir(0),
                wind_force(0),
                wind_angle(0),
                wind_rand(0),
                kickable_area(0),
                catch_area_l(0),
                catch_area_w(0),
                catch_probability(0),
                goalie_max_moves(0),
                corner_kick_margin(0),
                offside_active_area_size(0),
                wind_none(0),
                use_wind_random(0),
                coach_say_count_max(0),
                coach_say_msg_size(0),
                clang_win_size(0),
                clang_define_win(0),
                clang_meta_win(0),
                clang_advice_win(0),
                clang_info_win(0),
                clang_mess_delay(0),
                clang_mess_per_cycle(0),
                half_time(0),
                simulator_step(0),
                send_step(0),
                recv_step(0),
                sense_body_step(0),
                lcm_step(0),
                player_say_msg_size(0),
                player_hear_max(0),
                player_hear_inc(0),
                player_hear_decay(0),
                catch_ban_cycle(0),
                slow_down_factor(0),
                use_offside(0),
                kickoff_offside(0),
                offside_kick_margin(0),
                audio_cut_dist(0),
                dist_quantize_step(0),
                landmark_dist_quantize_step(0),
                dir_quantize_step(0),
                dist_quantize_step_l(0),
                dist_quantize_step_r(0),
                landmark_dist_quantize_step_l(0),
                landmark_dist_quantize_step_r(0),
                dir_quantize_step_l(0),
                dir_quantize_step_r(0),
                coach_mode(0),
                coach_with_referee_mode(0),
                use_old_coach_hear(0),
                slowness_on_top_for_left_team(0),
                slowness_on_top_for_right_team(0),
                start_goal_l(0),
                start_goal_r(0),
                fullstate_l(0),
                fullstate_r(0),
                drop_ball_time(0),
                synch_mode(0),
                synch_offset(0),
                synch_micro_sleep(0),
                point_to_ban(0),
                point_to_duration(0),
                player_port(0),
                trainer_port(0),
                online_coach_port(0),
                verbose_mode(0),
                coach_send_vi_step(0),
                replay_file(),
                landmark_file(),
                send_comms(0),
                text_logging(0),
                game_logging(0),
                game_log_version(0),
                text_log_dir(),
                game_log_dir(),
                text_log_fixed_name(),
                game_log_fixed_name(),
                use_text_log_fixed(0),
                use_game_log_fixed(0),
                use_text_log_dated(0),
                use_game_log_dated(0),
                log_date_format(),
                log_times(0),
                record_message(0),
                text_log_compression(0),
                game_log_compression(0),
                use_profile(0),
                tackle_dist(0),
                tackle_back_dist(0),
                tackle_width(0),
                tackle_exponent(0),
                tackle_cycles(0),
                tackle_power_rate(0),
                freeform_wait_period(0),
                freeform_send_period(0),
                free_kick_faults(0),
                back_passes(0),
                proper_goal_kicks(0),
                stopped_ball_vel(0),
                max_goal_kicks(0),
                clang_del_win(0),
                clang_rule_win(0),
                auto_mode(0),
                kick_off_wait(0),
                connect_wait(0),
                game_over_wait(0),
                team_l_start(),
                team_r_start(),
                keepaway_mode(0),
                keepaway_length(0),
                keepaway_width(0),
                keepaway_logging(0),
                keepaway_log_dir(),
                keepaway_log_fixed_name(),
                keepaway_log_fixed(0),
                keepaway_log_dated(0),
                keepaway_start(0),
                nr_normal_halfs(0),
                nr_extra_halfs(0),
                penalty_shoot_outs(0),
                pen_before_setup_wait(0),
                pen_setup_wait(0),
                pen_ready_wait(0),
                pen_taken_wait(0),
                pen_nr_kicks(0),
                pen_max_extra_kicks(0),
                pen_dist_x(0),
                pen_random_winner(0),
                pen_allow_mult_kicks(0),
                pen_max_goalie_dist_x(0),
                pen_coach_moves_players(0),
                module_dir(),
                ball_stuck_area(0),
                coach_msg_file(),
                max_tackle_power(0),
                max_back_tackle_power(0),
                player_speed_max_min(0),
                extra_stamina(0),
                synch_see_offset(0),
                extra_half_time(0),
                stamina_capacity(0),
                max_dash_angle(0),
                min_dash_angle(0),
                dash_angle_step(0),
                side_dash_rate(0),
                back_dash_rate(0),
                max_dash_power(0),
                min_dash_power(0),
                tackle_rand_factor(0),
                foul_detect_probability(0),
                foul_exponent(0),
                foul_cycles(0),
                golden_goal(0),
                red_card_probability(0),
                illegal_defense_duration(0),
                illegal_defense_number(0),
                illegal_defense_dist_x(0),
                illegal_defense_width(0),
                fixed_teamname_l(),
                fixed_teamname_r(),
                max_catch_angle(0),
                min_catch_angle(0),
                random_seed(0),
                long_kick_power_factor(0),
                long_kick_delay(0),
                max_monitors(0),
                catchable_area(0),
                real_speed_max(0),
                pitch_half_length(0),
                pitch_half_width(0),
                our_penalty_area_line_x(0),
                their_penalty_area_line_x(0),
                penalty_area_half_width(0),
                penalty_area_length(0),
                goal_width(0) {
  }

  virtual ~ServerParam() noexcept;
  /**
   * 
   * @see AgentType
   */
  AgentType::type agent_type;
  double inertia_moment;
  double player_size;
  double player_decay;
  double player_rand;
  double player_weight;
  double player_speed_max;
  double player_accel_max;
  double stamina_max;
  double stamina_inc_max;
  double recover_init;
  double recover_dec_thr;
  double recover_min;
  double recover_dec;
  double effort_init;
  double effort_dec_thr;
  double effort_min;
  double effort_dec;
  double effort_inc_thr;
  double effort_inc;
  double kick_rand;
  bool team_actuator_noise;
  double player_rand_factor_l;
  double player_rand_factor_r;
  double kick_rand_factor_l;
  double kick_rand_factor_r;
  double ball_size;
  double ball_decay;
  double ball_rand;
  double ball_weight;
  double ball_speed_max;
  double ball_accel_max;
  double dash_power_rate;
  double kick_power_rate;
  double kickable_margin;
  double control_radius;
  double control_radius_width;
  double max_power;
  double min_power;
  double max_moment;
  double min_moment;
  double max_neck_moment;
  double min_neck_moment;
  double max_neck_angle;
  double min_neck_angle;
  double visible_angle;
  double visible_distance;
  double wind_dir;
  double wind_force;
  double wind_angle;
  double wind_rand;
  double kickable_area;
  double catch_area_l;
  double catch_area_w;
  double catch_probability;
  int32_t goalie_max_moves;
  double corner_kick_margin;
  double offside_active_area_size;
  bool wind_none;
  bool use_wind_random;
  int32_t coach_say_count_max;
  int32_t coach_say_msg_size;
  int32_t clang_win_size;
  int32_t clang_define_win;
  int32_t clang_meta_win;
  int32_t clang_advice_win;
  int32_t clang_info_win;
  int32_t clang_mess_delay;
  int32_t clang_mess_per_cycle;
  int32_t half_time;
  int32_t simulator_step;
  int32_t send_step;
  int32_t recv_step;
  int32_t sense_body_step;
  int32_t lcm_step;
  int32_t player_say_msg_size;
  int32_t player_hear_max;
  int32_t player_hear_inc;
  int32_t player_hear_decay;
  int32_t catch_ban_cycle;
  int32_t slow_down_factor;
  bool use_offside;
  bool kickoff_offside;
  double offside_kick_margin;
  double audio_cut_dist;
  double dist_quantize_step;
  double landmark_dist_quantize_step;
  double dir_quantize_step;
  double dist_quantize_step_l;
  double dist_quantize_step_r;
  double landmark_dist_quantize_step_l;
  double landmark_dist_quantize_step_r;
  double dir_quantize_step_l;
  double dir_quantize_step_r;
  bool coach_mode;
  bool coach_with_referee_mode;
  bool use_old_coach_hear;
  double slowness_on_top_for_left_team;
  double slowness_on_top_for_right_team;
  int32_t start_goal_l;
  int32_t start_goal_r;
  bool fullstate_l;
  bool fullstate_r;
  int32_t drop_ball_time;
  bool synch_mode;
  int32_t synch_offset;
  int32_t synch_micro_sleep;
  int32_t point_to_ban;
  int32_t point_to_duration;
  int32_t player_port;
  int32_t trainer_port;
  int32_t online_coach_port;
  bool verbose_mode;
  int32_t coach_send_vi_step;
  std::string replay_file;
  std::string landmark_file;
  bool send_comms;
  bool text_logging;
  bool game_logging;
  int32_t game_log_version;
  std::string text_log_dir;
  std::string game_log_dir;
  std::string text_log_fixed_name;
  std::string game_log_fixed_name;
  bool use_text_log_fixed;
  bool use_game_log_fixed;
  bool use_text_log_dated;
  bool use_game_log_dated;
  std::string log_date_format;
  bool log_times;
  bool record_message;
  int32_t text_log_compression;
  int32_t game_log_compression;
  bool use_profile;
  double tackle_dist;
  double tackle_back_dist;
  double tackle_width;
  double tackle_exponent;
  int32_t tackle_cycles;
  double tackle_power_rate;
  int32_t freeform_wait_period;
  int32_t freeform_send_period;
  bool free_kick_faults;
  bool back_passes;
  bool proper_goal_kicks;
  double stopped_ball_vel;
  int32_t max_goal_kicks;
  int32_t clang_del_win;
  int32_t clang_rule_win;
  bool auto_mode;
  int32_t kick_off_wait;
  int32_t connect_wait;
  int32_t game_over_wait;
  std::string team_l_start;
  std::string team_r_start;
  bool keepaway_mode;
  double keepaway_length;
  double keepaway_width;
  bool keepaway_logging;
  std::string keepaway_log_dir;
  std::string keepaway_log_fixed_name;
  bool keepaway_log_fixed;
  bool keepaway_log_dated;
  int32_t keepaway_start;
  int32_t nr_normal_halfs;
  int32_t nr_extra_halfs;
  bool penalty_shoot_outs;
  int32_t pen_before_setup_wait;
  int32_t pen_setup_wait;
  int32_t pen_ready_wait;
  int32_t pen_taken_wait;
  int32_t pen_nr_kicks;
  int32_t pen_max_extra_kicks;
  double pen_dist_x;
  bool pen_random_winner;
  bool pen_allow_mult_kicks;
  double pen_max_goalie_dist_x;
  bool pen_coach_moves_players;
  std::string module_dir;
  double ball_stuck_area;
  std::string coach_msg_file;
  double max_tackle_power;
  double max_back_tackle_power;
  double player_speed_max_min;
  double extra_stamina;
  int32_t synch_see_offset;
  int32_t extra_half_time;
  double stamina_capacity;
  double max_dash_angle;
  double min_dash_angle;
  double dash_angle_step;
  double side_dash_rate;
  double back_dash_rate;
  double max_dash_power;
  double min_dash_power;
  double tackle_rand_factor;
  double foul_detect_probability;
  double foul_exponent;
  int32_t foul_cycles;
  bool golden_goal;
  double red_card_probability;
  int32_t illegal_defense_duration;
  int32_t illegal_defense_number;
  double illegal_defense_dist_x;
  double illegal_defense_width;
  std::string fixed_teamname_l;
  std::string fixed_teamname_r;
  double max_catch_angle;
  double min_catch_angle;
  int32_t random_seed;
  double long_kick_power_factor;
  int32_t long_kick_delay;
  int32_t max_monitors;
  double catchable_area;
  double real_speed_max;
  double pitch_half_length;
  double pitch_half_width;
  double our_penalty_area_line_x;
  double their_penalty_area_line_x;
  double penalty_area_half_width;
  double penalty_area_length;
  double goal_width;

  _ServerParam__isset __isset;

  void __set_agent_type(const AgentType::type val);

  void __set_inertia_moment(const double val);

  void __set_player_size(const double val);

  void __set_player_decay(const double val);

  void __set_player_rand(const double val);

  void __set_player_weight(const double val);

  void __set_player_speed_max(const double val);

  void __set_player_accel_max(const double val);

  void __set_stamina_max(const double val);

  void __set_stamina_inc_max(const double val);

  void __set_recover_init(const double val);

  void __set_recover_dec_thr(const double val);

  void __set_recover_min(const double val);

  void __set_recover_dec(const double val);

  void __set_effort_init(const double val);

  void __set_effort_dec_thr(const double val);

  void __set_effort_min(const double val);

  void __set_effort_dec(const double val);

  void __set_effort_inc_thr(const double val);

  void __set_effort_inc(const double val);

  void __set_kick_rand(const double val);

  void __set_team_actuator_noise(const bool val);

  void __set_player_rand_factor_l(const double val);

  void __set_player_rand_factor_r(const double val);

  void __set_kick_rand_factor_l(const double val);

  void __set_kick_rand_factor_r(const double val);

  void __set_ball_size(const double val);

  void __set_ball_decay(const double val);

  void __set_ball_rand(const double val);

  void __set_ball_weight(const double val);

  void __set_ball_speed_max(const double val);

  void __set_ball_accel_max(const double val);

  void __set_dash_power_rate(const double val);

  void __set_kick_power_rate(const double val);

  void __set_kickable_margin(const double val);

  void __set_control_radius(const double val);

  void __set_control_radius_width(const double val);

  void __set_max_power(const double val);

  void __set_min_power(const double val);

  void __set_max_moment(const double val);

  void __set_min_moment(const double val);

  void __set_max_neck_moment(const double val);

  void __set_min_neck_moment(const double val);

  void __set_max_neck_angle(const double val);

  void __set_min_neck_angle(const double val);

  void __set_visible_angle(const double val);

  void __set_visible_distance(const double val);

  void __set_wind_dir(const double val);

  void __set_wind_force(const double val);

  void __set_wind_angle(const double val);

  void __set_wind_rand(const double val);

  void __set_kickable_area(const double val);

  void __set_catch_area_l(const double val);

  void __set_catch_area_w(const double val);

  void __set_catch_probability(const double val);

  void __set_goalie_max_moves(const int32_t val);

  void __set_corner_kick_margin(const double val);

  void __set_offside_active_area_size(const double val);

  void __set_wind_none(const bool val);

  void __set_use_wind_random(const bool val);

  void __set_coach_say_count_max(const int32_t val);

  void __set_coach_say_msg_size(const int32_t val);

  void __set_clang_win_size(const int32_t val);

  void __set_clang_define_win(const int32_t val);

  void __set_clang_meta_win(const int32_t val);

  void __set_clang_advice_win(const int32_t val);

  void __set_clang_info_win(const int32_t val);

  void __set_clang_mess_delay(const int32_t val);

  void __set_clang_mess_per_cycle(const int32_t val);

  void __set_half_time(const int32_t val);

  void __set_simulator_step(const int32_t val);

  void __set_send_step(const int32_t val);

  void __set_recv_step(const int32_t val);

  void __set_sense_body_step(const int32_t val);

  void __set_lcm_step(const int32_t val);

  void __set_player_say_msg_size(const int32_t val);

  void __set_player_hear_max(const int32_t val);

  void __set_player_hear_inc(const int32_t val);

  void __set_player_hear_decay(const int32_t val);

  void __set_catch_ban_cycle(const int32_t val);

  void __set_slow_down_factor(const int32_t val);

  void __set_use_offside(const bool val);

  void __set_kickoff_offside(const bool val);

  void __set_offside_kick_margin(const double val);

  void __set_audio_cut_dist(const double val);

  void __set_dist_quantize_step(const double val);

  void __set_landmark_dist_quantize_step(const double val);

  void __set_dir_quantize_step(const double val);

  void __set_dist_quantize_step_l(const double val);

  void __set_dist_quantize_step_r(const double val);

  void __set_landmark_dist_quantize_step_l(const double val);

  void __set_landmark_dist_quantize_step_r(const double val);

  void __set_dir_quantize_step_l(const double val);

  void __set_dir_quantize_step_r(const double val);

  void __set_coach_mode(const bool val);

  void __set_coach_with_referee_mode(const bool val);

  void __set_use_old_coach_hear(const bool val);

  void __set_slowness_on_top_for_left_team(const double val);

  void __set_slowness_on_top_for_right_team(const double val);

  void __set_start_goal_l(const int32_t val);

  void __set_start_goal_r(const int32_t val);

  void __set_fullstate_l(const bool val);

  void __set_fullstate_r(const bool val);

  void __set_drop_ball_time(const int32_t val);

  void __set_synch_mode(const bool val);

  void __set_synch_offset(const int32_t val);

  void __set_synch_micro_sleep(const int32_t val);

  void __set_point_to_ban(const int32_t val);

  void __set_point_to_duration(const int32_t val);

  void __set_player_port(const int32_t val);

  void __set_trainer_port(const int32_t val);

  void __set_online_coach_port(const int32_t val);

  void __set_verbose_mode(const bool val);

  void __set_coach_send_vi_step(const int32_t val);

  void __set_replay_file(const std::string& val);

  void __set_landmark_file(const std::string& val);

  void __set_send_comms(const bool val);

  void __set_text_logging(const bool val);

  void __set_game_logging(const bool val);

  void __set_game_log_version(const int32_t val);

  void __set_text_log_dir(const std::string& val);

  void __set_game_log_dir(const std::string& val);

  void __set_text_log_fixed_name(const std::string& val);

  void __set_game_log_fixed_name(const std::string& val);

  void __set_use_text_log_fixed(const bool val);

  void __set_use_game_log_fixed(const bool val);

  void __set_use_text_log_dated(const bool val);

  void __set_use_game_log_dated(const bool val);

  void __set_log_date_format(const std::string& val);

  void __set_log_times(const bool val);

  void __set_record_message(const bool val);

  void __set_text_log_compression(const int32_t val);

  void __set_game_log_compression(const int32_t val);

  void __set_use_profile(const bool val);

  void __set_tackle_dist(const double val);

  void __set_tackle_back_dist(const double val);

  void __set_tackle_width(const double val);

  void __set_tackle_exponent(const double val);

  void __set_tackle_cycles(const int32_t val);

  void __set_tackle_power_rate(const double val);

  void __set_freeform_wait_period(const int32_t val);

  void __set_freeform_send_period(const int32_t val);

  void __set_free_kick_faults(const bool val);

  void __set_back_passes(const bool val);

  void __set_proper_goal_kicks(const bool val);

  void __set_stopped_ball_vel(const double val);

  void __set_max_goal_kicks(const int32_t val);

  void __set_clang_del_win(const int32_t val);

  void __set_clang_rule_win(const int32_t val);

  void __set_auto_mode(const bool val);

  void __set_kick_off_wait(const int32_t val);

  void __set_connect_wait(const int32_t val);

  void __set_game_over_wait(const int32_t val);

  void __set_team_l_start(const std::string& val);

  void __set_team_r_start(const std::string& val);

  void __set_keepaway_mode(const bool val);

  void __set_keepaway_length(const double val);

  void __set_keepaway_width(const double val);

  void __set_keepaway_logging(const bool val);

  void __set_keepaway_log_dir(const std::string& val);

  void __set_keepaway_log_fixed_name(const std::string& val);

  void __set_keepaway_log_fixed(const bool val);

  void __set_keepaway_log_dated(const bool val);

  void __set_keepaway_start(const int32_t val);

  void __set_nr_normal_halfs(const int32_t val);

  void __set_nr_extra_halfs(const int32_t val);

  void __set_penalty_shoot_outs(const bool val);

  void __set_pen_before_setup_wait(const int32_t val);

  void __set_pen_setup_wait(const int32_t val);

  void __set_pen_ready_wait(const int32_t val);

  void __set_pen_taken_wait(const int32_t val);

  void __set_pen_nr_kicks(const int32_t val);

  void __set_pen_max_extra_kicks(const int32_t val);

  void __set_pen_dist_x(const double val);

  void __set_pen_random_winner(const bool val);

  void __set_pen_allow_mult_kicks(const bool val);

  void __set_pen_max_goalie_dist_x(const double val);

  void __set_pen_coach_moves_players(const bool val);

  void __set_module_dir(const std::string& val);

  void __set_ball_stuck_area(const double val);

  void __set_coach_msg_file(const std::string& val);

  void __set_max_tackle_power(const double val);

  void __set_max_back_tackle_power(const double val);

  void __set_player_speed_max_min(const double val);

  void __set_extra_stamina(const double val);

  void __set_synch_see_offset(const int32_t val);

  void __set_extra_half_time(const int32_t val);

  void __set_stamina_capacity(const double val);

  void __set_max_dash_angle(const double val);

  void __set_min_dash_angle(const double val);

  void __set_dash_angle_step(const double val);

  void __set_side_dash_rate(const double val);

  void __set_back_dash_rate(const double val);

  void __set_max_dash_power(const double val);

  void __set_min_dash_power(const double val);

  void __set_tackle_rand_factor(const double val);

  void __set_foul_detect_probability(const double val);

  void __set_foul_exponent(const double val);

  void __set_foul_cycles(const int32_t val);

  void __set_golden_goal(const bool val);

  void __set_red_card_probability(const double val);

  void __set_illegal_defense_duration(const int32_t val);

  void __set_illegal_defense_number(const int32_t val);

  void __set_illegal_defense_dist_x(const double val);

  void __set_illegal_defense_width(const double val);

  void __set_fixed_teamname_l(const std::string& val);

  void __set_fixed_teamname_r(const std::string& val);

  void __set_max_catch_angle(const double val);

  void __set_min_catch_angle(const double val);

  void __set_random_seed(const int32_t val);

  void __set_long_kick_power_factor(const double val);

  void __set_long_kick_delay(const int32_t val);

  void __set_max_monitors(const int32_t val);

  void __set_catchable_area(const double val);

  void __set_real_speed_max(const double val);

  void __set_pitch_half_length(const double val);

  void __set_pitch_half_width(const double val);

  void __set_our_penalty_area_line_x(const double val);

  void __set_their_penalty_area_line_x(const double val);

  void __set_penalty_area_half_width(const double val);

  void __set_penalty_area_length(const double val);

  void __set_goal_width(const double val);

  bool operator == (const ServerParam & rhs) const
  {
    if (!(agent_type == rhs.agent_type))
      return false;
    if (!(inertia_moment == rhs.inertia_moment))
      return false;
    if (!(player_size == rhs.player_size))
      return false;
    if (!(player_decay == rhs.player_decay))
      return false;
    if (!(player_rand == rhs.player_rand))
      return false;
    if (!(player_weight == rhs.player_weight))
      return false;
    if (!(player_speed_max == rhs.player_speed_max))
      return false;
    if (!(player_accel_max == rhs.player_accel_max))
      return false;
    if (!(stamina_max == rhs.stamina_max))
      return false;
    if (!(stamina_inc_max == rhs.stamina_inc_max))
      return false;
    if (!(recover_init == rhs.recover_init))
      return false;
    if (!(recover_dec_thr == rhs.recover_dec_thr))
      return false;
    if (!(recover_min == rhs.recover_min))
      return false;
    if (!(recover_dec == rhs.recover_dec))
      return false;
    if (!(effort_init == rhs.effort_init))
      return false;
    if (!(effort_dec_thr == rhs.effort_dec_thr))
      return false;
    if (!(effort_min == rhs.effort_min))
      return false;
    if (!(effort_dec == rhs.effort_dec))
      return false;
    if (!(effort_inc_thr == rhs.effort_inc_thr))
      return false;
    if (!(effort_inc == rhs.effort_inc))
      return false;
    if (!(kick_rand == rhs.kick_rand))
      return false;
    if (!(team_actuator_noise == rhs.team_actuator_noise))
      return false;
    if (!(player_rand_factor_l == rhs.player_rand_factor_l))
      return false;
    if (!(player_rand_factor_r == rhs.player_rand_factor_r))
      return false;
    if (!(kick_rand_factor_l == rhs.kick_rand_factor_l))
      return false;
    if (!(kick_rand_factor_r == rhs.kick_rand_factor_r))
      return false;
    if (!(ball_size == rhs.ball_size))
      return false;
    if (!(ball_decay == rhs.ball_decay))
      return false;
    if (!(ball_rand == rhs.ball_rand))
      return false;
    if (!(ball_weight == rhs.ball_weight))
      return false;
    if (!(ball_speed_max == rhs.ball_speed_max))
      return false;
    if (!(ball_accel_max == rhs.ball_accel_max))
      return false;
    if (!(dash_power_rate == rhs.dash_power_rate))
      return false;
    if (!(kick_power_rate == rhs.kick_power_rate))
      return false;
    if (!(kickable_margin == rhs.kickable_margin))
      return false;
    if (!(control_radius == rhs.control_radius))
      return false;
    if (!(control_radius_width == rhs.control_radius_width))
      return false;
    if (!(max_power == rhs.max_power))
      return false;
    if (!(min_power == rhs.min_power))
      return false;
    if (!(max_moment == rhs.max_moment))
      return false;
    if (!(min_moment == rhs.min_moment))
      return false;
    if (!(max_neck_moment == rhs.max_neck_moment))
      return false;
    if (!(min_neck_moment == rhs.min_neck_moment))
      return false;
    if (!(max_neck_angle == rhs.max_neck_angle))
      return false;
    if (!(min_neck_angle == rhs.min_neck_angle))
      return false;
    if (!(visible_angle == rhs.visible_angle))
      return false;
    if (!(visible_distance == rhs.visible_distance))
      return false;
    if (!(wind_dir == rhs.wind_dir))
      return false;
    if (!(wind_force == rhs.wind_force))
      return false;
    if (!(wind_angle == rhs.wind_angle))
      return false;
    if (!(wind_rand == rhs.wind_rand))
      return false;
    if (!(kickable_area == rhs.kickable_area))
      return false;
    if (!(catch_area_l == rhs.catch_area_l))
      return false;
    if (!(catch_area_w == rhs.catch_area_w))
      return false;
    if (!(catch_probability == rhs.catch_probability))
      return false;
    if (!(goalie_max_moves == rhs.goalie_max_moves))
      return false;
    if (!(corner_kick_margin == rhs.corner_kick_margin))
      return false;
    if (!(offside_active_area_size == rhs.offside_active_area_size))
      return false;
    if (!(wind_none == rhs.wind_none))
      return false;
    if (!(use_wind_random == rhs.use_wind_random))
      return false;
    if (!(coach_say_count_max == rhs.coach_say_count_max))
      return false;
    if (!(coach_say_msg_size == rhs.coach_say_msg_size))
      return false;
    if (!(clang_win_size == rhs.clang_win_size))
      return false;
    if (!(clang_define_win == rhs.clang_define_win))
      return false;
    if (!(clang_meta_win == rhs.clang_meta_win))
      return false;
    if (!(clang_advice_win == rhs.clang_advice_win))
      return false;
    if (!(clang_info_win == rhs.clang_info_win))
      return false;
    if (!(clang_mess_delay == rhs.clang_mess_delay))
      return false;
    if (!(clang_mess_per_cycle == rhs.clang_mess_per_cycle))
      return false;
    if (!(half_time == rhs.half_time))
      return false;
    if (!(simulator_step == rhs.simulator_step))
      return false;
    if (!(send_step == rhs.send_step))
      return false;
    if (!(recv_step == rhs.recv_step))
      return false;
    if (!(sense_body_step == rhs.sense_body_step))
      return false;
    if (!(lcm_step == rhs.lcm_step))
      return false;
    if (!(player_say_msg_size == rhs.player_say_msg_size))
      return false;
    if (!(player_hear_max == rhs.player_hear_max))
      return false;
    if (!(player_hear_inc == rhs.player_hear_inc))
      return false;
    if (!(player_hear_decay == rhs.player_hear_decay))
      return false;
    if (!(catch_ban_cycle == rhs.catch_ban_cycle))
      return false;
    if (!(slow_down_factor == rhs.slow_down_factor))
      return false;
    if (!(use_offside == rhs.use_offside))
      return false;
    if (!(kickoff_offside == rhs.kickoff_offside))
      return false;
    if (!(offside_kick_margin == rhs.offside_kick_margin))
      return false;
    if (!(audio_cut_dist == rhs.audio_cut_dist))
      return false;
    if (!(dist_quantize_step == rhs.dist_quantize_step))
      return false;
    if (!(landmark_dist_quantize_step == rhs.landmark_dist_quantize_step))
      return false;
    if (!(dir_quantize_step == rhs.dir_quantize_step))
      return false;
    if (!(dist_quantize_step_l == rhs.dist_quantize_step_l))
      return false;
    if (!(dist_quantize_step_r == rhs.dist_quantize_step_r))
      return false;
    if (!(landmark_dist_quantize_step_l == rhs.landmark_dist_quantize_step_l))
      return false;
    if (!(landmark_dist_quantize_step_r == rhs.landmark_dist_quantize_step_r))
      return false;
    if (!(dir_quantize_step_l == rhs.dir_quantize_step_l))
      return false;
    if (!(dir_quantize_step_r == rhs.dir_quantize_step_r))
      return false;
    if (!(coach_mode == rhs.coach_mode))
      return false;
    if (!(coach_with_referee_mode == rhs.coach_with_referee_mode))
      return false;
    if (!(use_old_coach_hear == rhs.use_old_coach_hear))
      return false;
    if (!(slowness_on_top_for_left_team == rhs.slowness_on_top_for_left_team))
      return false;
    if (!(slowness_on_top_for_right_team == rhs.slowness_on_top_for_right_team))
      return false;
    if (!(start_goal_l == rhs.start_goal_l))
      return false;
    if (!(start_goal_r == rhs.start_goal_r))
      return false;
    if (!(fullstate_l == rhs.fullstate_l))
      return false;
    if (!(fullstate_r == rhs.fullstate_r))
      return false;
    if (!(drop_ball_time == rhs.drop_ball_time))
      return false;
    if (!(synch_mode == rhs.synch_mode))
      return false;
    if (!(synch_offset == rhs.synch_offset))
      return false;
    if (!(synch_micro_sleep == rhs.synch_micro_sleep))
      return false;
    if (!(point_to_ban == rhs.point_to_ban))
      return false;
    if (!(point_to_duration == rhs.point_to_duration))
      return false;
    if (!(player_port == rhs.player_port))
      return false;
    if (!(trainer_port == rhs.trainer_port))
      return false;
    if (!(online_coach_port == rhs.online_coach_port))
      return false;
    if (!(verbose_mode == rhs.verbose_mode))
      return false;
    if (!(coach_send_vi_step == rhs.coach_send_vi_step))
      return false;
    if (!(replay_file == rhs.replay_file))
      return false;
    if (!(landmark_file == rhs.landmark_file))
      return false;
    if (!(send_comms == rhs.send_comms))
      return false;
    if (!(text_logging == rhs.text_logging))
      return false;
    if (!(game_logging == rhs.game_logging))
      return false;
    if (!(game_log_version == rhs.game_log_version))
      return false;
    if (!(text_log_dir == rhs.text_log_dir))
      return false;
    if (!(game_log_dir == rhs.game_log_dir))
      return false;
    if (!(text_log_fixed_name == rhs.text_log_fixed_name))
      return false;
    if (!(game_log_fixed_name == rhs.game_log_fixed_name))
      return false;
    if (!(use_text_log_fixed == rhs.use_text_log_fixed))
      return false;
    if (!(use_game_log_fixed == rhs.use_game_log_fixed))
      return false;
    if (!(use_text_log_dated == rhs.use_text_log_dated))
      return false;
    if (!(use_game_log_dated == rhs.use_game_log_dated))
      return false;
    if (!(log_date_format == rhs.log_date_format))
      return false;
    if (!(log_times == rhs.log_times))
      return false;
    if (!(record_message == rhs.record_message))
      return false;
    if (!(text_log_compression == rhs.text_log_compression))
      return false;
    if (!(game_log_compression == rhs.game_log_compression))
      return false;
    if (!(use_profile == rhs.use_profile))
      return false;
    if (!(tackle_dist == rhs.tackle_dist))
      return false;
    if (!(tackle_back_dist == rhs.tackle_back_dist))
      return false;
    if (!(tackle_width == rhs.tackle_width))
      return false;
    if (!(tackle_exponent == rhs.tackle_exponent))
      return false;
    if (!(tackle_cycles == rhs.tackle_cycles))
      return false;
    if (!(tackle_power_rate == rhs.tackle_power_rate))
      return false;
    if (!(freeform_wait_period == rhs.freeform_wait_period))
      return false;
    if (!(freeform_send_period == rhs.freeform_send_period))
      return false;
    if (!(free_kick_faults == rhs.free_kick_faults))
      return false;
    if (!(back_passes == rhs.back_passes))
      return false;
    if (!(proper_goal_kicks == rhs.proper_goal_kicks))
      return false;
    if (!(stopped_ball_vel == rhs.stopped_ball_vel))
      return false;
    if (!(max_goal_kicks == rhs.max_goal_kicks))
      return false;
    if (!(clang_del_win == rhs.clang_del_win))
      return false;
    if (!(clang_rule_win == rhs.clang_rule_win))
      return false;
    if (!(auto_mode == rhs.auto_mode))
      return false;
    if (!(kick_off_wait == rhs.kick_off_wait))
      return false;
    if (!(connect_wait == rhs.connect_wait))
      return false;
    if (!(game_over_wait == rhs.game_over_wait))
      return false;
    if (!(team_l_start == rhs.team_l_start))
      return false;
    if (!(team_r_start == rhs.team_r_start))
      return false;
    if (!(keepaway_mode == rhs.keepaway_mode))
      return false;
    if (!(keepaway_length == rhs.keepaway_length))
      return false;
    if (!(keepaway_width == rhs.keepaway_width))
      return false;
    if (!(keepaway_logging == rhs.keepaway_logging))
      return false;
    if (!(keepaway_log_dir == rhs.keepaway_log_dir))
      return false;
    if (!(keepaway_log_fixed_name == rhs.keepaway_log_fixed_name))
      return false;
    if (!(keepaway_log_fixed == rhs.keepaway_log_fixed))
      return false;
    if (!(keepaway_log_dated == rhs.keepaway_log_dated))
      return false;
    if (!(keepaway_start == rhs.keepaway_start))
      return false;
    if (!(nr_normal_halfs == rhs.nr_normal_halfs))
      return false;
    if (!(nr_extra_halfs == rhs.nr_extra_halfs))
      return false;
    if (!(penalty_shoot_outs == rhs.penalty_shoot_outs))
      return false;
    if (!(pen_before_setup_wait == rhs.pen_before_setup_wait))
      return false;
    if (!(pen_setup_wait == rhs.pen_setup_wait))
      return false;
    if (!(pen_ready_wait == rhs.pen_ready_wait))
      return false;
    if (!(pen_taken_wait == rhs.pen_taken_wait))
      return false;
    if (!(pen_nr_kicks == rhs.pen_nr_kicks))
      return false;
    if (!(pen_max_extra_kicks == rhs.pen_max_extra_kicks))
      return false;
    if (!(pen_dist_x == rhs.pen_dist_x))
      return false;
    if (!(pen_random_winner == rhs.pen_random_winner))
      return false;
    if (!(pen_allow_mult_kicks == rhs.pen_allow_mult_kicks))
      return false;
    if (!(pen_max_goalie_dist_x == rhs.pen_max_goalie_dist_x))
      return false;
    if (!(pen_coach_moves_players == rhs.pen_coach_moves_players))
      return false;
    if (!(module_dir == rhs.module_dir))
      return false;
    if (!(ball_stuck_area == rhs.ball_stuck_area))
      return false;
    if (!(coach_msg_file == rhs.coach_msg_file))
      return false;
    if (!(max_tackle_power == rhs.max_tackle_power))
      return false;
    if (!(max_back_tackle_power == rhs.max_back_tackle_power))
      return false;
    if (!(player_speed_max_min == rhs.player_speed_max_min))
      return false;
    if (!(extra_stamina == rhs.extra_stamina))
      return false;
    if (!(synch_see_offset == rhs.synch_see_offset))
      return false;
    if (!(extra_half_time == rhs.extra_half_time))
      return false;
    if (!(stamina_capacity == rhs.stamina_capacity))
      return false;
    if (!(max_dash_angle == rhs.max_dash_angle))
      return false;
    if (!(min_dash_angle == rhs.min_dash_angle))
      return false;
    if (!(dash_angle_step == rhs.dash_angle_step))
      return false;
    if (!(side_dash_rate == rhs.side_dash_rate))
      return false;
    if (!(back_dash_rate == rhs.back_dash_rate))
      return false;
    if (!(max_dash_power == rhs.max_dash_power))
      return false;
    if (!(min_dash_power == rhs.min_dash_power))
      return false;
    if (!(tackle_rand_factor == rhs.tackle_rand_factor))
      return false;
    if (!(foul_detect_probability == rhs.foul_detect_probability))
      return false;
    if (!(foul_exponent == rhs.foul_exponent))
      return false;
    if (!(foul_cycles == rhs.foul_cycles))
      return false;
    if (!(golden_goal == rhs.golden_goal))
      return false;
    if (!(red_card_probability == rhs.red_card_probability))
      return false;
    if (!(illegal_defense_duration == rhs.illegal_defense_duration))
      return false;
    if (!(illegal_defense_number == rhs.illegal_defense_number))
      return false;
    if (!(illegal_defense_dist_x == rhs.illegal_defense_dist_x))
      return false;
    if (!(illegal_defense_width == rhs.illegal_defense_width))
      return false;
    if (!(fixed_teamname_l == rhs.fixed_teamname_l))
      return false;
    if (!(fixed_teamname_r == rhs.fixed_teamname_r))
      return false;
    if (!(max_catch_angle == rhs.max_catch_angle))
      return false;
    if (!(min_catch_angle == rhs.min_catch_angle))
      return false;
    if (!(random_seed == rhs.random_seed))
      return false;
    if (!(long_kick_power_factor == rhs.long_kick_power_factor))
      return false;
    if (!(long_kick_delay == rhs.long_kick_delay))
      return false;
    if (!(max_monitors == rhs.max_monitors))
      return false;
    if (!(catchable_area == rhs.catchable_area))
      return false;
    if (!(real_speed_max == rhs.real_speed_max))
      return false;
    if (!(pitch_half_length == rhs.pitch_half_length))
      return false;
    if (!(pitch_half_width == rhs.pitch_half_width))
      return false;
    if (!(our_penalty_area_line_x == rhs.our_penalty_area_line_x))
      return false;
    if (!(their_penalty_area_line_x == rhs.their_penalty_area_line_x))
      return false;
    if (!(penalty_area_half_width == rhs.penalty_area_half_width))
      return false;
    if (!(penalty_area_length == rhs.penalty_area_length))
      return false;
    if (!(goal_width == rhs.goal_width))
      return false;
    return true;
  }
  bool operator != (const ServerParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServerParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ServerParam &a, ServerParam &b);

std::ostream& operator<<(std::ostream& out, const ServerParam& obj);

typedef struct _PlayerParam__isset {
  _PlayerParam__isset() : agent_type(false), player_types(false), subs_max(false), pt_max(false), allow_mult_default_type(false), player_speed_max_delta_min(false), player_speed_max_delta_max(false), stamina_inc_max_delta_factor(false), player_decay_delta_min(false), player_decay_delta_max(false), inertia_moment_delta_factor(false), dash_power_rate_delta_min(false), dash_power_rate_delta_max(false), player_size_delta_factor(false), kickable_margin_delta_min(false), kickable_margin_delta_max(false), kick_rand_delta_factor(false), extra_stamina_delta_min(false), extra_stamina_delta_max(false), effort_max_delta_factor(false), effort_min_delta_factor(false), random_seed(false), new_dash_power_rate_delta_min(false), new_dash_power_rate_delta_max(false), new_stamina_inc_max_delta_factor(false), kick_power_rate_delta_min(false), kick_power_rate_delta_max(false), foul_detect_probability_delta_factor(false), catchable_area_l_stretch_min(false), catchable_area_l_stretch_max(false) {}
  bool agent_type :1;
  bool player_types :1;
  bool subs_max :1;
  bool pt_max :1;
  bool allow_mult_default_type :1;
  bool player_speed_max_delta_min :1;
  bool player_speed_max_delta_max :1;
  bool stamina_inc_max_delta_factor :1;
  bool player_decay_delta_min :1;
  bool player_decay_delta_max :1;
  bool inertia_moment_delta_factor :1;
  bool dash_power_rate_delta_min :1;
  bool dash_power_rate_delta_max :1;
  bool player_size_delta_factor :1;
  bool kickable_margin_delta_min :1;
  bool kickable_margin_delta_max :1;
  bool kick_rand_delta_factor :1;
  bool extra_stamina_delta_min :1;
  bool extra_stamina_delta_max :1;
  bool effort_max_delta_factor :1;
  bool effort_min_delta_factor :1;
  bool random_seed :1;
  bool new_dash_power_rate_delta_min :1;
  bool new_dash_power_rate_delta_max :1;
  bool new_stamina_inc_max_delta_factor :1;
  bool kick_power_rate_delta_min :1;
  bool kick_power_rate_delta_max :1;
  bool foul_detect_probability_delta_factor :1;
  bool catchable_area_l_stretch_min :1;
  bool catchable_area_l_stretch_max :1;
} _PlayerParam__isset;

class PlayerParam : public virtual ::apache::thrift::TBase {
 public:

  PlayerParam(const PlayerParam&) noexcept;
  PlayerParam& operator=(const PlayerParam&) noexcept;
  PlayerParam() noexcept
              : agent_type(static_cast<AgentType::type>(0)),
                player_types(0),
                subs_max(0),
                pt_max(0),
                allow_mult_default_type(0),
                player_speed_max_delta_min(0),
                player_speed_max_delta_max(0),
                stamina_inc_max_delta_factor(0),
                player_decay_delta_min(0),
                player_decay_delta_max(0),
                inertia_moment_delta_factor(0),
                dash_power_rate_delta_min(0),
                dash_power_rate_delta_max(0),
                player_size_delta_factor(0),
                kickable_margin_delta_min(0),
                kickable_margin_delta_max(0),
                kick_rand_delta_factor(0),
                extra_stamina_delta_min(0),
                extra_stamina_delta_max(0),
                effort_max_delta_factor(0),
                effort_min_delta_factor(0),
                random_seed(0),
                new_dash_power_rate_delta_min(0),
                new_dash_power_rate_delta_max(0),
                new_stamina_inc_max_delta_factor(0),
                kick_power_rate_delta_min(0),
                kick_power_rate_delta_max(0),
                foul_detect_probability_delta_factor(0),
                catchable_area_l_stretch_min(0),
                catchable_area_l_stretch_max(0) {
  }

  virtual ~PlayerParam() noexcept;
  /**
   * 
   * @see AgentType
   */
  AgentType::type agent_type;
  int32_t player_types;
  int32_t subs_max;
  int32_t pt_max;
  bool allow_mult_default_type;
  double player_speed_max_delta_min;
  double player_speed_max_delta_max;
  double stamina_inc_max_delta_factor;
  double player_decay_delta_min;
  double player_decay_delta_max;
  double inertia_moment_delta_factor;
  double dash_power_rate_delta_min;
  double dash_power_rate_delta_max;
  double player_size_delta_factor;
  double kickable_margin_delta_min;
  double kickable_margin_delta_max;
  double kick_rand_delta_factor;
  double extra_stamina_delta_min;
  double extra_stamina_delta_max;
  double effort_max_delta_factor;
  double effort_min_delta_factor;
  int32_t random_seed;
  double new_dash_power_rate_delta_min;
  double new_dash_power_rate_delta_max;
  double new_stamina_inc_max_delta_factor;
  double kick_power_rate_delta_min;
  double kick_power_rate_delta_max;
  double foul_detect_probability_delta_factor;
  double catchable_area_l_stretch_min;
  double catchable_area_l_stretch_max;

  _PlayerParam__isset __isset;

  void __set_agent_type(const AgentType::type val);

  void __set_player_types(const int32_t val);

  void __set_subs_max(const int32_t val);

  void __set_pt_max(const int32_t val);

  void __set_allow_mult_default_type(const bool val);

  void __set_player_speed_max_delta_min(const double val);

  void __set_player_speed_max_delta_max(const double val);

  void __set_stamina_inc_max_delta_factor(const double val);

  void __set_player_decay_delta_min(const double val);

  void __set_player_decay_delta_max(const double val);

  void __set_inertia_moment_delta_factor(const double val);

  void __set_dash_power_rate_delta_min(const double val);

  void __set_dash_power_rate_delta_max(const double val);

  void __set_player_size_delta_factor(const double val);

  void __set_kickable_margin_delta_min(const double val);

  void __set_kickable_margin_delta_max(const double val);

  void __set_kick_rand_delta_factor(const double val);

  void __set_extra_stamina_delta_min(const double val);

  void __set_extra_stamina_delta_max(const double val);

  void __set_effort_max_delta_factor(const double val);

  void __set_effort_min_delta_factor(const double val);

  void __set_random_seed(const int32_t val);

  void __set_new_dash_power_rate_delta_min(const double val);

  void __set_new_dash_power_rate_delta_max(const double val);

  void __set_new_stamina_inc_max_delta_factor(const double val);

  void __set_kick_power_rate_delta_min(const double val);

  void __set_kick_power_rate_delta_max(const double val);

  void __set_foul_detect_probability_delta_factor(const double val);

  void __set_catchable_area_l_stretch_min(const double val);

  void __set_catchable_area_l_stretch_max(const double val);

  bool operator == (const PlayerParam & rhs) const
  {
    if (!(agent_type == rhs.agent_type))
      return false;
    if (!(player_types == rhs.player_types))
      return false;
    if (!(subs_max == rhs.subs_max))
      return false;
    if (!(pt_max == rhs.pt_max))
      return false;
    if (!(allow_mult_default_type == rhs.allow_mult_default_type))
      return false;
    if (!(player_speed_max_delta_min == rhs.player_speed_max_delta_min))
      return false;
    if (!(player_speed_max_delta_max == rhs.player_speed_max_delta_max))
      return false;
    if (!(stamina_inc_max_delta_factor == rhs.stamina_inc_max_delta_factor))
      return false;
    if (!(player_decay_delta_min == rhs.player_decay_delta_min))
      return false;
    if (!(player_decay_delta_max == rhs.player_decay_delta_max))
      return false;
    if (!(inertia_moment_delta_factor == rhs.inertia_moment_delta_factor))
      return false;
    if (!(dash_power_rate_delta_min == rhs.dash_power_rate_delta_min))
      return false;
    if (!(dash_power_rate_delta_max == rhs.dash_power_rate_delta_max))
      return false;
    if (!(player_size_delta_factor == rhs.player_size_delta_factor))
      return false;
    if (!(kickable_margin_delta_min == rhs.kickable_margin_delta_min))
      return false;
    if (!(kickable_margin_delta_max == rhs.kickable_margin_delta_max))
      return false;
    if (!(kick_rand_delta_factor == rhs.kick_rand_delta_factor))
      return false;
    if (!(extra_stamina_delta_min == rhs.extra_stamina_delta_min))
      return false;
    if (!(extra_stamina_delta_max == rhs.extra_stamina_delta_max))
      return false;
    if (!(effort_max_delta_factor == rhs.effort_max_delta_factor))
      return false;
    if (!(effort_min_delta_factor == rhs.effort_min_delta_factor))
      return false;
    if (!(random_seed == rhs.random_seed))
      return false;
    if (!(new_dash_power_rate_delta_min == rhs.new_dash_power_rate_delta_min))
      return false;
    if (!(new_dash_power_rate_delta_max == rhs.new_dash_power_rate_delta_max))
      return false;
    if (!(new_stamina_inc_max_delta_factor == rhs.new_stamina_inc_max_delta_factor))
      return false;
    if (!(kick_power_rate_delta_min == rhs.kick_power_rate_delta_min))
      return false;
    if (!(kick_power_rate_delta_max == rhs.kick_power_rate_delta_max))
      return false;
    if (!(foul_detect_probability_delta_factor == rhs.foul_detect_probability_delta_factor))
      return false;
    if (!(catchable_area_l_stretch_min == rhs.catchable_area_l_stretch_min))
      return false;
    if (!(catchable_area_l_stretch_max == rhs.catchable_area_l_stretch_max))
      return false;
    return true;
  }
  bool operator != (const PlayerParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PlayerParam &a, PlayerParam &b);

std::ostream& operator<<(std::ostream& out, const PlayerParam& obj);

typedef struct _PlayerType__isset {
  _PlayerType__isset() : agent_type(false), id(false), stamina_inc_max(false), player_decay(false), inertia_moment(false), dash_power_rate(false), player_size(false), kickable_margin(false), kick_rand(false), extra_stamina(false), effort_max(false), effort_min(false), kick_power_rate(false), foul_detect_probability(false), catchable_area_l_stretch(false), unum_far_length(false), unum_too_far_length(false), team_far_length(false), team_too_far_length(false), player_max_observation_length(false), ball_vel_far_length(false), ball_vel_too_far_length(false), ball_max_observation_length(false), flag_chg_far_length(false), flag_chg_too_far_length(false), flag_max_observation_length(false), kickable_area(false), reliable_catchable_dist(false), max_catchable_dist(false), real_speed_max(false), player_speed_max2(false), real_speed_max2(false), cycles_to_reach_max_speed(false), player_speed_max(false) {}
  bool agent_type :1;
  bool id :1;
  bool stamina_inc_max :1;
  bool player_decay :1;
  bool inertia_moment :1;
  bool dash_power_rate :1;
  bool player_size :1;
  bool kickable_margin :1;
  bool kick_rand :1;
  bool extra_stamina :1;
  bool effort_max :1;
  bool effort_min :1;
  bool kick_power_rate :1;
  bool foul_detect_probability :1;
  bool catchable_area_l_stretch :1;
  bool unum_far_length :1;
  bool unum_too_far_length :1;
  bool team_far_length :1;
  bool team_too_far_length :1;
  bool player_max_observation_length :1;
  bool ball_vel_far_length :1;
  bool ball_vel_too_far_length :1;
  bool ball_max_observation_length :1;
  bool flag_chg_far_length :1;
  bool flag_chg_too_far_length :1;
  bool flag_max_observation_length :1;
  bool kickable_area :1;
  bool reliable_catchable_dist :1;
  bool max_catchable_dist :1;
  bool real_speed_max :1;
  bool player_speed_max2 :1;
  bool real_speed_max2 :1;
  bool cycles_to_reach_max_speed :1;
  bool player_speed_max :1;
} _PlayerType__isset;

class PlayerType : public virtual ::apache::thrift::TBase {
 public:

  PlayerType(const PlayerType&) noexcept;
  PlayerType& operator=(const PlayerType&) noexcept;
  PlayerType() noexcept
             : agent_type(static_cast<AgentType::type>(0)),
               id(0),
               stamina_inc_max(0),
               player_decay(0),
               inertia_moment(0),
               dash_power_rate(0),
               player_size(0),
               kickable_margin(0),
               kick_rand(0),
               extra_stamina(0),
               effort_max(0),
               effort_min(0),
               kick_power_rate(0),
               foul_detect_probability(0),
               catchable_area_l_stretch(0),
               unum_far_length(0),
               unum_too_far_length(0),
               team_far_length(0),
               team_too_far_length(0),
               player_max_observation_length(0),
               ball_vel_far_length(0),
               ball_vel_too_far_length(0),
               ball_max_observation_length(0),
               flag_chg_far_length(0),
               flag_chg_too_far_length(0),
               flag_max_observation_length(0),
               kickable_area(0),
               reliable_catchable_dist(0),
               max_catchable_dist(0),
               real_speed_max(0),
               player_speed_max2(0),
               real_speed_max2(0),
               cycles_to_reach_max_speed(0),
               player_speed_max(0) {
  }

  virtual ~PlayerType() noexcept;
  /**
   * 
   * @see AgentType
   */
  AgentType::type agent_type;
  int32_t id;
  double stamina_inc_max;
  double player_decay;
  double inertia_moment;
  double dash_power_rate;
  double player_size;
  double kickable_margin;
  double kick_rand;
  double extra_stamina;
  double effort_max;
  double effort_min;
  double kick_power_rate;
  double foul_detect_probability;
  double catchable_area_l_stretch;
  double unum_far_length;
  double unum_too_far_length;
  double team_far_length;
  double team_too_far_length;
  double player_max_observation_length;
  double ball_vel_far_length;
  double ball_vel_too_far_length;
  double ball_max_observation_length;
  double flag_chg_far_length;
  double flag_chg_too_far_length;
  double flag_max_observation_length;
  double kickable_area;
  double reliable_catchable_dist;
  double max_catchable_dist;
  double real_speed_max;
  double player_speed_max2;
  double real_speed_max2;
  int32_t cycles_to_reach_max_speed;
  double player_speed_max;

  _PlayerType__isset __isset;

  void __set_agent_type(const AgentType::type val);

  void __set_id(const int32_t val);

  void __set_stamina_inc_max(const double val);

  void __set_player_decay(const double val);

  void __set_inertia_moment(const double val);

  void __set_dash_power_rate(const double val);

  void __set_player_size(const double val);

  void __set_kickable_margin(const double val);

  void __set_kick_rand(const double val);

  void __set_extra_stamina(const double val);

  void __set_effort_max(const double val);

  void __set_effort_min(const double val);

  void __set_kick_power_rate(const double val);

  void __set_foul_detect_probability(const double val);

  void __set_catchable_area_l_stretch(const double val);

  void __set_unum_far_length(const double val);

  void __set_unum_too_far_length(const double val);

  void __set_team_far_length(const double val);

  void __set_team_too_far_length(const double val);

  void __set_player_max_observation_length(const double val);

  void __set_ball_vel_far_length(const double val);

  void __set_ball_vel_too_far_length(const double val);

  void __set_ball_max_observation_length(const double val);

  void __set_flag_chg_far_length(const double val);

  void __set_flag_chg_too_far_length(const double val);

  void __set_flag_max_observation_length(const double val);

  void __set_kickable_area(const double val);

  void __set_reliable_catchable_dist(const double val);

  void __set_max_catchable_dist(const double val);

  void __set_real_speed_max(const double val);

  void __set_player_speed_max2(const double val);

  void __set_real_speed_max2(const double val);

  void __set_cycles_to_reach_max_speed(const int32_t val);

  void __set_player_speed_max(const double val);

  bool operator == (const PlayerType & rhs) const
  {
    if (!(agent_type == rhs.agent_type))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(stamina_inc_max == rhs.stamina_inc_max))
      return false;
    if (!(player_decay == rhs.player_decay))
      return false;
    if (!(inertia_moment == rhs.inertia_moment))
      return false;
    if (!(dash_power_rate == rhs.dash_power_rate))
      return false;
    if (!(player_size == rhs.player_size))
      return false;
    if (!(kickable_margin == rhs.kickable_margin))
      return false;
    if (!(kick_rand == rhs.kick_rand))
      return false;
    if (!(extra_stamina == rhs.extra_stamina))
      return false;
    if (!(effort_max == rhs.effort_max))
      return false;
    if (!(effort_min == rhs.effort_min))
      return false;
    if (!(kick_power_rate == rhs.kick_power_rate))
      return false;
    if (!(foul_detect_probability == rhs.foul_detect_probability))
      return false;
    if (!(catchable_area_l_stretch == rhs.catchable_area_l_stretch))
      return false;
    if (!(unum_far_length == rhs.unum_far_length))
      return false;
    if (!(unum_too_far_length == rhs.unum_too_far_length))
      return false;
    if (!(team_far_length == rhs.team_far_length))
      return false;
    if (!(team_too_far_length == rhs.team_too_far_length))
      return false;
    if (!(player_max_observation_length == rhs.player_max_observation_length))
      return false;
    if (!(ball_vel_far_length == rhs.ball_vel_far_length))
      return false;
    if (!(ball_vel_too_far_length == rhs.ball_vel_too_far_length))
      return false;
    if (!(ball_max_observation_length == rhs.ball_max_observation_length))
      return false;
    if (!(flag_chg_far_length == rhs.flag_chg_far_length))
      return false;
    if (!(flag_chg_too_far_length == rhs.flag_chg_too_far_length))
      return false;
    if (!(flag_max_observation_length == rhs.flag_max_observation_length))
      return false;
    if (!(kickable_area == rhs.kickable_area))
      return false;
    if (!(reliable_catchable_dist == rhs.reliable_catchable_dist))
      return false;
    if (!(max_catchable_dist == rhs.max_catchable_dist))
      return false;
    if (!(real_speed_max == rhs.real_speed_max))
      return false;
    if (!(player_speed_max2 == rhs.player_speed_max2))
      return false;
    if (!(real_speed_max2 == rhs.real_speed_max2))
      return false;
    if (!(cycles_to_reach_max_speed == rhs.cycles_to_reach_max_speed))
      return false;
    if (!(player_speed_max == rhs.player_speed_max))
      return false;
    return true;
  }
  bool operator != (const PlayerType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PlayerType &a, PlayerType &b);

std::ostream& operator<<(std::ostream& out, const PlayerType& obj);


class Empty : public virtual ::apache::thrift::TBase {
 public:

  Empty(const Empty&) noexcept;
  Empty& operator=(const Empty&) noexcept;
  Empty() noexcept {
  }

  virtual ~Empty() noexcept;

  bool operator == (const Empty & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Empty &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Empty & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Empty &a, Empty &b);

std::ostream& operator<<(std::ostream& out, const Empty& obj);

typedef struct _RegisterRequest__isset {
  _RegisterRequest__isset() : agent_type(false), team_name(false), uniform_number(false) {}
  bool agent_type :1;
  bool team_name :1;
  bool uniform_number :1;
} _RegisterRequest__isset;

class RegisterRequest : public virtual ::apache::thrift::TBase {
 public:

  RegisterRequest(const RegisterRequest&);
  RegisterRequest& operator=(const RegisterRequest&);
  RegisterRequest() noexcept
                  : agent_type(static_cast<AgentType::type>(0)),
                    team_name(),
                    uniform_number(0) {
  }

  virtual ~RegisterRequest() noexcept;
  /**
   * 
   * @see AgentType
   */
  AgentType::type agent_type;
  std::string team_name;
  int32_t uniform_number;

  _RegisterRequest__isset __isset;

  void __set_agent_type(const AgentType::type val);

  void __set_team_name(const std::string& val);

  void __set_uniform_number(const int32_t val);

  bool operator == (const RegisterRequest & rhs) const
  {
    if (!(agent_type == rhs.agent_type))
      return false;
    if (!(team_name == rhs.team_name))
      return false;
    if (!(uniform_number == rhs.uniform_number))
      return false;
    return true;
  }
  bool operator != (const RegisterRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RegisterRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RegisterRequest &a, RegisterRequest &b);

std::ostream& operator<<(std::ostream& out, const RegisterRequest& obj);

typedef struct _RegisterResponse__isset {
  _RegisterResponse__isset() : client_id(false) {}
  bool client_id :1;
} _RegisterResponse__isset;

class RegisterResponse : public virtual ::apache::thrift::TBase {
 public:

  RegisterResponse(const RegisterResponse&) noexcept;
  RegisterResponse& operator=(const RegisterResponse&) noexcept;
  RegisterResponse() noexcept
                   : client_id(0) {
  }

  virtual ~RegisterResponse() noexcept;
  int32_t client_id;

  _RegisterResponse__isset __isset;

  void __set_client_id(const int32_t val);

  bool operator == (const RegisterResponse & rhs) const
  {
    if (!(client_id == rhs.client_id))
      return false;
    return true;
  }
  bool operator != (const RegisterResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RegisterResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RegisterResponse &a, RegisterResponse &b);

std::ostream& operator<<(std::ostream& out, const RegisterResponse& obj);

} // namespace

#endif
